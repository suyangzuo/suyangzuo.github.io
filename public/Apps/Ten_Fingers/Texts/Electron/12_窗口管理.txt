Advanced window management is essential for complex Electron apps - like tools with separate settings windows or multi-document interfaces. Electron's BrowserWindow module offers more than basic window creation; it supports multi-window workflows, modal dialogs, and state persistence, ensuring a smooth user experience across sessions.​
For multi-window setups, start by creating secondary windows from the main process. When a user clicks a "Settings" button in the main window, send an IPC message to the main process (e.g., ipcRenderer.send('open-settings-window')). In the main process, listen for this message and create a new BrowserWindow: ipcMain.on('open-settings-window', () => { const settingsWindow = new BrowserWindow({ width: 600, height: 400, parent: mainWindow, modal: true }); settingsWindow.loadFile('settings.html'); }). The parent option ties the secondary window to the main window (closing the main window closes the secondary one), and modal: true makes the secondary window a modal (blocks interaction with the main window until closed) - ideal for critical tasks like settings or form submissions.​
Manage window state (size, position) to improve user experience. Users expect apps to remember their preferred window size and position between launches. Use the electron-window-state npm package to simplify this: install it with npm install electron-window-state --save. In the main process, initialize window state before creating the main window: const windowStateKeeper = require('electron-window-state'); const mainWindowState = windowStateKeeper({ defaultWidth: 800, defaultHeight: 600 });. Pass the saved state to BrowserWindow: const mainWindow = new BrowserWindow({ x: mainWindowState.x, y: mainWindowState.y, width: mainWindowState.width, height: mainWindowState.height });, then attach the state manager to the window: mainWindowState.manage(mainWindow);. This automatically saves the window's position and size when closed and restores it on startup.​
Handle window events to prevent data loss. For apps with unsaved changes (e.g., a text editor), listen for the close event on the main window and prompt users to save: mainWindow.on('close', (event) => { if (hasUnsavedChanges) { event.preventDefault(); // Block close dialog.showMessageBox(mainWindow, { type: 'question', title: 'Unsaved Changes', message: 'Do you want to save before closing?', buttons: ['Save', 'Don\'t Save', 'Cancel'] }).then((result) => { if (result.response === 0) saveChanges().then(() => mainWindow.destroy()); else if (result.response === 1) mainWindow.destroy(); }); } });. The event.preventDefault() stops the window from closing immediately, giving you time to handle the save flow.​
Best practices for multi-window apps: Limit the number of open windows to avoid clutter - use tabs (via front-end frameworks like React Router) for related content instead of separate windows. For secondary windows, use webPreferences: { nodeIntegration: false, contextIsolation: true } to maintain security. Test window behavior on different screen resolutions - ensure windows don't go off-screen or have overlapping elements. For apps with many windows, track them in an array (e.g., const openWindows = [];) to manage them collectively (e.g., closing all windows on app quit).​
In short, advanced window management in Electron goes beyond basic creation. By using multi-window setups, modal dialogs, state persistence, and event handling, you can build intuitive apps that adapt to user preferences and prevent data loss.​

