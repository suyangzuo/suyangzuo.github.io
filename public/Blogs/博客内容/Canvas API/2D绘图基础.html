<article class="专题简介">
  <h1 class="简介标题">
    <span><span class="行内专业名词">2D</span>绘图基础</span><span class="原创">原创</span>
  </h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本"
          ><span class="日期文本-数字 日期文本-年">2025</span>年<span class="日期文本-数字 日期文本-月">7</span>月<span
            class="日期文本-数字 日期文本-日"
            >13</span
          >日</span
        >
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">渲染上下文</h2>

    <h3 class="分区标题 分区3级标题">什么是<span class="行内专业名词">渲染上下文</span></h3>
    <p class="分区普通文本">
      在<span class="行内专业名词">Canvas API</span>中，<span class="行内专业名词">渲染上下文</span
      ><span class="附加说明">Context</span>是<span class="行内专业名词">Canvas</span>对象的属性。<span
        class="行内专业名词"
        >渲染上下文</span
      >对象提供了绘制<span class="行内专业名词">Canvas</span>图形的一整套环境，包括绘图接口，状态，以及各种属性。
    </p>
    <p class="分区普通文本"><span class="行内专业名词">渲染上下文</span>包含了多种模式：</p>
    <figure class="截图容器">
      <img src="/Images/Blogs/Canvas API/2D绘图基础/上下文模式.png" alt="Canvas 上下文模式" />
    </figure>
    <p class="分区普通文本">
      其中<span class="行内专业名词">2D</span>是最常用的渲染上下文模式，可以说，<span class="行内专业名词"
        >Canvas API</span
      >主要就是用来绘制<span class="行内专业名词">2D</span>图形的。这在<a
        class="超链接"
        href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API"
        target="_blank"
        >MDN 文档</a
      >中有明确的说明：
    </p>
    <figure class="截图容器">
      <img src="/Images/Blogs/Canvas API/2D绘图基础/聚焦2D_MDN.png" alt="Canvas 聚焦2D" />
    </figure>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        有关<span class="行内专业名词">渲染上下文</span>的权威解释，请参考<a
          class="超链接"
          href="https://html.spec.whatwg.org/multipage/canvas.html"
          target="_blank"
          >W3C 最新规范</a
        >。
      </p>
    </section>

    <h3 class="分区标题 分区3级标题">获取<span class="行内专业名词">渲染上下文</span></h3>
    <p class="分区普通文本">
      调用<span class="行内专业名词">Canvas</span>对象的<span class="行内代码">getContext()</span>方法即可：
    </p>
    <pre>
      <code class="lang-javascript">
        // 先获取canvas元素
        const canvas = document.getElementById("canvas的id");
        
        // 获取2D渲染上下文
        // 上下文的英文是"context"，编程中经常简写为"ctx"
        const ctx = canvas.getContext("2d");
      </code>
    </pre>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        绘图的第一步就是获取<span class="行内专业名词">渲染上下文</span>，没有上下文，绘图就无从谈起。
      </p>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">分辨率缩放</h2>

    <h3 class="分区标题 分区3级标题">什么是<span class="行内专业名词">分辨率缩放</span></h3>
    <p class="分区普通文本">
      现在很多显示器的分辨率都很高，尤其是笔记本电脑，比如我的笔记本是<span class="行内专业名词"
        >Redmi Book Pro 16 2024</span
      >，其屏幕分辨率为<span class="行内专业名词">3072<span class="次要">✗</span>1920</span>，但是屏幕的尺寸只有<span
        class="行内专业名词"
        >16</span
      >英寸，导致的结果就是屏幕的像素密度很高，如果分辨率缩放设置为<span class="行内专业名词">1</span
      >，屏幕上所有的图片、文字会非常小，看着很累。因此我将分辨率缩放设置为<span class="行内专业名词">150%</span
      >，把<span class="行内专业名词">3</span>个像素当作<span class="行内专业名词">2</span
      >个像素用，这样屏幕上的图片、文字都会放大<span class="行内专业名词">1.5</span>倍。
    </p>
    <figure class="截图容器">
      <img src="/Images/Blogs/Canvas API/2D绘图基础/分辨率缩放_Ubuntu.png" alt="分辨率缩放 Ubuntu" />
    </figure>
    <p class="分区普通文本">
      分辨率缩放设置为<span class="行内专业名词">150%</span>，在代码中，就是<span class="行内代码">1.5</span>。
    </p>

    <h3 class="分区标题 分区3级标题">获取<span class="行内专业名词">分辨率缩放值</span></h3>
    <p class="分区普通文本">
      我这台电脑的分辨率缩放是<span class="行内代码">1.5</span>，那么代码中就直接用<span class="行内代码">1.5</span
      >吗？当然不行！因为每个人的电脑分辨率缩放都不一样，如果直接用<span class="行内代码">1.5</span>设计<span
        class="行内专业名词"
        >Canvas图形</span
      >，在我的电脑上看起来是正常的，但另一个人的电脑分辨率缩放如果是<span class="行内代码">1</span
      >，那么在他的电脑上<span class="行内专业名词">Canvas图形</span>看上去就会变得很大。为了让<span
        class="行内专业名词"
        >Canvas图形</span
      >在每个人的电脑上保持一致，代码中就<span class="强调">不能用常数</span>来表示分辨率缩放，而要用变量。<span
        class="行内代码"
        >window.devicePixelRatio</span
      >就是用来获取分辨率缩放的变量。
    </p>
    <pre>
      <code class="lang-javascript">
        const dpr = window.devicePixelRatio || 1;   //获取分辨率缩放值，无法获取则默认为1
        console.log(`分辨率缩放值: ${dpr}`);   //打印分辨率缩放值
      </code>
    </pre>
    <figure class="截图容器">
      <img src="/Images/Blogs/Canvas API/2D绘图基础/打印分辨率缩放值.png" alt="打印分辨率缩放值" />
    </figure>
    <p class="分区普通文本">
      <span class="行内专业名词">分辨率缩放值</span>是<span class="行内代码">2</span>。这也是为什么要用<span
        class="行内代码"
        >window.devicePixelRatio</span
      >的另一个原因：你在操作系统中查到的<span class="行内专业名词">分辨率缩放值</span>和<span class="行内代码"
        >window.devicePixelRatio</span
      >未必一致。
    </p>

    <h3 class="分区标题 分区3级标题">应用<span class="行内专业名词">分辨率缩放值</span></h3>
    <p class="分区普通文本">简单地说就是<span class="行内专业名词">2</span>步：</p>
    <ol class="分区有序列表">
      <li class="分区列表项">
        修改<span class="行内专业名词">Canvas</span>的实际尺寸：<span class="行内专业名词">实际尺寸</span
        ><span class="次要">=</span><span class="行内专业名词">CSS尺寸</span><span class="次要">✗</span
        ><span class="行内专业名词">分辨率缩放值</span>。
        <pre style="margin-bottom: 40px">
          <code class="lang-javascript">
            const dpr = window.devicePixelRatio || 1;    //获取分辨率缩放值，无法获取则默认为1
            canvas.width = canvas.offsetWidth * dpr;     //实际宽度 = CSS宽度 × 分辨率缩放值
            canvas.height = canvas.offsetHeight * dpr;   //实际高度 = CSS高度 × 分辨率缩放值
          </code>
        </pre>
      </li>
      <li class="分区列表项">
        设置<span class="行内专业名词">渲染上下文缩放值</span>：
        <pre>
          <code class="lang-javascript">
            const dpr = window.devicePixelRatio || 1;   //获取分辨率缩放值，无法获取则默认为1
            ctx.scale(dpr, dpr);   //ctx.scale(水平缩放值, 垂直缩放值)
          </code>
        </pre>
      </li>
    </ol>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        <span class="行内代码">canvas.width</span>是实际尺寸，<span class="行内代码">HTMLElement.offsetWidth</span
        >、<span class="行内代码">DOMRect.width</span>都是<span class="行内专业名词 等宽">CSS</span>尺寸。
      </p>
      <pre>
        <code class="lang-html">
          &lt;!-- 这里的 width 和 height 是实际尺寸 --&gt;
          &lt;canvas id="canvas" width="500" height="300"&gt;&lt;/canvas&gt;
        </code>
      </pre>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">基础绘图</h2>

    <h3 class="分区标题 分区3级标题">新建<span class="行内专业名词">路径</span></h3>
    <p class="分区普通文本">
      可以把路径绘图想象成<span class="行内专业名词">Photoshop</span>中的操作，其原理基本一致。我们在<span
        class="行内专业名词"
        >Photoshop</span
      >中想要绘制<span class="行内专业名词">图形</span>，是不是要先新建一个<span class="行内专业名词">路径</span
      >？在<span class="行内专业名词">Canvas</span>中也是一样的。不管你想要画什么图形，都要先新建路径：
    </p>
    <pre>
      <code class="lang-javascript">
        ctx.beginPath();   //新建路径
      </code>
    </pre>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        和<span class="行内专业名词">Photoshop</span>一样，如果没有调用<span class="行内代码">ctx.beginPath()</span
        >，绘制图形时会自动新建路径。如果你在一个路径中一口气绘制了好几个图形，中途没有再新建路径，那么在填充、描边时，这些图形会一起被填充、描边。
      </p>
    </section>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">直线</span></h3>
    <p class="分区普通文本">
      在<span class="行内专业名词">Canvas</span>中，绘制<span class="行内专业名词">直线</span>的方法和<span
        class="行内专业名词"
        >Photoshop</span
      >基本一致：一个起点，一个终点，足矣。但是，光有路径还不够，路径只是一个几何图形的<span class="行内专业名词"
        >逻辑</span
      >，本身是看不见的，想要看见这个图形，我们可以给它<span class="行内专业名词">描边</span>。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- ↓ 获取Canvas 获取渲染上下文 ↓ ----------------
        const canvas = document.getElementById("canvas");   //获取Canvas元素
        const ctx = canvas.getContext("2d");   //获取渲染上下文

        //---------------- ↓ 设置分辨率缩放 ↓ ----------------
        const dpr = window.devicePixelRatio || 1;   //获取分辨率缩放值，无法获取则默认为1
        canvas.width = canvas.offsetWidth * dpr;   //通过分辨率缩放值，修改Canvas的实际宽度
        canvas.height = canvas.offsetHeight * dpr;   //通过分辨率缩放值，修改Canvas的实际高度
        ctx.scale(dpr, dpr);   //通过分辨率缩放值，修改上下文绘图的实际大小

        //---------------- ↓ 绘图 ↓ ----------------
        ctx.beginPath();   //新建路径
        ctx.moveTo(100, 100);   // ctx.moveTo(x, y);  移动到起点
        ctx.lineTo(400, 200);   // ctx.lineTo(x, y);  绘制到终点
        ctx.lineWidth = 2;   //设置描边宽度
        ctx.strokeStyle = "lightskyblue";   //设置描边颜色
        ctx.stroke();   //描边
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-0" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script type="text/javascript">
      const canvas_0 = document.getElementById("canvas-0");
      const ctx = canvas_0.getContext("2d");
      const dpr = window.devicePixelRatio || 1;
      canvas_0.width = canvas_0.offsetWidth * dpr;
      canvas_0.height = canvas_0.offsetHeight * dpr;
      ctx.scale(dpr, dpr);
      ctx.beginPath();
      ctx.moveTo(100, 100);
      ctx.lineTo(400, 200);
      ctx.strokeStyle = "lightskyblue";
      ctx.lineWidth = 2;
      ctx.stroke();
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">矩形</span></h3>
    <p class="分区普通文本">要绘制矩形，需要知道<span class="行内专业名词">2</span>个必要条件：</p>
    <ul class="分区列表">
      <li class="分区列表项">
        矩形的<span class="行内专业名词">坐标</span>，<span class="强调">注意：</span>
        <ul class="分区列表">
          <li class="分区列表项">
            矩形的<span class="行内专业名词">坐标</span>就是矩形<span class="强调">左上角</span>的坐标。
          </li>
          <li class="分区列表项">
            矩形的<span class="行内专业名词">坐标</span>是相对于<span class="行内专业名词">Canvas</span
            ><span class="强调">左上角</span>的。
          </li>
        </ul>
      </li>
      <li class="分区列表项">矩形的<span class="行内专业名词">尺寸</span></li>
    </ul>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75; background: none">
      <div class="canvas-1-container" style="width: 100%; height: calc(100% - 42px)">
        <div class="rect-x-indicator"></div>
        <canvas id="canvas-1" style="width: 100%; height: 100%; background-color: #222"></canvas>
        <div class="rect-y-indicator"></div>
        <div class="canvas-dimension canvas-width"><span class="num">500</span><span class="unit">px</span></div>
        <div class="canvas-dimension canvas-height"><span class="num">500</span><span class="unit">px</span></div>
        <div class="canvas-1-introduction">我是<span class="行内代码">Canvas</span></div>
      </div>
    </figure>
    <p class="分区普通文本">
      矩形<span class="行内专业名词">宽度</span>为<span class="行内代码">150</span>，<span class="行内专业名词"
        >高度</span
      >为<span class="行内代码">100</span>；矩形的坐标就是<span class="行内专业名词"
        >矩形<span class="强调">左上角</span>的坐标</span
      >。
    </p>
    <style>
      .canvas-1-container {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 30px 0 0 40px;
        position: relative;
        width: fit-content;
        margin: 0 auto;
      }

      #canvas-1 {
        width: 100%;
        height: 100%;
        background-color: #222;
        display: block;
        position: relative;
      }

      .canvas-1-introduction {
        position: absolute;
        left: 50%;
        bottom: 10px;
        translate: calc(-50% + 20px) 0;
        font-size: 16px;
        pointer-events: none;
      }

      .rect-x-indicator {
        position: absolute;
        left: 0;
        top: 0;
        font-size: 16px;
        color: lightsteelblue;
        font-family: "Google Sans Code", monospace;
        pointer-events: none;
        user-select: none;
        z-index: 10;
        transform: translate(-50%, -100%);
        /* left/top 由JS动态设置 */
      }
      .rect-y-indicator {
        position: absolute;
        left: 0;
        top: 0;
        font-size: 16px;
        color: lightsteelblue;
        font-family: "Google Sans Code", monospace;
        pointer-events: none;
        user-select: none;
        z-index: 10;
        transform: translate(-100%, -50%);
        /* left/top 由JS动态设置 */
      }

      .canvas-dimension {
        position: absolute;
        font-size: 16px;
        font-family: "Google Sans Code", monospace;
        pointer-events: none;
        user-select: none;
        width: fit-content;
      }
      .canvas-width {
        left: 50%;
        top: 35px;
        text-align: center;
      }
      .canvas-height {
        left: 45px;
        top: 50%;
        text-align: center;
      }
      .canvas-dimension .num {
        color: rgb(50, 164, 143);
        text-shadow: 1px 1px 1px #000a;
      }
      .canvas-dimension .unit {
        color: rgb(182, 121, 61);
        margin-left: 2px;
        text-shadow: 1px 1px 1px #000a;
      }
    </style>
    <script>
      const canvas_1 = document.getElementById("canvas-1");
      const widthNum = document.querySelector(".canvas-width .num");
      const heightNum = document.querySelector(".canvas-height .num");
      if (widthNum) widthNum.textContent = canvas_1.offsetWidth;
      if (heightNum) heightNum.textContent = canvas_1.offsetHeight;
      const rectXIndicator = document.querySelector(".rect-x-indicator");
      const rectYIndicator = document.querySelector(".rect-y-indicator");
      const dpr_1 = window.devicePixelRatio || 1;
      canvas_1.width = canvas_1.offsetWidth * dpr_1;
      canvas_1.height = canvas_1.offsetHeight * dpr_1;
      const ctx_1 = canvas_1.getContext("2d");
      ctx_1.setTransform(1, 0, 0, 1, 0, 0); // 重置变换
      ctx_1.scale(dpr_1, dpr_1);

      const canvas_1_W = canvas_1.offsetWidth;
      const canvas_1_H = canvas_1.offsetHeight;
      const RECT_W = 150;
      const RECT_H = 100;

      let rectX = Math.random() * (canvas_1_W - RECT_W);
      let rectY = Math.random() * (canvas_1_H - RECT_H);
      let vx = (((Math.random() - 0.5) * 4) / 3) * 2;
      let vy = (((Math.random() - 0.5) * 4) / 3) * 2;

      function drawDashedLine(x1, y1, x2, y2) {
        ctx_1.save();
        ctx_1.strokeStyle = "rgba(255,255,255,0.5)";
        ctx_1.setLineDash([8, 6]);
        ctx_1.lineWidth = 2;
        ctx_1.beginPath();
        ctx_1.moveTo(x1, y1);
        ctx_1.lineTo(x2, y2);
        ctx_1.stroke();
        ctx_1.restore();
      }

      function draw() {
        ctx_1.clearRect(0, 0, canvas_1_W, canvas_1_H);
        // 绘制虚线：矩形左上角到上边界
        drawDashedLine(rectX, rectY, rectX, 0);
        // 绘制虚线：矩形左上角到左边界
        drawDashedLine(rectX, rectY, 0, rectY);
        // 绘制矩形
        ctx_1.save();
        ctx_1.fillStyle = "#365";
        ctx_1.fillRect(rectX, rectY, RECT_W, RECT_H);
        ctx_1.restore();

        // 在矩形内部靠下方、水平居中绘制"我是矩形"
        ctx_1.save();
        ctx_1.font = "14px 'Noto Sans SC', sans-serif";
        ctx_1.fillStyle = "#ffa";
        ctx_1.textAlign = "center";
        ctx_1.textBaseline = "bottom";
        ctx_1.fillText("我是矩形", rectX + RECT_W / 2, rectY + RECT_H - 5);
        ctx_1.restore();

        // 在矩形内部绘制宽度和高度数字
        ctx_1.save();
        ctx_1.font = "14px 'Google Sans Code', monospace";
        ctx_1.fillStyle = "white";
        ctx_1.textAlign = "center";
        ctx_1.textBaseline = "top";
        // 宽度数字，顶部居中，距离顶部5px
        ctx_1.fillText(RECT_W, rectX + RECT_W / 2, rectY + 5);
        // 高度数字，左侧居中，距离左边5px
        ctx_1.textAlign = "left";
        ctx_1.textBaseline = "middle";
        ctx_1.fillText(RECT_H, rectX + 5, rectY + RECT_H / 2);
        ctx_1.restore();

        // 更新外部坐标指示器
        if (rectXIndicator) {
          rectXIndicator.style.left = `${rectX + canvas_1.offsetLeft}px`;
          rectXIndicator.style.top = `${canvas_1.offsetTop - 10}px`;
          rectXIndicator.textContent = Math.round(rectX);
        }
        if (rectYIndicator) {
          rectYIndicator.style.left = `${canvas_1.offsetLeft - 10}px`;
          rectYIndicator.style.top = `${rectY + canvas_1.offsetTop}px`;
          rectYIndicator.textContent = Math.round(rectY);
        }
      }

      function update() {
        rectX += vx;
        rectY += vy;
        // 碰到边界反弹
        if (rectX < 0) {
          rectX = 0;
          vx = -vx;
        }
        if (rectY < 0) {
          rectY = 0;
          vy = -vy;
        }
        if (rectX > canvas_1_W - RECT_W) {
          rectX = canvas_1_W - RECT_W;
          vx = -vx;
        }
        if (rectY > canvas_1_H - RECT_H) {
          rectY = canvas_1_H - RECT_H;
          vy = -vy;
        }
      }

      function animate() {
        update();
        draw();
        requestAnimationFrame(animate);
      }

      animate();
    </script>
    <p class="分区普通文本">绘制矩形有两种方式：</p>
    <ul class="分区列表">
      <li class="分区列表项">
        绘制<span class="强调">单个</span>矩形：直接用<span class="行内代码">ctx.fillRect()</span>填充，用<span
          class="行内代码"
          >ctx.strokeRect()</span
        >描边
      </li>
      <li class="分区列表项">
        绘制<span class="强调">多个</span>矩形：先用<span class="行内代码">ctx.Rect()</span>绘制矩形路径，再用<span
          class="行内代码"
          >ctx.fill()</span
        >或<span class="行内代码">ctx.stroke()</span>填充或描边
      </li>
    </ul>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        ctx.fillStyle = "darkgreen";   //设置填充颜色
        ctx.strokeStyle = "gold";   //设置描边颜色

        //---------------- ↓ 绘制单个矩形 ↓ ----------------
        // ctx.fillRect(水平坐标, 垂直坐标, 宽度, 高度);
        ctx.fillRect(265, 100, 150, 100);   //填充单个矩形

        // ctx.strokeRect(水平坐标, 垂直坐标, 宽度, 高度);
        ctx.strokeRect(265, 100, 150, 100);   //描边单个矩形

        //---------------- ↓ 绘制多个矩形 ↓ ----------------
        // ctx.Rect(水平坐标, 垂直坐标, 宽度, 高度);
        ctx.Rect(200, 300, 150, 300);  //绘制矩形路径
        ctx.Rect(350, 90, 250, 225);   //绘制矩形路径
        ctx.Rect(50, 410, 75, 240);    //绘制矩形路径
        ctx.fill();     //填充多个矩形
        ctx.stroke();   //描边多个矩形
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-2" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_2 = document.getElementById("canvas-2");
      const ctx_2 = canvas_2.getContext("2d");
      const dpr_2 = window.devicePixelRatio || 1;
      canvas_2.width = canvas_2.offsetWidth * dpr_2;
      canvas_2.height = canvas_2.offsetHeight * dpr_2;
      ctx_2.scale(dpr_2, dpr_2);
      ctx_2.fillStyle = "#006400a0";
      ctx_2.strokeStyle = "gold";
      ctx_2.fillRect(265, 100, 250, 200);
      ctx_2.strokeRect(265, 100, 250, 200);

      ctx_2.arc(265, 100, 5, 0, 2 * Math.PI);
      ctx_2.fillStyle = "black";
      ctx_2.strokeStyle = "white";
      ctx_2.fill();
      ctx_2.stroke();

      ctx_2.font = "16px 'Google Sans Code', 'Consolas', sans-serif";
      ctx_2.textAlign = "center";
      ctx_2.textBaseline = "bottom";
      ctx_2.fillStyle = "silver";
      ctx_2.fillText("坐标：(265, 100)", 265, 85);
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">圆角矩形</span></h3>
    <p class="分区普通文本">
      圆角矩形相比于矩形多了一个必要条件：<span class="行内专业名词">圆角半径</span>。熟悉<span class="行内专业名词"
        >CSS</span
      >规则的都知道，圆角半径有<span class="行内专业名词">4</span>种写法，在<span class="行内专业名词">Canvas API</span
      >中也是一样的，只不过用的是数组的形式。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- ↓ 绘制圆角矩形 ↓ ----------------
        // ctx.roundRect(水平坐标, 垂直坐标, 宽度, 高度, 圆角半径数组);
        //[20, 40, 80] -> 左上, 右上和左下, 右下
        ctx.roundRect(250, 200, 300, 200, [20, 40, 80]);
        ctx.fillStyle = "darkgreen";   //设置填充颜色
        ctx.strokeStyle = "gold";   //设置描边颜色
        ctx.fill();   //填充路径
        ctx.stroke();   //描边路径
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-round-rect" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      圆角半径数组的写法和<span class="行内专业名词">CSS</span
      >是一致的，只不过用的是数组的形式，因此两个值之间要用英文逗号。
    </p>
    <script>
      const canvas_round_rect = document.getElementById("canvas-round-rect");
      const ctx_round_rect = canvas_round_rect.getContext("2d");
      const dpr_round_rect = window.devicePixelRatio || 1;
      canvas_round_rect.width = canvas_round_rect.offsetWidth * dpr_round_rect;
      canvas_round_rect.height = canvas_round_rect.offsetHeight * dpr_round_rect;
      ctx_round_rect.scale(dpr_round_rect, dpr_round_rect);
      ctx_round_rect.roundRect(
        (canvas_round_rect.offsetWidth - 300) / 2,
        (canvas_round_rect.offsetHeight - 200) / 2,
        300,
        200,
        [20, 40, 80]
      );
      ctx_round_rect.fillStyle = "darkgreen";
      ctx_round_rect.strokeStyle = "gold";
      ctx_round_rect.fill();
      ctx_round_rect.stroke();

      ctx_round_rect.font = "16px 'Google Sans Code', monospace";
      ctx_round_rect.fillStyle = "#ccc";
      ctx_round_rect.fillText(
        "20",
        (canvas_round_rect.offsetWidth - 300) / 2 - 30,
        (canvas_round_rect.offsetHeight - 200) / 2 - 15
      );
      ctx_round_rect.fillText(
        "40",
        (canvas_round_rect.offsetWidth - 300) / 2 + 300 + 10,
        (canvas_round_rect.offsetHeight - 200) / 2 - 15
      );
      ctx_round_rect.fillText(
        "80",
        (canvas_round_rect.offsetWidth - 300) / 2 + 300 + 10,
        (canvas_round_rect.offsetHeight - 200) / 2 + 200 + 15
      );
      ctx_round_rect.fillText(
        "40",
        (canvas_round_rect.offsetWidth - 300) / 2 - 30,
        (canvas_round_rect.offsetHeight - 200) / 2 + 200 + 15
      );
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">正圆</span></h3>
    <p class="分区普通文本">要绘制正圆，需要知道<span class="行内专业名词">4</span>个必要条件：</p>
    <ul class="分区列表">
      <li class="分区列表项">圆心坐标</li>
      <li class="分区列表项">半径</li>
      <li class="分区列表项">起始弧度</li>
      <li class="分区列表项">结束弧度</li>
    </ul>
    <section class="提醒">
      <h3 class="提醒标题">小知识</h3>
      <p class="分区普通文本">
        <span class="行内专业名词">弧度</span>和<span class="行内专业名词">角度</span
        >其实是一回事，只是表示方式不同，可以访问<a
          class="超链接"
          href="/Interactive-Hub/Radius-And-Angle/"
          target="_blank"
          >弧度和角度</a
        >了解更多。
      </p>
      <p class="分区普通文本">
        简而言之，圆的周长相当于<span class="行内代码">2π</span>弧度，大约等于<span class="行内代码">6.28</span>。
      </p>
    </section>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- ↓ 绘制正圆 ↓ ----------------
        // ctx.arc(圆心水平坐标, 圆心垂直坐标, 半径, 起始弧度, 结束弧度);
        ctx.arc(390, 200, 100, 0, 2 * Math.PI);   //绘制正圆路径
        ctx.fillStyle = "darkgreen";   //设置填充颜色
        ctx.strokeStyle = "lightskyblue";   //设置描边颜色
        ctx.fill();   //填充路径
        ctx.stroke();   //描边路径
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-circle" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      class CircleDemo {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;

          // 滑块相关属性
          this.sliderX = 20;
          this.sliderY = 40;
          this.sliderWidth = 200;
          this.sliderHeight = 6;
          this.thumbSize = 16;
          this.endAngle = 2 * Math.PI; // 默认值
          this.minValue = 0;
          this.maxValue = 2 * Math.PI;
          this.step = 0.01;
          this.isDragging = false;
          this.isHovered = false;

          this.initCanvas();
          this.bindEvents();
          this.draw();
        }

        initCanvas() {
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);
        }

        bindEvents() {
          this.canvas.addEventListener("mousedown", (e) => this.handleMouseDown(e));
          this.canvas.addEventListener("mousemove", (e) => this.handleMouseMove(e));
          this.canvas.addEventListener("mouseup", () => this.handleMouseUp());
          this.canvas.addEventListener("mouseleave", () => this.handleMouseLeave());
        }

        handleMouseDown(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = ((e.clientX - rect.left) * (this.canvas.width / rect.width)) / this.dpr;
          const y = ((e.clientY - rect.top) * (this.canvas.height / rect.height)) / this.dpr;

          const thumbX = this.getThumbPosition();
          const thumbY = this.sliderY + this.sliderHeight / 2;

          // 检查是否点击在thumb上
          if (Math.abs(x - thumbX) <= this.thumbSize / 2 && Math.abs(y - thumbY) <= this.thumbSize / 2) {
            this.isDragging = true;
          }
        }

        handleMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = ((e.clientX - rect.left) * (this.canvas.width / rect.width)) / this.dpr;
          const y = ((e.clientY - rect.top) * (this.canvas.height / rect.height)) / this.dpr;

          if (this.isDragging) {
            // 更新滑块值
            const newValue = ((x - this.sliderX) / this.sliderWidth) * (this.maxValue - this.minValue) + this.minValue;
            this.endAngle = Math.max(this.minValue, Math.min(this.maxValue, newValue));
            this.draw();
          } else {
            // 检查悬停状态
            const thumbX = this.getThumbPosition();
            const thumbY = this.sliderY + this.sliderHeight / 2;
            const wasHovered = this.isHovered;
            this.isHovered = Math.abs(x - thumbX) <= this.thumbSize / 2 && Math.abs(y - thumbY) <= this.thumbSize / 2;

            if (wasHovered !== this.isHovered) {
              this.draw();
            }
          }
        }

        handleMouseUp() {
          this.isDragging = false;
        }

        handleMouseLeave() {
          this.isDragging = false;
          if (this.isHovered) {
            this.isHovered = false;
            this.draw();
          }
        }

        getThumbPosition() {
          const ratio = (this.endAngle - this.minValue) / (this.maxValue - this.minValue);
          return this.sliderX + ratio * this.sliderWidth;
        }

        formatAngle(angle) {
          const pi = Math.PI;
          if (Math.abs(angle - pi / 2) < 0.01) return { text: "0.5π", number: "0.5" };
          if (Math.abs(angle - pi) < 0.01) return { text: "π", number: "1" };
          if (Math.abs(angle - 1.5 * pi) < 0.01) return { text: "1.5π", number: "1.5" };
          if (Math.abs(angle - 2 * pi) < 0.01) return { text: "2π", number: "2" };
          
          // 格式化普通数字，去掉不必要的尾随零
          const formatted = parseFloat(angle.toFixed(2)).toString();
          return { text: formatted, number: formatted };
        }

        draw() {
          // 清除画布
          this.ctx.clearRect(0, 0, this.canvas.width / this.dpr, this.canvas.height / this.dpr);

          // 绘制滑块
          this.drawSlider();

          // 绘制圆形
          this.ctx.beginPath();
          this.ctx.arc(390, 200, 100, 0, this.endAngle);
          this.ctx.fillStyle = "darkgreen";
          this.ctx.strokeStyle = "gold";
          this.ctx.fill();
          this.ctx.stroke();

          // 绘制中心点
          this.ctx.beginPath();
          this.ctx.arc(390, 200, 5, 0, 2 * Math.PI);
          this.ctx.fillStyle = "black";
          this.ctx.strokeStyle = "white";
          this.ctx.fill();
          this.ctx.stroke();

          // 绘制坐标文字
          this.ctx.font = "16px 'Google Sans Code', 'Consolas', sans-serif";
          this.ctx.textAlign = "center";
          this.ctx.textBaseline = "middle";
          this.ctx.fillStyle = "white";
          this.ctx.fillText("坐标：(390, 200)", 390, 175);
        }

        drawSlider() {
          this.ctx.save();

          // 绘制滑块轨道背景
          this.ctx.fillStyle = "#333";
          this.ctx.fillRect(this.sliderX, this.sliderY, this.sliderWidth, this.sliderHeight);

          // 绘制已滑过的部分
          const thumbX = this.getThumbPosition();
          this.ctx.fillStyle = "#4CAF50";
          this.ctx.fillRect(this.sliderX, this.sliderY, thumbX - this.sliderX, this.sliderHeight);

          // 绘制滑块轨道边框
          this.ctx.strokeStyle = "#666";
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(this.sliderX, this.sliderY, this.sliderWidth, this.sliderHeight);

          // 绘制thumb
          const thumbY = this.sliderY + this.sliderHeight / 2;
          this.ctx.beginPath();
          this.ctx.arc(thumbX, thumbY, 10, 0, 2 * Math.PI);

          if (this.isHovered || this.isDragging) {
            this.ctx.fillStyle = "#2C8F30";
          } else {
            this.ctx.fillStyle = "#4CAF50";
          }

          this.ctx.fill();

          // 绘制角度值
          this.ctx.font = "16px 'Google Sans Code', sans-serif";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "bottom"; // 明确设置文本基线
          
          const angleInfo = this.formatAngle(this.endAngle);
          const labelText = "结束弧度: ";
          const numberText = angleInfo.text;
          
          // 绘制标签文字（白色）
          this.ctx.fillStyle = "#aaa";
          this.ctx.fillText(labelText, this.sliderX, this.sliderY - 10);
          
          // 计算数字文字的起始位置
          const labelWidth = this.ctx.measureText(labelText).width;
          
          // 绘制数字（黄色）
          this.ctx.fillStyle = "#FFD700"; // 金黄色
          this.ctx.fillText(numberText, this.sliderX + labelWidth, this.sliderY - 10);

          this.ctx.restore();
        }
      }

      // 创建实例
      new CircleDemo("canvas-circle");
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">椭圆</span></h3>
    <p class="分区普通文本">要绘制椭圆，需要知道<span class="行内专业名词">6</span>个必要条件：</p>
    <ul class="分区列表">
      <li class="分区列表项">圆心坐标</li>
      <li class="分区列表项">水平半径</li>
      <li class="分区列表项">垂直半径</li>
      <li class="分区列表项">旋转弧度</li>
      <li class="分区列表项">起始弧度</li>
      <li class="分区列表项">结束弧度</li>
    </ul>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- ↓ 绘制椭圆 ↓ ----------------
        // ctx.arc(圆心水平坐标, 圆心垂直坐标, 水平半径, 垂直半径, 旋转弧度, 起始弧度, 结束弧度);
        ctx.ellipse(250, 200, 150, 75, Math.PI / 4, 0, 2 * Math.PI);   //绘制正圆路径
        ctx.fillStyle = "darkgreen";   //设置填充颜色
        ctx.strokeStyle = "lightskyblue";   //设置描边颜色
        ctx.fill();   //填充路径
        ctx.stroke();   //描边路径
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-椭圆" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      class EllipseCanvas {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.rotationAngle = 0; // 默认旋转角度为0

          // 滑块相关属性
          this.slider = {
            x: 0,
            y: 0,
            width: 150,
            height: 8,
            thumbRadius: 10,
            isDragging: false,
            minValue: 0,
            maxValue: 2 * Math.PI,
            value: 0, // 默认值为0
          };

          this.init();
          this.setupEventListeners();
          this.draw();
        }

        init() {
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);

          // 设置滑块位置（右上角）
          this.slider.x = this.canvas.offsetWidth - this.slider.width - 20;
          this.slider.y = 40;
        }

        setupEventListeners() {
          this.canvas.addEventListener("mousedown", (e) => this.handleMouseDown(e));
          this.canvas.addEventListener("mousemove", (e) => this.handleMouseMove(e));
          this.canvas.addEventListener("mouseup", () => this.handleMouseUp());
          this.canvas.addEventListener("mouseleave", () => this.handleMouseUp());
        }

        handleMouseDown(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) * (this.canvas.offsetWidth / rect.width);
          const y = (e.clientY - rect.top) * (this.canvas.offsetHeight / rect.height);

          const thumbX = this.slider.x + (this.slider.value / this.slider.maxValue) * this.slider.width;
          const thumbY = this.slider.y + this.slider.height / 2;

          const distance = Math.sqrt((x - thumbX) ** 2 + (y - thumbY) ** 2);

          if (distance <= this.slider.thumbRadius) {
            this.slider.isDragging = true;
          }
        }

        handleMouseMove(e) {
          if (!this.slider.isDragging) return;

          const rect = this.canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) * (this.canvas.offsetWidth / rect.width);

          // 计算滑块值
          const relativeX = Math.max(0, Math.min(this.slider.width, x - this.slider.x));
          this.slider.value = (relativeX / this.slider.width) * this.slider.maxValue;
          this.rotationAngle = this.slider.value;

          this.draw();
        }

        handleMouseUp() {
          this.slider.isDragging = false;
        }

        drawSlider() {
          // 绘制滑块轨道（未滑过部分）
          this.ctx.fillStyle = "#444";
          this.ctx.fillRect(this.slider.x, this.slider.y, this.slider.width, this.slider.height);

          // 绘制已滑过部分
          const progressWidth = (this.slider.value / this.slider.maxValue) * this.slider.width;
          this.ctx.fillStyle = "#669919";
          this.ctx.fillRect(this.slider.x, this.slider.y, progressWidth, this.slider.height);

          // 绘制滑块拇指
          const thumbX = this.slider.x + (this.slider.value / this.slider.maxValue) * this.slider.width;
          const thumbY = this.slider.y + this.slider.height / 2;

          this.ctx.fillStyle = "#669919";
          this.ctx.beginPath();
          this.ctx.arc(thumbX, thumbY, this.slider.thumbRadius, 0, 2 * Math.PI);
          this.ctx.fill();

          // 绘制当前值标签（跟随thumb移动）
          this.ctx.fillStyle = "lightskyblue";
          this.ctx.font = "14px 'Google Sans Code', sans-serif";
          this.ctx.textAlign = "center";

          let valueText = "";
          if (Math.abs(this.slider.value - 0) < 0.01) {
            valueText = "0";
          } else if (Math.abs(this.slider.value - Math.PI / 2) < 0.01) {
            valueText = "0.5π";
          } else if (Math.abs(this.slider.value - Math.PI) < 0.01) {
            valueText = "π";
          } else if (Math.abs(this.slider.value - (3 * Math.PI) / 2) < 0.01) {
            valueText = "1.5π";
          } else if (Math.abs(this.slider.value - 2 * Math.PI) < 0.01) {
            valueText = "2π";
          } else {
            valueText = this.slider.value.toFixed(2);
          }

          this.ctx.fillText(valueText, thumbX, this.slider.y - 12);

          // 绘制标签标题
          this.ctx.fillStyle = "#aaa";
          this.ctx.font = "14px 'Google Sans Code', sans-serif";
          this.ctx.textAlign = "left";
          this.ctx.fillText("旋转弧度", this.slider.x, this.slider.y + this.slider.height + 25);
        }

        draw() {
          // 清除画布
          this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight);

          // 绘制椭圆
          this.ctx.beginPath();
          this.ctx.ellipse(375, 200, 150, 75, this.rotationAngle, 0, 2 * Math.PI);
          this.ctx.fillStyle = "darkgreen";
          this.ctx.strokeStyle = "gold";
          this.ctx.fill();
          this.ctx.stroke();

          // 绘制滑块
          this.drawSlider();
        }
      }

      // 初始化椭圆canvas
      new EllipseCanvas("canvas-椭圆");
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">正多边形</span></h3>
    <p class="分区普通文本">
      <span class="行内专业名词">正多边形</span>的本质就是<span class="行内专业名词 等宽">N</span
      >个顶点之间的连线，只要知道所有顶点的坐标，就能绘制出正多边形。事实上，正多边形的顶点都分布在同一个正圆上，因此，绘制正多边形需要知道以下条件：
    </p>
    <ul class="分区列表">
      <li class="分区列表项">圆心坐标</li>
      <li class="分区列表项">半径</li>
      <li class="分区列表项">顶点数量</li>
      <li class="分区列表项">起始弧度</li>
    </ul>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <div style="position: relative; width: 100%; height: calc(100% - 42px)">
        <canvas id="canvas-正多边形范例" style="width: 100%; height: 100%; background-color: #222"></canvas>
        <!-- 滑块控制区域 -->
        <div
          style="
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            color: #aaa;
            font-family: 'Google Sans Code', sans-serif;
            z-index: 1000;
          "
        >
          <style>
            .滑块标签:hover {
              cursor: url("/Images/Common/鼠标-默认.cur"), pointer;
            }

            .滑块:hover {
              cursor: url("/Images/Common/鼠标-指向.cur"), pointer;
            }

            .滑块::-webkit-slider-thumb {
              scale: 1.25;
            }

            #顶点数量显示,
            #起始弧度显示 {
              color: darkgoldenrod;
            }
          </style>
          <div style="margin-bottom: 15px">
            <label class="滑块标签" style="display: block; margin-bottom: 5px; font-size: 16px"
              >顶点数量: <span id="顶点数量显示">5</span></label
            >
            <input
              class="滑块"
              type="range"
              id="顶点数量滑块"
              min="3"
              max="10"
              value="5"
              style="width: 150px; accent-color: rgb(102, 153, 25)"
            />
          </div>
          <div>
            <label class="滑块标签" style="display: block; margin-bottom: 5px; font-size: 16px"
              >起始弧度: <span id="起始弧度显示">-π/2</span></label
            >
            <input
              class="滑块"
              type="range"
              id="起始弧度滑块"
              min="-628"
              max="628"
              value="-157"
              style="width: 150px; accent-color: rgb(102, 153, 25)"
              list="起始弧度刻度"
            />
            <datalist id="起始弧度刻度" style="display: none; opacity: 0">
              <option value="-628" label="-2π"></option>
              <option value="-471" label="-3π/2"></option>
              <option value="-314" label="-π"></option>
              <option value="-157" label="-π/2"></option>
              <option value="0" label="0"></option>
              <option value="157" label="π/2"></option>
              <option value="314" label="π"></option>
              <option value="471" label="3π/2"></option>
              <option value="628" label="2π"></option>
            </datalist>
          </div>
        </div>
      </div>
    </figure>
    <p class="分区普通文本">
      通过起始弧度，确定每个顶点的坐标，就可以用<span class="行内专业名词">绘制直线</span
      >的方式，依次连接所有顶点，成为一个正多边形。
    </p>
    <script>
      class 正多边形范例 {
        constructor() {
          this.canvas = document.getElementById("canvas-正多边形范例");
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);
          this.正圆 = {
            圆心: {
              x: this.canvas.offsetWidth / 2,
              y: this.canvas.offsetHeight / 2,
            },
            半径: 150,
            路径: null,
          };
          this.正多边形 = {
            顶点数量: 5,
            起始弧度: -Math.PI / 2,
          };

          // 初始化滑块控制
          this.初始化滑块控制();

          requestAnimationFrame(this.绘制全部.bind(this));
        }

        绘制正圆() {
          this.ctx.save();
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "#fff3";
          this.ctx.fillStyle = "#fff1";
          this.正圆.路径 = new Path2D();
          this.正圆.路径.arc(this.正圆.圆心.x, this.正圆.圆心.y, this.正圆.半径, 0, 2 * Math.PI);
          this.ctx.stroke(this.正圆.路径);
          this.ctx.fill(this.正圆.路径);
          this.ctx.restore();
        }

        绘制正多边形() {
          this.ctx.save();
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "lightskyblue";
          this.ctx.fillStyle = "#87cefa25";
          this.ctx.beginPath();
          for (let i = 0; i < this.正多边形.顶点数量; i++) {
            this.ctx.lineTo(
              this.正圆.圆心.x +
                this.正圆.半径 * Math.cos(this.正多边形.起始弧度 + (i * 2 * Math.PI) / this.正多边形.顶点数量),
              this.正圆.圆心.y +
                this.正圆.半径 * Math.sin(this.正多边形.起始弧度 + (i * 2 * Math.PI) / this.正多边形.顶点数量)
            );
          }
          this.ctx.closePath();
          this.ctx.stroke();
          this.ctx.fill();
          this.ctx.restore();
        }

        绘制起始弧度参考线() {
          this.ctx.save();
          const 虚线长度 = 10;
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "#fff7";
          this.ctx.setLineDash([虚线长度, 虚线长度]);
          this.ctx.beginPath();
          this.ctx.moveTo(this.正圆.圆心.x, this.正圆.圆心.y);
          this.ctx.lineTo(
            this.正圆.圆心.x + this.正圆.半径 * Math.cos(this.正多边形.起始弧度),
            this.正圆.圆心.y + this.正圆.半径 * Math.sin(this.正多边形.起始弧度)
          );
          this.ctx.stroke();
          this.ctx.lineDashOffset = 虚线长度;
          this.ctx.strokeStyle = "#0007";
          this.ctx.stroke();
          this.ctx.restore();
        }

        绘制圆心() {
          this.ctx.save();
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "#333";
          this.ctx.fillStyle = "#aaa";
          this.ctx.beginPath();
          this.ctx.arc(this.正圆.圆心.x, this.正圆.圆心.y, 7, 0, Math.PI * 2);
          this.ctx.stroke();
          this.ctx.fill();
          this.ctx.restore();
        }

        绘制正多边形顶点() {
          this.ctx.save();
          this.ctx.lineWidth = 2;
          for (let i = 0; i < this.正多边形.顶点数量; i++) {
            this.ctx.beginPath();
            const 顶点弧度 = this.正多边形.起始弧度 + (i * 2 * Math.PI) / this.正多边形.顶点数量;
            const 顶点坐标 = {
              x: this.正圆.圆心.x + this.正圆.半径 * Math.cos(顶点弧度),
              y: this.正圆.圆心.y + this.正圆.半径 * Math.sin(顶点弧度),
            };
            this.ctx.arc(顶点坐标.x, 顶点坐标.y, 5, 0, Math.PI * 2);
            this.ctx.closePath();
            this.ctx.fillStyle = "gold";
            this.ctx.fill();
            this.ctx.strokeStyle = "#fff7";
            this.ctx.stroke();
          }
          this.ctx.restore();
        }

        绘制顶点索引() {
          this.ctx.save();
          this.ctx.font = "14px 'Google Sans Code', sans-serif";
          this.ctx.fillStyle = "#aaa";
          this.ctx.textAlign = "center";
          this.ctx.textBaseline = "middle";

          for (let i = 0; i < this.正多边形.顶点数量; i++) {
            const 顶点弧度 = this.正多边形.起始弧度 + (i * 2 * Math.PI) / this.正多边形.顶点数量;
            // 计算索引文本位置（在顶点外侧）
            const 索引偏移距离 = 20;
            const 索引坐标 = {
              x: this.正圆.圆心.x + (this.正圆.半径 + 索引偏移距离) * Math.cos(顶点弧度),
              y: this.正圆.圆心.y + (this.正圆.半径 + 索引偏移距离) * Math.sin(顶点弧度),
            };

            // 绘制索引文本
            this.ctx.fillText(i.toString(), 索引坐标.x, 索引坐标.y);
          }
          this.ctx.restore();
        }

        绘制全部() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.绘制正圆();
          this.绘制正多边形();
          this.绘制起始弧度参考线();
          this.绘制圆心();
          this.绘制正多边形顶点();
          this.绘制顶点索引();
        }

        初始化滑块控制() {
          // 获取滑块元素
          const 顶点数量滑块 = document.getElementById("顶点数量滑块");
          const 起始弧度滑块 = document.getElementById("起始弧度滑块");
          const 顶点数量显示 = document.getElementById("顶点数量显示");
          const 起始弧度显示 = document.getElementById("起始弧度显示");

          // 顶点数量滑块事件
          顶点数量滑块.addEventListener("input", (e) => {
            const 新值 = parseInt(e.target.value);
            this.正多边形.顶点数量 = 新值;
            顶点数量显示.textContent = 新值;
            // 立即更新绘制
            requestAnimationFrame(this.绘制全部.bind(this));
          });

          // 起始弧度滑块事件
          起始弧度滑块.addEventListener("input", (e) => {
            const 新值 = parseInt(e.target.value) / 100; // 转换为弧度
            this.正多边形.起始弧度 = 新值;
            // 更新显示文本
            if (Math.abs(新值) < 0.01) {
              起始弧度显示.textContent = "0";
            } else if (Math.abs(Math.abs(新值) - Math.PI) < 0.01) {
              起始弧度显示.textContent = 新值 > 0 ? "π" : "-π";
            } else if (Math.abs(Math.abs(新值) - Math.PI / 2) < 0.01) {
              起始弧度显示.textContent = 新值 > 0 ? "π/2" : "-π/2";
            } else if (Math.abs(Math.abs(新值) - Math.PI * 1.5) < 0.01) {
              起始弧度显示.textContent = 新值 > 0 ? "3π/2" : "-3π/2";
            } else if (Math.abs(Math.abs(新值) - Math.PI * 2) < 0.01) {
              起始弧度显示.textContent = 新值 > 0 ? "2π" : "-2π";
            } else {
              起始弧度显示.textContent = 新值.toFixed(2);
            }
            // 立即更新绘制
            requestAnimationFrame(this.绘制全部.bind(this));
          });
        }
      }

      new 正多边形范例();
    </script>
    <p class="分区普通文本">
      因此，只剩一个问题：如何通过<span class="行内专业名词">弧度</span>，确定顶点坐标？假设顶点数量为<span
        class="行内专业名词 等宽"
        >5</span
      >，那么两个相邻顶点之间的弧度偏移量为<span class="行内代码">2π / 5</span>，若起始弧度为<span class="行内代码"
        >-(π / 2)</span
      >，则每个顶点的弧度分别为：
    </p>
    <style>
      .标点 {
        color: rgb(158, 158, 158);
      }

      .圆括号 {
        color: darkgoldenrod;
      }
    </style>
    <ul class="分区列表">
      <li class="分区列表项">
        <span class="等宽">顶点<span class="行内专业名词">1</span>：</span>
        <span class="代码"
          ><span class="标点">-</span>π <span class="标点">/</span> 2 <span class="标点">+</span>
          <span class="圆括号">(</span>2π <span class="标点">/</span> 5<span class="圆括号">)</span>
          <span class="标点">×</span> 0</span
        >
      </li>
      <li class="分区列表项">
        <span class="等宽">顶点<span class="行内专业名词">2</span>：</span>
        <span class="代码"
          ><span class="标点">-</span>π <span class="标点">/</span> 2 <span class="标点">+</span>
          <span class="圆括号">(</span>2π <span class="标点">/</span> 5<span class="圆括号">)</span>
          <span class="标点">×</span> 1</span
        >
      </li>
      <li class="分区列表项">
        <span class="等宽">顶点<span class="行内专业名词">3</span>：</span>
        <span class="代码"
          ><span class="标点">-</span>π <span class="标点">/</span> 2 <span class="标点">+</span>
          <span class="圆括号">(</span>2π <span class="标点">/</span> 5<span class="圆括号">)</span>
          <span class="标点">×</span> 2</span
        >
      </li>
      <li class="分区列表项">
        <span class="等宽">顶点<span class="行内专业名词">4</span>：</span>
        <span class="代码"
          ><span class="标点">-</span>π <span class="标点">/</span> 2 <span class="标点">+</span>
          <span class="圆括号">(</span>2π <span class="标点">/</span> 5<span class="圆括号">)</span>
          <span class="标点">×</span> 3</span
        >
      </li>
      <li class="分区列表项">
        <span class="等宽">顶点<span class="行内专业名词">5</span>：</span>
        <span class="代码"
          ><span class="标点">-</span>π <span class="标点">/</span> 2 <span class="标点">+</span>
          <span class="圆括号">(</span>2π <span class="标点">/</span> 5<span class="圆括号">)</span>
          <span class="标点">×</span> 4</span
        >
      </li>
    </ul>
    <p class="分区普通文本">将其写成公式，就是：</p>
    <ul class="分区列表">
      <li class="分区列表项">
        <span class="行内专业名词 等宽"
          >弧度偏移 <span class="标点">=</span> 2π <span class="标点">/</span> 顶点数量</span
        >
      </li>
      <li class="分区列表项">
        <span class="行内专业名词 等宽"
          >顶点弧度 <span class="标点">=</span> 初始弧度 <span class="标点">+</span> 弧度偏移
          <span class="标点">×</span> 顶点索引</span
        >
      </li>
    </ul>
    <p class="分区普通文本">
      有了<span class="行内专业名词">半径</span>和<span class="行内专业名词">顶点弧度</span>，我们就可以计算出<span
        class="强调"
        >顶点和圆心之间</span
      >的<span class="行内专业名词">水平偏移</span>和<span class="行内专业名词">垂直偏移</span>，从而得到<span
        class="行内专业名词"
        >顶点坐标</span
      >。
    </p>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1">
      <canvas
        id="canvas-半径弧度算坐标"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <p class="分区普通文本">
      <span class="专业名词"
        >水平偏移 <span class="标点">=</span>
        <span class="行内专业名词 等宽"
          ><span class="行内代码" style="margin: 0">Math</span><span class="标点">.</span
          ><span class="行内代码" style="margin: 0">Cos</span><span class="圆括号">(</span>弧度<span class="圆括号"
            >)</span
          >
          <span class="标点">×</span> 半径</span
        ></span
      >
      ，<span class="专业名词"
        >垂直偏移 <span class="标点">=</span>
        <span class="行内专业名词 等宽"
          ><span class="行内代码" style="margin: 0">Math</span><span class="标点">.</span
          ><span class="行内代码" style="margin: 0">Sin</span><span class="圆括号">(</span>弧度<span class="圆括号"
            >)</span
          >
          <span class="标点">×</span> 半径</span
        ></span
      >，因此，顶点的坐标为：
    </p>
    <ul class="分区列表">
      <li class="分区列表项">
        <span class="行内专业名词">顶点水平坐标</span>：<span class="专业名词"
          >圆心水平坐标 <span class="标点">+</span> 水平偏移</span
        >
      </li>
      <li class="分区列表项">
        <span class="行内专业名词">顶点垂直坐标</span>：<span class="专业名词"
          >圆心垂直坐标 <span class="标点">+</span> 垂直偏移</span
        >
      </li>
    </ul>
    <script>
      class 半径弧度算坐标 {
        constructor() {
          this.canvas = document.getElementById("canvas-半径弧度算坐标");
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);

          // 初始化参数
          this.圆心 = {
            x: this.canvas.offsetWidth / 2,
            y: this.canvas.offsetHeight / 2,
          };
          this.半径 = 275;
          this.顶点弧度 = 0;
          this.顶点半径 = 8;
          this.是否拖拽中 = false;
          this.鼠标悬停在顶点上 = false;
          this.最后鼠标位置 = null;

          // 绑定事件
          this.绑定事件();

          // 开始绘制循环
          this.绘制();
        }

        绑定事件() {
          this.canvas.addEventListener("mousedown", this.鼠标按下.bind(this));
          this.canvas.addEventListener("mousemove", this.鼠标移动.bind(this));
          this.canvas.addEventListener("mouseup", this.鼠标松开.bind(this));
          this.canvas.addEventListener("mouseleave", this.鼠标离开.bind(this));
        }

        鼠标按下(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = ((e.clientX - rect.left) * this.dpr) / this.dpr;
          const y = ((e.clientY - rect.top) * this.dpr) / this.dpr;

          // 检查是否点击在顶点上
          const 顶点坐标 = this.计算顶点坐标();
          const 距离 = Math.sqrt((x - 顶点坐标.x) ** 2 + (y - 顶点坐标.y) ** 2);

          if (距离 <= this.顶点半径) {
            this.是否拖拽中 = true;
          }
        }

        鼠标移动(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = ((e.clientX - rect.left) * this.dpr) / this.dpr;
          const y = ((e.clientY - rect.top) * this.dpr) / this.dpr;

          // 记录鼠标位置
          this.最后鼠标位置 = { x, y };

          // 检查鼠标是否悬停在顶点上
          const 顶点坐标 = this.计算顶点坐标();
          const 距离 = Math.sqrt((x - 顶点坐标.x) ** 2 + (y - 顶点坐标.y) ** 2);
          this.鼠标悬停在顶点上 = 距离 <= this.顶点半径;

          if (this.是否拖拽中) {
            // 计算新的弧度
            const dx = x - this.圆心.x;
            const dy = y - this.圆心.y;
            this.顶点弧度 = Math.atan2(dy, dx);
          }

          // 重新绘制
          this.绘制();
        }

        鼠标松开() {
          this.是否拖拽中 = false;

          // 松开鼠标后立即检查鼠标是否还在顶点上
          const 顶点坐标 = this.计算顶点坐标();
          const 鼠标位置 = this.获取鼠标位置();
          if (鼠标位置) {
            const 距离 = Math.sqrt((鼠标位置.x - 顶点坐标.x) ** 2 + (鼠标位置.y - 顶点坐标.y) ** 2);
            this.鼠标悬停在顶点上 = 距离 <= this.顶点半径;
            // 立即重新绘制以更新顶点颜色
            this.绘制();
          }
        }

        鼠标离开() {
          this.是否拖拽中 = false;
        }

        计算顶点坐标() {
          return {
            x: this.圆心.x + this.半径 * Math.cos(this.顶点弧度),
            y: this.圆心.y + this.半径 * Math.sin(this.顶点弧度),
          };
        }

        获取鼠标位置() {
          // 返回最后一次记录的鼠标位置
          return this.最后鼠标位置;
        }

        绘制提示() {
          this.ctx.save();
          this.ctx.font = "20px sans-serif";
          this.ctx.textAlign = "center";
          this.ctx.textBaseline = "middle";
          this.ctx.fillStyle = "#ccc";
          this.ctx.fillText("拖拽顶点", this.canvas.offsetWidth / 2, 40);
          this.ctx.restore();
        }

        绘制圆() {
          this.ctx.save();
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "#5af3";
          this.ctx.beginPath();
          this.ctx.arc(this.圆心.x, this.圆心.y, this.半径, 0, 2 * Math.PI);
          this.ctx.stroke();
          this.ctx.restore();
        }

        绘制圆心() {
          this.ctx.save();
          this.ctx.beginPath();
          this.ctx.arc(this.圆心.x, this.圆心.y, 7, 0, 2 * Math.PI);
          this.ctx.fillStyle = "#aaa";
          this.ctx.fill();
          this.ctx.restore();
        }

        绘制顶点() {
          this.ctx.save();
          const 顶点坐标 = this.计算顶点坐标();

          this.ctx.beginPath();
          this.ctx.arc(顶点坐标.x, 顶点坐标.y, this.顶点半径, 0, 2 * Math.PI);
          this.ctx.fillStyle = this.鼠标悬停在顶点上 || this.是否拖拽中 ? "gold" : "rgb(134, 94, 0)";
          this.ctx.fill();
          this.ctx.strokeStyle = "#fff";
          this.ctx.lineWidth = 1;
          this.ctx.stroke();
          this.ctx.restore();
        }

        绘制连线() {
          this.ctx.save();
          const 顶点坐标 = this.计算顶点坐标();

          // 黑白相间的虚线
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([10, 10]);
          this.ctx.strokeStyle = "#0008";
          this.ctx.beginPath();
          this.ctx.moveTo(this.圆心.x, this.圆心.y);
          this.ctx.lineTo(顶点坐标.x, 顶点坐标.y);
          this.ctx.stroke();

          this.ctx.lineDashOffset = 10;
          this.ctx.strokeStyle = "#fff8";
          this.ctx.stroke();

          this.ctx.restore();
        }

        绘制坐标示意线() {
          this.ctx.save();
          const 顶点坐标 = this.计算顶点坐标();

          // 横坐标示意线（绿色+透明虚线）
          this.ctx.lineWidth = 2;
          this.ctx.setLineDash([5, 5]);
          this.ctx.strokeStyle = "lightgreen";
          this.ctx.beginPath();
          this.ctx.moveTo(this.圆心.x, 顶点坐标.y);
          this.ctx.lineTo(顶点坐标.x, 顶点坐标.y);
          this.ctx.stroke();

          // 纵坐标示意线（蓝色+透明虚线）
          this.ctx.strokeStyle = "lightblue";
          this.ctx.beginPath();
          this.ctx.moveTo(this.圆心.x, this.圆心.y);
          this.ctx.lineTo(this.圆心.x, 顶点坐标.y);
          this.ctx.stroke();

          this.ctx.restore();
        }

        绘制公式文本() {
          this.ctx.save();
          const 顶点坐标 = this.计算顶点坐标();

          this.ctx.font = "14px 'Google Sans Code', 'Consolas', sans-serif";
          this.ctx.textAlign = "center";
          this.ctx.textBaseline = "middle";

          // 根据顶点位置动态调整文本显示位置
          const 顶点在圆心上方 = 顶点坐标.y <= this.圆心.y;
          const 横坐标示意线在圆心左方 = 顶点坐标.x <= this.圆心.x;

          // 横坐标公式文本
          const 横坐标文本 = "Math.Cos(弧度) × 半径";
          const 横坐标文本Y = 顶点在圆心上方 ? 顶点坐标.y - 30 : 顶点坐标.y + 30;
          const 横坐标文本X = (this.圆心.x + 顶点坐标.x) / 2;

          // 绘制横坐标文本的圆角矩形底色
          this.ctx.save();
          this.ctx.fillStyle = "#ffffff1a";
          this.ctx.lineWidth = 1;

          // 测量文本尺寸
          const 横坐标文本尺寸 = this.ctx.measureText(横坐标文本);
          const 横坐标矩形宽度 = 横坐标文本尺寸.width + 20; // 左右各10px内边距
          const 横坐标矩形高度 = 横坐标文本尺寸.actualBoundingBoxAscent + 横坐标文本尺寸.actualBoundingBoxDescent + 15; // 上下各5px内边距

          // 绘制圆角矩形
          this.ctx.beginPath();
          this.ctx.roundRect(
            横坐标文本X - 横坐标矩形宽度 / 2,
            横坐标文本Y - 横坐标矩形高度 / 2,
            横坐标矩形宽度,
            横坐标矩形高度,
            7
          );
          this.ctx.fill();
          this.ctx.restore();

          // 绘制横坐标文本
          this.ctx.fillStyle = "#90ee90cc";
          this.ctx.fillText(横坐标文本, 横坐标文本X, 横坐标文本Y);

          // 纵坐标公式文本
          const 纵坐标文本 = "Math.Sin(弧度) × 半径";
          const 纵坐标文本X = 横坐标示意线在圆心左方 ? this.圆心.x + 20 : this.圆心.x - 20;
          const 纵坐标文本Y = (this.圆心.y + 顶点坐标.y) / 2;

          // 绘制纵坐标文本的圆角矩形底色
          this.ctx.save();
          this.ctx.fillStyle = "#ffffff1a";
          this.ctx.lineWidth = 1;

          // 测量文本尺寸
          const 纵坐标文本尺寸 = this.ctx.measureText(纵坐标文本);
          const 纵坐标矩形宽度 = 纵坐标文本尺寸.width + 20; // 左右各10px内边距
          const 纵坐标矩形高度 = 纵坐标文本尺寸.actualBoundingBoxAscent + 纵坐标文本尺寸.actualBoundingBoxDescent + 15; // 上下各5px内边距

          // 绘制圆角矩形
          this.ctx.beginPath();
          this.ctx.roundRect(
            纵坐标文本X - (横坐标示意线在圆心左方 ? 0 : 纵坐标矩形宽度),
            纵坐标文本Y - 纵坐标矩形高度 / 2,
            纵坐标矩形宽度,
            纵坐标矩形高度,
            7
          );
          this.ctx.fill();
          this.ctx.restore();

          // 绘制纵坐标文本
          this.ctx.fillStyle = "#add8e6cc";
          this.ctx.textAlign = 横坐标示意线在圆心左方 ? "left" : "right";
          this.ctx.fillText(纵坐标文本, 纵坐标文本X + (this.ctx.textAlign === "left" ? 10 : -10), 纵坐标文本Y);

          this.ctx.restore();
        }

        绘制() {
          // 清空画布
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // 绘制各个元素
          this.绘制提示();
          this.绘制圆();
          this.绘制连线();
          this.绘制坐标示意线();
          this.绘制公式文本();
          this.绘制顶点();
          this.绘制圆心();
        }
      }

      new 半径弧度算坐标();
    </script>
    <p class="分区普通文本">
      有了计算公式，让我们来做一个正六边形，初始弧度为<span class="行内代码">-π / 2</span>，半径为<span class="行内代码"
        >150</span
      >。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        class 正六边形范例 {
          constructor() {
            this.canvas = document.getElementById("canvas-正六边形");
            this.ctx = this.canvas.getContext("2d");
            this.dpr = window.devicePixelRatio || 1;
            this.canvas.width = this.canvas.offsetWidth * this.dpr;
            this.canvas.height = this.canvas.offsetHeight * this.dpr;
            this.ctx.scale(this.dpr, this.dpr);
            this.正多边形 = {
              圆心: {
                x: this.canvas.offsetWidth / 2,
                y: this.canvas.offsetHeight / 2,
              },
              半径: 150,
              起始弧度: -Math.PI / 2,
              顶点数量: 6,
              // 上面4个属性其实都是为了确定顶点坐标
              顶点坐标组: [],
            };
  
            requestAnimationFrame(this.绘制全部.bind(this));
          }

          // 最重要的核心函数，确定所有顶点的坐标
          生成正多边形顶点坐标() {
            this.正多边形.顶点坐标组 = []; //先清空顶点坐标组，否则后续的坐标会不停叠加到组中
            const 弧度偏移量 = 2 * Math.PI / this.正多边形.顶点数量;
            for (let i = 0; i < this.正多边形.顶点数量; i++) {
              const 顶点弧度 = this.正多边形.起始弧度 + i * 弧度偏移量;
              const 顶点坐标 = {
                x: this.正多边形.圆心.x + this.正多边形.半径 * Math.cos(顶点弧度),
                y: this.正多边形.圆心.y + this.正多边形.半径 * Math.sin(顶点弧度),
              };
              this.正多边形.顶点坐标组.push(顶点坐标);
            }
          }
  
          绘制圆周() {
            this.ctx.save();
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = "#5af3";
            this.ctx.beginPath();
            this.ctx.arc(
              this.正多边形.圆心.x, 
              this.正多边形.圆心.y, 
              this.正多边形.半径, 
              0, 
              2 * Math.PI
            );
            this.ctx.stroke();
            this.ctx.restore();
          }
  
          绘制圆心() {
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.arc(this.正多边形.圆心.x, this.正多边形.圆心.y, 7, 0, 2 * Math.PI);
            this.ctx.fillStyle = "#aaa";
            this.ctx.fill();
            this.ctx.restore();
          }
            
          绘制多边形() {
            this.ctx.save();
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = "lightskyblue";
            this.ctx.fillStyle = "#87cefa25";
            this.ctx.beginPath();
  
            // 移动到第一个顶点
            this.ctx.moveTo(this.正多边形.顶点坐标组[0].x, this.正多边形.顶点坐标组[0].y);
  
            // 连接所有顶点
            for (let i = 1; i < this.正多边形.顶点坐标组.length; i++) {
              this.ctx.lineTo(this.正多边形.顶点坐标组[i].x, this.正多边形.顶点坐标组[i].y);
            }
  
            // 闭合路径
            this.ctx.closePath();
            this.ctx.fill();
            this.ctx.stroke();
            this.ctx.restore();
          }
  
          绘制顶点() {
            this.ctx.save();
            this.ctx.lineWidth = 2;
  
            for (let i = 0; i < this.正多边形.顶点坐标组.length; i++) {
              const 顶点坐标 = this.正多边形.顶点坐标组[i];
  
              this.ctx.beginPath();
              this.ctx.arc(顶点坐标.x, 顶点坐标.y, 5, 0, Math.PI * 2);
              this.ctx.fillStyle = "gold";
              this.ctx.fill();
              this.ctx.strokeStyle = "#fff";
              this.ctx.stroke();
  
              // 绘制顶点索引
              this.ctx.font = "14px 'Google Sans Code', 'Consolas', sans-serif";
              this.ctx.fillStyle = "#fffa";
              this.ctx.textAlign = "center";
              this.ctx.textBaseline = "middle";

              this.绘制索引(i);
            }
  
            this.ctx.restore();
          }

          绘制索引(i) {
            const 索引偏移距离 = 20;
            const 弧度偏移量 = (2 * Math.PI) / this.正多边形.顶点数量;
            const 顶点弧度 = this.正多边形.起始弧度 + i * 弧度偏移量;
            const 水平偏移 = Math.cos(顶点弧度) * (this.正多边形.半径 + 索引偏移距离);
            const 垂直偏移 = Math.sin(顶点弧度) * (this.正多边形.半径 + 索引偏移距离);
            const 索引坐标 = {
              x: this.正多边形.圆心.x + 水平偏移,
              y: this.正多边形.圆心.y + 垂直偏移,
            };
  
            this.ctx.fillText(i.toString(), 索引坐标.x, 索引坐标.y);
          }
  
          绘制全部() {
            // 清空画布
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  
            // 初始化顶点
            this.生成正多边形顶点坐标();
  
            // 绘制各个元素
            this.绘制圆周();
            this.绘制多边形();
            this.绘制圆心();
            this.绘制顶点();
          }
        }
  
        new 正六边形范例();  
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-正六边形" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      class 正六边形范例 {
        constructor() {
          this.canvas = document.getElementById("canvas-正六边形");
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);
          this.正多边形 = {
            圆心: {
              x: this.canvas.offsetWidth / 2,
              y: this.canvas.offsetHeight / 2,
            },
            半径: 150,
            起始弧度: -Math.PI / 2,
            顶点数量: 6,
            顶点坐标组: [],
          };

          requestAnimationFrame(this.绘制全部.bind(this));
        }

        绘制圆周() {
          this.ctx.save();
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "#5af3";
          this.ctx.beginPath();
          this.ctx.arc(this.正多边形.圆心.x, this.正多边形.圆心.y, this.正多边形.半径, 0, 2 * Math.PI);
          this.ctx.stroke();
          this.ctx.restore();
        }

        绘制圆心() {
          this.ctx.save();
          this.ctx.beginPath();
          this.ctx.arc(this.正多边形.圆心.x, this.正多边形.圆心.y, 7, 0, 2 * Math.PI);
          this.ctx.fillStyle = "#aaa";
          this.ctx.fill();
          this.ctx.restore();
        }

        初始化多边形顶点() {
          this.正多边形.顶点坐标组 = [];
          const 弧度偏移量 = (2 * Math.PI) / this.正多边形.顶点数量;
          for (let i = 0; i < this.正多边形.顶点数量; i++) {
            const 顶点弧度 = this.正多边形.起始弧度 + i * 弧度偏移量;
            const 顶点坐标 = {
              x: this.正多边形.圆心.x + this.正多边形.半径 * Math.cos(顶点弧度),
              y: this.正多边形.圆心.y + this.正多边形.半径 * Math.sin(顶点弧度),
            };
            this.正多边形.顶点坐标组.push(顶点坐标);
          }
        }

        绘制多边形() {
          this.ctx.save();
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "lightskyblue";
          this.ctx.fillStyle = "#87cefa25";
          this.ctx.beginPath();

          // 移动到第一个顶点
          this.ctx.moveTo(this.正多边形.顶点坐标组[0].x, this.正多边形.顶点坐标组[0].y);

          // 连接所有顶点
          for (let i = 1; i < this.正多边形.顶点坐标组.length; i++) {
            this.ctx.lineTo(this.正多边形.顶点坐标组[i].x, this.正多边形.顶点坐标组[i].y);
          }

          // 闭合路径
          this.ctx.closePath();
          this.ctx.fill();
          this.ctx.stroke();
          this.ctx.restore();
        }

        绘制顶点() {
          this.ctx.save();
          this.ctx.lineWidth = 2;

          for (let i = 0; i < this.正多边形.顶点坐标组.length; i++) {
            const 顶点坐标 = this.正多边形.顶点坐标组[i];

            this.ctx.beginPath();
            this.ctx.arc(顶点坐标.x, 顶点坐标.y, 5, 0, Math.PI * 2);
            this.ctx.fillStyle = "gold";
            this.ctx.fill();
            this.ctx.strokeStyle = "#fff";
            this.ctx.stroke();

            // 绘制顶点索引
            this.ctx.font = "14px 'Google Sans Code', 'Consolas', sans-serif";
            this.ctx.fillStyle = "#fffa";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";

            this.绘制索引(i);
          }

          this.ctx.restore();
        }

        绘制索引(i) {
          const 索引偏移距离 = 20;
          const 弧度偏移量 = (2 * Math.PI) / this.正多边形.顶点数量;
          const 顶点弧度 = this.正多边形.起始弧度 + i * 弧度偏移量;
          const 水平偏移 = Math.cos(顶点弧度) * (this.正多边形.半径 + 索引偏移距离);
          const 垂直偏移 = Math.sin(顶点弧度) * (this.正多边形.半径 + 索引偏移距离);
          const 索引坐标 = {
            x: this.正多边形.圆心.x + 水平偏移,
            y: this.正多边形.圆心.y + 垂直偏移,
          };

          this.ctx.fillText(i.toString(), 索引坐标.x, 索引坐标.y);
        }

        绘制全部() {
          // 清空画布
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // 初始化顶点
          this.初始化多边形顶点();

          // 绘制各个元素
          this.绘制圆周();
          this.绘制多边形();
          this.绘制圆心();
          this.绘制顶点();
        }
      }

      new 正六边形范例();
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">文本</span></h3>
    <p class="分区普通文本">要绘制文本，需要知道<span class="行内专业名词">2</span>个必要条件：</p>
    <ul class="分区列表">
      <li class="分区列表项">文本内容</li>
      <li class="分区列表项">文本坐标</li>
    </ul>
    <p class="分区普通文本">此外，还可以对文本做以下设置：</p>
    <ul class="分区列表">
      <li class="分区列表项">字体</li>
      <li class="分区列表项">文本垂直基线</li>
      <li class="分区列表项">文本水平对齐</li>
    </ul>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- ↓ 绘制文本 ↓ ----------------
        ctx.font = "bold 30px 'JetBrains Mono', 'Consolas', sans-serif";   //设置字体
        ctx.fillStyle = "#abc";   //设置填充颜色
        ctx.strokeStyle = "firebrick";   //设置描边颜色
        ctx.lineWidth = 1;   //设置描边宽度，不写则默认为1.0
        ctx.textBaseline = "alphabetic";   //设置文本垂直基线
        ctx.textAlign = "start";   //设置文本水平对齐

        // ctx.fillText(文本内容, 水平坐标, 垂直坐标);
        ctx.fillText("ABgfjpyZ-水平与垂直", ctx.宽度 / 2, ctx.高度 / 2);   //填充文本

        // ctx.strokeText(文本内容, 水平坐标, 垂直坐标);
        ctx.strokeText("ABgfjpyZ-水平与垂直", ctx.宽度 / 2, ctx.高度 / 2);   //描边文本
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-text" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      <span style="color: gold; margin: 0 4px">●</span
      >代表文本的坐标，可以很清楚地看出，垂直基线和水平对齐是如何影响文本与坐标的关系的。
    </p>
    <script>
      class TextAlignmentDemo {
        constructor() {
          this.canvas = document.getElementById("canvas-text");
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.cssWidth = this.canvas.offsetWidth;
          this.cssHeight = this.canvas.offsetHeight;

          // 设置canvas尺寸
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);

          // 文本设置
          this.text = "ABgfjpyZ-水平与垂直";
          this.centerX = this.canvas.offsetWidth / 2;
          this.centerY = this.canvas.offsetHeight / 2;

          // 单选框设置
          this.textAlignOptions = ["left", "right", "center", "start", "end"];
          this.textBaselineOptions = ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"];
          this.selectedTextAlign = "start";
          this.selectedTextBaseline = "alphabetic";

          // 单选框尺寸和位置
          this.radioSize = 12;
          this.radioSpacing = 20;
          this.radioGroupSpacing = 40;

          // 存储单选框坐标和尺寸信息
          this.textAlignRadioBoxes = [];
          this.textBaselineRadioBoxes = [];

          // 跟踪鼠标悬停状态
          this.hoveredTextAlign = null;
          this.hoveredTextBaseline = null;
          this.hoveredCheckbox = false;

          // 复选框设置
          this.showTextCoordinate = true; // 默认选中

          this.init();
        }

        init() {
          this.draw();
          this.addEventListeners();
        }

        draw() {
          // 清空canvas
          this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight);

          // 绘制主文本
          this.ctx.font = "bold 30px 'Consolas', sans-serif";
          this.ctx.fillStyle = "#abc";
          this.ctx.strokeStyle = "firebrick";
          this.ctx.lineWidth = 1;
          this.ctx.textBaseline = this.selectedTextBaseline;
          this.ctx.textAlign = this.selectedTextAlign;

          this.ctx.fillText(this.text, this.centerX, this.centerY);
          this.ctx.strokeText(this.text, this.centerX, this.centerY);

          // 绘制基准线和坐标点
          this.ctx.save();
          this.ctx.strokeStyle = "#4d87";
          this.ctx.beginPath();
          this.ctx.moveTo(0, this.centerY);
          this.ctx.lineTo(this.cssWidth, this.centerY);
          this.ctx.stroke();
          this.ctx.moveTo(this.centerX, this.centerY + 50);
          this.ctx.lineTo(this.centerX, this.centerY - 50);
          this.ctx.stroke();

          // 根据复选框状态决定是否绘制坐标点
          if (this.showTextCoordinate) {
            this.ctx.beginPath();
            this.ctx.arc(this.centerX, this.centerY, 6, 0, Math.PI * 2);
            this.ctx.fillStyle = "gold";
            this.ctx.fill();
          }
          this.ctx.restore();

          // 绘制单选框
          this.drawRadioGroups();
        }

        drawRadioGroups() {
          const startX = 20;
          const startY = 20;

          // 先绘制标题（位置固定）
          this.ctx.font = "14px 微软雅黑, sans-serif";
          this.ctx.fillStyle = "white";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "top";
          this.ctx.fillText("水平对齐：", startX, startY);
          this.ctx.fillText("垂直基线：", startX, startY + this.radioGroupSpacing + 10);

          // 设置字体用于测量文本宽度
          this.ctx.font = "14px 'Google Sans Code', 'Consolas', monospace";
          const radioHeight = 30; // 字体大小 + 10 + 5

          // 清空存储的单选框信息
          this.textAlignRadioBoxes = [];
          this.textBaselineRadioBoxes = [];
          this.checkboxInfo = null;

          // 绘制水平对齐单选框组
          let currentX = startX + 80; // 标题右边开始
          this.textAlignOptions.forEach((option, index) => {
            // 测量当前选项的文本宽度
            const textMetrics = this.ctx.measureText(option);
            const radioWidth = textMetrics.width + 20;

            const x = currentX + radioWidth / 2;
            const y = startY + 7; // 调整Y坐标，让文本在单选框中心

            // 记录单选框坐标和尺寸信息
            this.textAlignRadioBoxes.push({
              option: option,
              x: currentX,
              y: y - radioHeight / 2,
              width: radioWidth,
              height: radioHeight,
            });

            // 如果选中，先绘制背景矩形
            if (option === this.selectedTextAlign) {
              this.ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
              this.ctx.fillRect(currentX, y - radioHeight / 2, radioWidth, radioHeight);
            }
            // 如果悬停，绘制悬停背景
            else if (option === this.hoveredTextAlign) {
              this.ctx.fillStyle = "#fff2";
              this.ctx.fillRect(currentX, y - radioHeight / 2, radioWidth, radioHeight);
            }

            // 绘制边框
            this.ctx.strokeStyle = "#888";
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(currentX, y - radioHeight / 2, radioWidth, radioHeight);

            // 绘制文本
            this.ctx.fillStyle = option === this.selectedTextAlign ? "white" : "#aaa";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(option, x, y);

            // 更新下一个单选框的起始位置（无空隙）
            currentX += radioWidth;
          });

          // 绘制垂直基线单选框组
          currentX = startX + 80; // 标题右边开始
          this.textBaselineOptions.forEach((option, index) => {
            // 测量当前选项的文本宽度
            const textMetrics = this.ctx.measureText(option);
            const radioWidth = textMetrics.width + 20;

            const x = currentX + radioWidth / 2;
            const y = startY + this.radioGroupSpacing + 17; // 调整Y坐标，让文本在单选框中心

            // 记录单选框坐标和尺寸信息
            this.textBaselineRadioBoxes.push({
              option: option,
              x: currentX,
              y: y - radioHeight / 2,
              width: radioWidth,
              height: radioHeight,
            });

            // 如果选中，先绘制背景矩形
            if (option === this.selectedTextBaseline) {
              this.ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
              this.ctx.fillRect(currentX, y - radioHeight / 2, radioWidth, radioHeight);
            }
            // 如果悬停，绘制悬停背景
            else if (option === this.hoveredTextBaseline) {
              this.ctx.fillStyle = "#fff1";
              this.ctx.fillRect(currentX, y - radioHeight / 2, radioWidth, radioHeight);
            }

            // 绘制边框
            this.ctx.strokeStyle = "#888";
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(currentX, y - radioHeight / 2, radioWidth, radioHeight);

            // 绘制文本
            this.ctx.fillStyle = option === this.selectedTextBaseline ? "white" : "#aaa";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";
            this.ctx.fillText(option, x, y);

            // 更新下一个单选框的起始位置（无空隙）
            currentX += radioWidth;
          });

          // 绘制复选框
          const checkboxY = startY + this.radioGroupSpacing + 60;
          const checkboxSize = 16;
          const checkboxX = startX;

          // 如果悬停，绘制悬停背景
          if (this.hoveredCheckbox) {
            this.ctx.fillStyle = "#fff1";
            this.ctx.fillRect(checkboxX, checkboxY, checkboxSize, checkboxSize);
          }

          // 绘制复选框边框
          this.ctx.strokeStyle = "#888";
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(checkboxX, checkboxY, checkboxSize, checkboxSize);

          // 如果选中，绘制勾选标记
          if (this.showTextCoordinate) {
            // 绘制打勾
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(checkboxX + 3, checkboxY + 8);
            this.ctx.lineTo(checkboxX + 7, checkboxY + 12);
            this.ctx.lineTo(checkboxX + 13, checkboxY + 5);
            this.ctx.stroke();
          }

          // 绘制复选框文本
          this.ctx.font = "14px 微软雅黑, sans-serif";
          this.ctx.fillStyle = "white";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "top";
          this.ctx.fillText("显示文本坐标", checkboxX + checkboxSize + 8, checkboxY + 2);

          // 记录复选框信息（包括文本区域）
          this.checkboxInfo = {
            x: checkboxX,
            y: checkboxY,
            width: checkboxSize + 8 + this.ctx.measureText("显示文本坐标").width, // 复选框 + 间距 + 文本宽度
            height: checkboxSize,
          };
        }

        addEventListeners() {
          this.canvas.addEventListener("click", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 检查水平对齐单选框点击
            this.textAlignRadioBoxes.forEach((radioBox) => {
              if (
                x >= radioBox.x &&
                x <= radioBox.x + radioBox.width &&
                y >= radioBox.y &&
                y <= radioBox.y + radioBox.height
              ) {
                this.selectedTextAlign = radioBox.option;
                this.draw();
                return;
              }
            });

            // 检查垂直基线单选框点击
            this.textBaselineRadioBoxes.forEach((radioBox) => {
              if (
                x >= radioBox.x &&
                x <= radioBox.x + radioBox.width &&
                y >= radioBox.y &&
                y <= radioBox.y + radioBox.height
              ) {
                this.selectedTextBaseline = radioBox.option;
                this.draw();
                return;
              }
            });

            // 检查复选框点击
            if (
              this.checkboxInfo &&
              x >= this.checkboxInfo.x &&
              x <= this.checkboxInfo.x + this.checkboxInfo.width &&
              y >= this.checkboxInfo.y &&
              y <= this.checkboxInfo.y + this.checkboxInfo.height
            ) {
              this.showTextCoordinate = !this.showTextCoordinate;
              this.draw();
              return;
            }
          });

          // 添加鼠标移动事件监听器
          this.canvas.addEventListener("mousemove", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let isOverRadioBox = false;
            let newHoveredTextAlign = null;
            let newHoveredTextBaseline = null;
            let newHoveredCheckbox = false;

            // 检查是否在水平对齐单选框上
            this.textAlignRadioBoxes.forEach((radioBox) => {
              if (
                x >= radioBox.x &&
                x <= radioBox.x + radioBox.width &&
                y >= radioBox.y &&
                y <= radioBox.y + radioBox.height
              ) {
                isOverRadioBox = true;
                newHoveredTextAlign = radioBox.option;
              }
            });

            // 检查是否在垂直基线单选框上
            this.textBaselineRadioBoxes.forEach((radioBox) => {
              if (
                x >= radioBox.x &&
                x <= radioBox.x + radioBox.width &&
                y >= radioBox.y &&
                y <= radioBox.y + radioBox.height
              ) {
                isOverRadioBox = true;
                newHoveredTextBaseline = radioBox.option;
              }
            });

            // 检查是否在复选框上
            if (
              this.checkboxInfo &&
              x >= this.checkboxInfo.x &&
              x <= this.checkboxInfo.x + this.checkboxInfo.width &&
              y >= this.checkboxInfo.y &&
              y <= this.checkboxInfo.y + this.checkboxInfo.height
            ) {
              newHoveredCheckbox = true;
            }

            // 更新悬停状态
            if (
              this.hoveredTextAlign !== newHoveredTextAlign ||
              this.hoveredTextBaseline !== newHoveredTextBaseline ||
              this.hoveredCheckbox !== newHoveredCheckbox
            ) {
              this.hoveredTextAlign = newHoveredTextAlign;
              this.hoveredTextBaseline = newHoveredTextBaseline;
              this.hoveredCheckbox = newHoveredCheckbox;
              this.draw(); // 重新绘制以显示悬停效果
            }

            // 设置光标样式
            if (isOverRadioBox || newHoveredCheckbox) {
              this.canvas.style.cursor = 'url("/Images/Common/鼠标-指向.cur"), pointer';
            } else {
              this.canvas.style.cursor = 'url("/Images/Common/鼠标-默认.cur"), auto';
            }
          });
        }
      }

      // 初始化应用
      new TextAlignmentDemo();
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        垂直基线的默认值是：<span class="行内代码">alphabetic</span>，水平对齐的默认值是：<span class="行内代码"
          >start</span
        >。如需更多信息，可访问二者的<span class="行内专业名词">MDN 文档</span>：
      </p>
      <ul class="分区列表">
        <li class="分区列表项">
          <a
            class="超链接"
            href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textBaseline"
            target="_blank"
            >垂直基线</a
          >
        </li>

        <li class="分区列表项">
          <a
            class="超链接"
            href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/textAlign"
            target="_blank"
            >水平对齐</a
          >
        </li>
      </ul>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">其它常用操作</h2>

    <h3 class="分区标题 分区3级标题">清空区域</h3>
    <p class="分区普通文本">
      清空区域使用<span class="行内代码">ctx.clearRect()</span
      >方法。清空区域就相当于橡皮擦功能，清空后区域内会变成透明。由于清空的区域是一个矩形，所以它的必要条件和绘制矩形一致：
    </p>
    <ul class="分区列表">
      <li class="分区列表项">矩形的<span class="行内专业名词">坐标</span></li>
      <li class="分区列表项">矩形的<span class="行内专业名词">尺寸</span></li>
    </ul>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- ↓ 绘制正圆 ↓ ----------------
        const 半径 = 100;
        const 圆心 = { 
          x: canvas.offsetWidth / 2, 
          y: canvas.offsetHeight / 2
        };
        const 弧度 = {
          起始: 0,
          结束: 2 * Math.PI
        };
        ctx.fillStyle = "darkgreen";
        ctx.strokeStyle = "gold";
        ctx.arc(圆心.x, 圆心.y, 半径, 弧度.起始, 弧度.结束);
        ctx.fill();
        ctx.stroke();

        //---------------- ↓ 清空圆的右下部分 ↓ ----------------
        ctx.clearRect(圆心.x, 圆心.y, 半径, 半径);

        //如果图形包含描边，则清空区域的尺寸要加上描边
        ctx.clearRect(圆心.x, 圆心.y, 半径 + 描边宽度, 半径 + 描边宽度);
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-clearRect" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_clear = document.getElementById("canvas-clearRect");
      const ctx_clear = canvas_clear.getContext("2d");
      const dpr_clear = window.devicePixelRatio || 1;
      canvas_clear.width = canvas_clear.offsetWidth * dpr_clear;
      canvas_clear.height = canvas_clear.offsetHeight * dpr_clear;
      ctx_clear.scale(dpr_clear, dpr_clear);
      ctx_clear.fillStyle = "darkgreen";
      ctx_clear.strokeStyle = "gold";
      const 清空演示半径 = 100;
      const 清空演示圆心 = {
        x: canvas_clear.offsetWidth / 2,
        y: canvas_clear.offsetHeight / 2,
      };
      ctx_clear.arc(清空演示圆心.x, 清空演示圆心.y, 清空演示半径, 0, 2 * Math.PI);
      ctx_clear.fill();
      ctx_clear.stroke();
      ctx_clear.clearRect(
        清空演示圆心.x,
        清空演示圆心.y,
        清空演示半径 + ctx_clear.lineWidth,
        清空演示半径 + ctx_clear.lineWidth
      );
      ctx_clear.setLineDash([10, 5]);
      ctx_clear.strokeStyle = "white";
      ctx_clear.strokeRect(
        清空演示圆心.x,
        清空演示圆心.y,
        清空演示半径 + ctx_clear.lineWidth,
        清空演示半径 + ctx_clear.lineWidth
      );
    </script>
    <section class="提醒">
      <h3 class="提醒标题">小知识</h3>
      <p class="分区普通文本"><span class="行内代码">ctx.clearRect()</span>最常见的用途就是清空整个Canvas：</p>
      <pre>
        <code class="lang-javascript">
          ctx.clearRect(0, 0, canvas.width, canvas.height);   //清空整个Canvas
        </code>
      </pre>
    </section>

    <h3 class="分区标题 分区3级标题">闭合路径</h3>
    <p class="分区普通文本">
      闭合路径使用<span class="行内代码">ctx.closePath()</span
      >，目的是将路径的起点和终点连接起来，形成一个封闭的区域。假如没有闭合，会怎么样呢？
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- ↓ 绘制路径 ↓ ----------------
        ctx.beginPath();
        ctx.moveTo(200, 200);   //第1个点，起点
        ctx.lineTo(350, 100);   //第2个点
        ctx.lineTo(500, 250);   //第3个点，终点
        //ctx.closePath();   //不闭合路径；如果闭合，则会将终点和起点连接起来
        ctx.lineWidth = 2;   //设置描边宽度
        ctx.fill();    //填充路径
        ctx.stroke();  //描边路径
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-closePath" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      class ClosePathDemo {
        constructor(canvasId) {
          this.canvas = document.getElementById(canvasId);
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.isClosePathEnabled = true;

          this.initCanvas();
          this.createCheckbox();
          this.draw();
        }

        initCanvas() {
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);
        }

        createCheckbox() {
          // 设置复选框的位置和尺寸
          this.checkboxX = 10;
          this.checkboxY = 10;
          this.checkboxSize = 16;
          this.checkboxPadding = 8;
          this.isHovered = false;

          // 绑定鼠标点击事件
          this.canvas.addEventListener("click", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) * (this.canvas.width / rect.width)) / this.dpr;
            const y = ((e.clientY - rect.top) * (this.canvas.height / rect.height)) / this.dpr;

            // 检查是否点击在复选框区域
            const checkboxAreaWidth = this.checkboxSize + this.checkboxPadding * 2 + 60; // 60是文字宽度估算
            const checkboxAreaHeight = this.checkboxSize + this.checkboxPadding * 2;

            if (
              x >= this.checkboxX &&
              x <= this.checkboxX + checkboxAreaWidth &&
              y >= this.checkboxY &&
              y <= this.checkboxY + checkboxAreaHeight
            ) {
              this.isClosePathEnabled = !this.isClosePathEnabled;
              this.draw();
            }
          });

          // 绑定鼠标移动事件来检测悬停
          this.canvas.addEventListener("mousemove", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) * (this.canvas.width / rect.width)) / this.dpr;
            const y = ((e.clientY - rect.top) * (this.canvas.height / rect.height)) / this.dpr;

            // 检查是否悬停在复选框区域
            const checkboxAreaWidth = this.checkboxSize + this.checkboxPadding * 2 + 60;
            const checkboxAreaHeight = this.checkboxSize + this.checkboxPadding * 2;

            const wasHovered = this.isHovered;
            this.isHovered =
              x >= this.checkboxX &&
              x <= this.checkboxX + checkboxAreaWidth &&
              y >= this.checkboxY &&
              y <= this.checkboxY + checkboxAreaHeight;

            // 如果悬停状态改变，重新绘制
            if (wasHovered !== this.isHovered) {
              this.draw();
            }
          });

          // 绑定鼠标离开事件
          this.canvas.addEventListener("mouseleave", () => {
            if (this.isHovered) {
              this.isHovered = false;
              this.draw();
            }
          });
        }

        draw() {
          // 清除画布
          this.ctx.clearRect(0, 0, this.canvas.width / this.dpr, this.canvas.height / this.dpr);

          // 绘制复选框
          this.drawCheckbox();

          // 设置样式
          this.ctx.fillStyle = "darkgreen";
          this.ctx.strokeStyle = "gold";
          this.ctx.lineWidth = 2;

          // 开始路径
          this.ctx.beginPath();
          this.ctx.moveTo(200, 200);
          this.ctx.lineTo(350, 100);
          this.ctx.lineTo(500, 250);

          // 根据复选框状态决定是否闭合路径
          if (this.isClosePathEnabled) {
            this.ctx.closePath();
          }

          // 填充和描边
          this.ctx.fill();
          this.ctx.stroke();
        }

        drawCheckbox() {
          // 保存当前状态
          this.ctx.save();

          // 根据状态确定颜色
          let fillColor, strokeColor;

          if (this.isClosePathEnabled) {
            // 选中状态
            if (this.isHovered) {
              fillColor = "#3E8D42"; // 悬停时的绿色填充
              strokeColor = "#3E8D42"; // 悬停时的深绿色边框
            } else {
              fillColor = "#2E7D32"; // 选中时的绿色填充
              strokeColor = "#2E7D32"; // 选中时的深绿色边框
            }
          } else {
            // 未选中状态
            if (this.isHovered) {
              fillColor = "#fff2"; // 悬停时的浅灰色填充
              strokeColor = "#aaa"; // 悬停时的灰色边框
            } else {
              fillColor = "transparent"; // 未选中时透明填充
              strokeColor = "#888"; // 未选中时的灰色边框
            }
          }

          // 绘制复选框填充
          if (fillColor !== "transparent") {
            this.ctx.fillStyle = fillColor;
            this.ctx.fillRect(
              this.checkboxX + this.checkboxPadding,
              this.checkboxY + this.checkboxPadding,
              this.checkboxSize,
              this.checkboxSize
            );
          }

          // 绘制复选框边框
          this.ctx.strokeStyle = strokeColor;
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(
            this.checkboxX + this.checkboxPadding,
            this.checkboxY + this.checkboxPadding,
            this.checkboxSize,
            this.checkboxSize
          );

          // 如果选中，绘制对勾
          if (this.isClosePathEnabled) {
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(
              this.checkboxX + this.checkboxPadding + 3,
              this.checkboxY + this.checkboxPadding + this.checkboxSize / 2
            );
            this.ctx.lineTo(
              this.checkboxX + this.checkboxPadding + this.checkboxSize / 2,
              this.checkboxY + this.checkboxPadding + this.checkboxSize - 3
            );
            this.ctx.lineTo(
              this.checkboxX + this.checkboxPadding + this.checkboxSize - 3,
              this.checkboxY + this.checkboxPadding + 3
            );
            this.ctx.stroke();
          }

          // 绘制文字
          this.ctx.fillStyle = "white";
          this.ctx.font = "16px sans-serif";
          this.ctx.fillText(
            "闭合路径",
            this.checkboxX + this.checkboxPadding + this.checkboxSize + 8,
            this.checkboxY + this.checkboxPadding + this.checkboxSize - 2
          );

          // 恢复状态
          this.ctx.restore();
        }
      }

      // 创建实例
      new ClosePathDemo("canvas-closePath");
    </script>
    <p class="分区普通文本">
      如<span class="行内截图序号">· 图12 ·</span
      >所示，如果没有闭合路径，填充时会临时自动闭合，但是描边时不会临时自动闭合。从编程规范性、可扩展性的角度来说，建议显式闭合路径。
    </p>

    <h3 class="分区标题 分区3级标题">保存与恢复上下文</h3>
    <p class="分区普通文本">保存与恢复上下文无非就是这么几个问题：</p>
    <ul class="分区列表">
      <li class="分区列表项">
        何时保存？何时恢复？
        <ul class="分区列表">
          <li class="分区列表项">当前上下文状态会频繁使用，但有时需要临时修改一下。</li>
        </ul>
      </li>
      <li class="分区列表项">
        保存什么？恢复什么？
        <ul class="分区列表">
          <li class="分区列表项">
            当前各种属性的值：<span class="行内专业名词">填充样式</span>、<span class="行内专业名词">描边样式</span
            >、<span class="行内专业名词">描边宽度</span>…………，共<span class="行内专业名词">18</span>个属性。
          </li>
          <li class="分区列表项">当前变换矩阵</li>
          <li class="分区列表项">当前裁剪区域</li>
          <li class="分区列表项">当前虚线列表</li>
        </ul>
      </li>
      <li class="分区列表项">
        怎么保存？怎么恢复？
        <ul class="分区列表">
          <li class="分区列表项">保存上下文：<span class="行内代码">ctx.save()</span></li>
          <li class="分区列表项">恢复上下文：<span class="行内代码">ctx.restore()</span></li>
        </ul>
      </li>
    </ul>
    <p class="分区普通文本">
      让我们举个例子。比如我要绘制<span class="行内专业名词">10</span>个矩形，其中<span class="行内专业名词">第5个</span
      >矩形是黑底白框，其它矩形都是蓝底绿框。正常顺序是：先绘制<span class="行内专业名词">1 - 4</span
      >蓝底绿框矩形，然后绘制<span class="行内专业名词">第5个</span>黑底白框的矩形，最后绘制<span class="行内专业名词"
        >6 - 10</span
      >蓝底绿框矩形。在这段程序中，<span class="行内专业名词">蓝底绿框</span>就是<span class="强调">频繁使用</span
      >的上下文，<span class="行内专业名词">黑底白框</span>就是<span class="强调">临时使用</span>的上下文。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        ctx.fillStyle = "blue";     //蓝底
        ctx.strokeStyle = "green";  //绿框
        ctx.fillRect(100, 100, 100, 100);   //绘制蓝底绿框矩形

        ctx.fillStyle = "black";    //黑底
        ctx.strokeStyle = "white";  //白框
        ctx.fillRect(100, 100, 100, 100);   //绘制黑底白框矩形

        ctx.fillStyle = "blue";   //蓝底
        ctx.strokeStyle = "green";   //绿框
        ctx.fillRect(100, 100, 100, 100);   //绘制蓝底绿框矩形
      </code>
    </pre>
    <p class="分区普通文本">
      有没有觉得这么写很麻烦？每次绘制完黑底白框后，又要再次设置蓝底绿框，更不用说可能还有别的属性需要设置，既繁琐，又容易出错。因此，我们要转换思路：每次要绘制黑底白框前，<span
        class="行内专业名词"
        >先保存</span
      >上下文，绘制完后<span class="行内专业名词">再恢复</span>上下文。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        ctx.fillStyle = "blue";     //蓝底
        ctx.strokeStyle = "green";  //绿框
        ctx.fillRect(100, 100, 100, 100);   //绘制蓝底绿框矩形

        ctx.save();   //保存上下文
        ctx.fillStyle = "black";    //黑底
        ctx.strokeStyle = "white";  //白框
        ctx.fillRect(100, 100, 100, 100);   //绘制黑底白框矩形
        ctx.restore();   //恢复上下文

        ctx.fillRect(100, 100, 100, 100);   //绘制蓝底绿框矩形
      </code>
    </pre>
  </article>
</div>
