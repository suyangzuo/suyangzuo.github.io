<article class="专题简介">
  <h1 class="简介标题">
    <span><span class="行内专业名词">2D</span>绘图进阶</span><span class="原创">原创</span>
  </h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本">2025年7月14日</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">透明度<span class="次要">和</span>阴影</h2>

    <h3 class="分区标题 分区3级标题">全局<span class="行内专业名词">透明度</span></h3>
    <p class="分区普通文本">
      透明度属性是<span class="行内代码">globalAlpha</span>，从名称就可以看出，<span class="行内代码">global</span
      >是<span class="行内专业名词">全局</span>的意思，也就是说，所有绘制的图形都会受到透明度的影响。<span
        class="行内代码"
        >globalAlpha</span
      >的范围是：<span class="代码">0 <span style="color: darkgoldenrod">-</span> 1</span>。
    </p>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //此时 globalAlpha 的值为 1.0
        //绘制第1个矩形
        
        ctx.globalAlpha = 0.25;
        //绘制第2个矩形

        ctx.globalAlpha = 0.05;
        //绘制第3个矩形
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-global-alpha" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_global_alpha = document.getElementById("canvas-global-alpha");
      const ctx_global_alpha = canvas_global_alpha.getContext("2d");
      const dpr_global_alpha = window.devicePixelRatio || 1;
      canvas_global_alpha.width = canvas_global_alpha.offsetWidth * dpr_global_alpha;
      canvas_global_alpha.height = canvas_global_alpha.offsetHeight * dpr_global_alpha;
      ctx_global_alpha.scale(dpr_global_alpha, dpr_global_alpha);
      ctx_global_alpha.fillStyle = "darkgreen";
      ctx_global_alpha.strokeStyle = "gold";
      const rect_width_ga = 150;
      const rect_height_ga = 100;
      const gap_ga = 50;
      const total_width_ga = rect_width_ga * 3 + gap_ga * 2;
      ctx_global_alpha.rect(
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2,
        rect_width_ga,
        rect_height_ga
      );
      ctx_global_alpha.fill();
      ctx_global_alpha.stroke();
      ctx_global_alpha.save();
      ctx_global_alpha.fillStyle = "white";
      ctx_global_alpha.font = "bold 16px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_global_alpha.textBaseline = "middle";
      ctx_global_alpha.textAlign = "center";
      ctx_global_alpha.fillText(
        "100% 不透明度",
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga / 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2 + rect_height_ga / 2
      );
      ctx_global_alpha.restore();
      ctx_global_alpha.globalAlpha = 0.25;
      ctx_global_alpha.rect(
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga + gap_ga,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2,
        rect_width_ga,
        rect_height_ga
      );
      ctx_global_alpha.fill();
      ctx_global_alpha.stroke();
      ctx_global_alpha.save();
      ctx_global_alpha.globalAlpha = 1.0;
      ctx_global_alpha.fillStyle = "#aaa";
      ctx_global_alpha.font = "bold 16px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_global_alpha.textBaseline = "middle";
      ctx_global_alpha.textAlign = "center";
      ctx_global_alpha.fillText(
        "25% 不透明度",
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga / 2 + rect_width_ga + gap_ga,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2 + rect_height_ga / 2
      );
      ctx_global_alpha.restore();
      ctx_global_alpha.globalAlpha = 0.05;
      ctx_global_alpha.rect(
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga * 2 + gap_ga * 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2,
        rect_width_ga,
        rect_height_ga
      );
      ctx_global_alpha.fill();
      ctx_global_alpha.stroke();
      ctx_global_alpha.save();
      ctx_global_alpha.globalAlpha = 1.0;
      ctx_global_alpha.fillStyle = "#aaa";
      ctx_global_alpha.font = "bold 16px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_global_alpha.textBaseline = "middle";
      ctx_global_alpha.textAlign = "center";
      ctx_global_alpha.fillText(
        "5% 不透明度",
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga / 2 + rect_width_ga * 2 + gap_ga * 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2 + rect_height_ga / 2
      );
      ctx_global_alpha.restore();
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">阴影</span></h3>
    <p class="分区普通文本">
      想一想，在<span class="行内专业名词">CSS</span>中的各种阴影，<span class="行内代码">box-shadow</span>、<span
        class="行内代码"
        >drop-shadow</span
      >、<span class="行内代码">text-shadow</span>，它们有哪些共同的属性？
    </p>
    <ul class="分区无序列表">
      <li class="分区列表项"><span class="行内专业名词">偏移量</span>：水平、垂直</li>
      <li class="分区列表项"><span class="行内专业名词">颜色</span></li>
      <li class="分区列表项"><span class="行内专业名词">模糊</span></li>
    </ul>
    <p class="分区普通文本">没错，在<span class="行内专业名词">Canvas</span>中，阴影的属性也是一样的：</p>
    <ul class="分区无序列表">
      <li class="分区列表项"><span class="行内代码">shadowOffsetX</span>：水平偏移量</li>
      <li class="分区列表项"><span class="行内代码">shadowOffsetY</span>：垂直偏移量</li>
      <li class="分区列表项"><span class="行内代码">shadowColor</span>：颜色</li>
      <li class="分区列表项"><span class="行内代码">shadowBlur</span>：模糊</li>
    </ul>
    <pre style="margin-top: 50px">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        ctx.shadowColor = "black";  //阴影颜色
        ctx.shadowOffsetX = 50;     //水平偏移量
        ctx.shadowOffsetY = 50;     //垂直偏移量
        ctx.shadowBlur = 20;        //模糊

        //绘制矩形代码：省略
        ctx.fill();    //填充
        ctx.stroke();  //描边

        //为文本设置阴影属性
        ctx.shadowOffsetX = 10;     //水平偏移量
        ctx.shadowOffsetY = 10;     //垂直偏移量
        ctx.shadowBlur = 10;        //模糊

        //---------------- 填充文本 ----------------
        ctx.fillText("阴影", x + rectWidth / 2, y + rectHeight / 2);
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-shadow" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_shadow = document.getElementById("canvas-shadow");
      const ctx_shadow = canvas_shadow.getContext("2d");
      const dpr_shadow = window.devicePixelRatio || 1;
      canvas_shadow.width = canvas_shadow.offsetWidth * dpr_shadow;
      canvas_shadow.height = canvas_shadow.offsetHeight * dpr_shadow;
      ctx_shadow.scale(dpr_shadow, dpr_shadow);
      ctx_shadow.fillStyle = "darkgreen";
      ctx_shadow.strokeStyle = "gold";
      ctx_shadow.shadowColor = "black";
      ctx_shadow.shadowOffsetX = 50;
      ctx_shadow.shadowOffsetY = 50;
      ctx_shadow.shadowBlur = 20;

      // 计算矩形位置：水平1/3，垂直居中
      const rectWidth = 200;
      const rectHeight = 200;
      const x = (canvas_shadow.offsetWidth - rectWidth) / 2;
      const y = (canvas_shadow.offsetHeight - rectHeight) / 2;

      ctx_shadow.rect(x, y, rectWidth, rectHeight);
      ctx_shadow.fill();
      ctx_shadow.stroke();

      ctx_shadow.save();
      ctx_shadow.fillStyle = "white";
      ctx_shadow.font = "bold 24px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_shadow.textBaseline = "middle";
      ctx_shadow.textAlign = "center";
      ctx_shadow.shadowColor = "black";
      ctx_shadow.shadowOffsetX = 10;
      ctx_shadow.shadowOffsetY = 10;
      ctx_shadow.shadowBlur = 10;
      ctx_shadow.fillText("阴影", x + rectWidth / 2, y + rectHeight / 2);
      ctx_shadow.restore();
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        细心的同学肯定发现了：<span class="行内专业名词">描边</span>的阴影<span class="强调">覆盖了</span
        ><span class="行内专业名词">填充</span>的阴影。为什么会这样呢？因为代码中是<span class="行内专业名词"
          >先填充，后描边</span
        >，谁在后面，谁就处于更上方。因此描边的阴影在填充的上方。
      </p>
      <p class="分区普通文本">怎么办呢？最简单直接的想法是：<span class="强调">先描边，后填充</span>，我们来试试：</p>
      <pre>
        <code class="lang-javascript">
          //其它代码不变
          ctx.stroke();  //描边在前
          ctx.fill();    //填充在后
          //其它代码不变
        </code>
      </pre>
      <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
        <canvas
          id="canvas-shadow-stroke-before"
          style="width: 100%; height: calc(100% - 42px); background-color: #222"
        ></canvas>
      </figure>
      <p class="分区普通文本">
        还是有问题！描边又被填充的阴影覆盖了！因为描边在前，填充在后，因此填充的阴影处于描边的上方。
      </p>
      <script>
        const canvas_shadow_stroke_before = document.getElementById("canvas-shadow-stroke-before");
        const ctx_shadow_stroke_before = canvas_shadow_stroke_before.getContext("2d");
        const dpr_shadow_stroke_before = window.devicePixelRatio || 1;
        canvas_shadow_stroke_before.width = canvas_shadow_stroke_before.offsetWidth * dpr_shadow_stroke_before;
        canvas_shadow_stroke_before.height = canvas_shadow_stroke_before.offsetHeight * dpr_shadow_stroke_before;
        ctx_shadow_stroke_before.scale(dpr_shadow_stroke_before, dpr_shadow_stroke_before);
        ctx_shadow_stroke_before.fillStyle = "darkgreen";
        ctx_shadow_stroke_before.strokeStyle = "gold";
        ctx_shadow_stroke_before.lineWidth = 5;
        ctx_shadow_stroke_before.shadowColor = "black";
        ctx_shadow_stroke_before.shadowOffsetX = 50;
        ctx_shadow_stroke_before.shadowOffsetY = 50;
        ctx_shadow_stroke_before.shadowBlur = 20;

        // 计算矩形位置：水平1/3，垂直居中
        const rectWidthBefore = 200;
        const rectHeightBefore = 200;
        const xBefore = (canvas_shadow_stroke_before.offsetWidth - rectWidthBefore) / 2;
        const yBefore = (canvas_shadow_stroke_before.offsetHeight - rectHeightBefore) / 2;

        ctx_shadow_stroke_before.rect(xBefore, yBefore, rectWidthBefore, rectHeightBefore);
        ctx_shadow_stroke_before.stroke();
        ctx_shadow_stroke_before.fill();
      </script>
      <p class="分区普通文本">
        仔细思考一下，到底应该怎么办？此时比较好的办法是：放弃描边的阴影，只保留填充的阴影。但是，阴影的设置代码会同时应用到填充和描边。因此，我们要将<span
          class="强调"
          >阴影仅仅应用到填充</span
        >。
      </p>
      <pre>
        <code class="lang-javascript">
          //其它代码不变
          ctx.save();   //将"没有阴影"的上下文保存起来
          ctx.shadowColor = "black";  //阴影颜色
          ctx.shadowOffsetX = 50;     //水平偏移量
          ctx.shadowOffsetY = 50;     //垂直偏移量
          ctx.shadowBlur = 20;        //模糊
          ctx.fill();    //填充
          ctx.restore(); //恢复"没有阴影"的上下文

          ctx.stroke();  //现在描边就不会有阴影了，且描边在后，所以不会被填充的阴影挡住
        </code>
      </pre>
      <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
        <canvas
          id="canvas-shadow-stroke-after"
          style="width: 100%; height: calc(100% - 42px); background-color: #222"
        ></canvas>
      </figure>
      <p class="分区普通文本">这回看上去正常了。虽然失去了描边的阴影，但不影响整体的视觉效果。</p>
      <script>
        const canvas_shadow_stroke_after = document.getElementById("canvas-shadow-stroke-after");
        const ctx_shadow_stroke_after = canvas_shadow_stroke_after.getContext("2d");
        const dpr_shadow_stroke_after = window.devicePixelRatio || 1;
        canvas_shadow_stroke_after.width = canvas_shadow_stroke_after.offsetWidth * dpr_shadow_stroke_after;
        canvas_shadow_stroke_after.height = canvas_shadow_stroke_after.offsetHeight * dpr_shadow_stroke_after;
        ctx_shadow_stroke_after.scale(dpr_shadow_stroke_after, dpr_shadow_stroke_after);
        ctx_shadow_stroke_after.fillStyle = "darkgreen";
        ctx_shadow_stroke_after.strokeStyle = "gold";
        ctx_shadow_stroke_after.lineWidth = 3;

        const rectWidthAfter = 200;
        const rectHeightAfter = 200;
        const xAfter = (canvas_shadow_stroke_after.offsetWidth - rectWidthAfter) / 2;
        const yAfter = (canvas_shadow_stroke_after.offsetHeight - rectHeightAfter) / 2;

        ctx_shadow_stroke_after.rect(xAfter, yAfter, rectWidthAfter, rectHeightAfter);
        ctx_shadow_stroke_after.save();
        ctx_shadow_stroke_after.shadowColor = "black";
        ctx_shadow_stroke_after.shadowOffsetX = 50;
        ctx_shadow_stroke_after.shadowOffsetY = 50;
        ctx_shadow_stroke_after.shadowBlur = 20;
        ctx_shadow_stroke_after.fill();
        ctx_shadow_stroke_after.restore();
        ctx_shadow_stroke_after.stroke();
      </script>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">绘制虚线</h2>

    <h3 class="分区标题 分区3级标题">普通虚线</h3>
    <p class="分区普通文本">
      虚线用<span class="行内代码">setLineDash()</span
      >设置，其要点是：一段实线、一段透明线，交替绘制，我们只需要给出实线的长度和透明线的长度，两个数字用数组形式表示。
    </p>
    <pre>
      <code class="lang-javascript">
        //其它代码
        const 实线长度 = 20;
        const 透明线长度 = 10;
        ctx.setLineDash([实线长度, 透明线长度]);   //设置虚线
        ctx.stroke();  //描边
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-line-dash" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_line_dash = document.getElementById("canvas-line-dash");
      const ctx_line_dash = canvas_line_dash.getContext("2d");
      const dpr_line_dash = window.devicePixelRatio || 1;
      canvas_line_dash.width = canvas_line_dash.offsetWidth * dpr_line_dash;
      canvas_line_dash.height = canvas_line_dash.offsetHeight * dpr_line_dash;
      ctx_line_dash.scale(dpr_line_dash, dpr_line_dash);
      ctx_line_dash.strokeStyle = "darkgoldenrod";
      ctx_line_dash.lineWidth = 2;
      ctx_line_dash.setLineDash([20, 10]);
      ctx_line_dash.rect(300, 100, 200, 200);
      ctx_line_dash.stroke();
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">要从虚线恢复到实线，直接将虚线数组设置为空即可：</p>
      <pre>
        <code class="lang-javascript">
          ctx.setLineDash([]);  //将虚线数组设置为空，恢复实线
        </code>
      </pre>
    </section>

    <h3 class="分区标题 分区3级标题">双色虚线</h3>
    <p class="分区普通文本">
      假设我们绘制这样一段虚线：<span class="行内专业名词">白色-透明</span
      >，这个虚线在浅色背景下就会看不清；如果改成：<span class="行内专业名词">黑色-透明</span
      >，在深色背景下又会看不清。怎么样才能在浅色深色背景下都能看得清楚呢？答案很简单：<span class="行内专业名词"
        >白色-黑色</span
      >。
    </p>
    <p class="分区普通文本">
      但是，<span class="行内代码">setLineDash()</span>只支持<span class="行内专业名词">不透明-透明</span
      >的模式，想要两段线都不透明，就要自己想想办法了。比较好的办法是：绘制两条虚线，第2条虚线进行位置偏移，然后合并两条虚线：
    </p>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制矩形 ----------------
        
        const 虚线长度 = 20;
        ctx.setLineDash([虚线长度, 虚线长度]);
        ctx.strokeStyle = "white";
        ctx.stroke();   //先绘制白线
        //不要用 beginPath()，确保白线和黑线绘制在同一个路径上
        ctx.lineDashOffset = 虚线长度;   //虚线偏移
        ctx.strokeStyle = "black";
        ctx.stroke();   //再绘制黑线

      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-line-dash-double" style="width: 100%; height: calc(100% - 42px)"></canvas>
    </figure>
    <script>
      const canvas_line_dash_double = document.getElementById("canvas-line-dash-double");
      const ctx_line_dash_double = canvas_line_dash_double.getContext("2d");
      const dpr_line_dash_double = window.devicePixelRatio || 1;
      canvas_line_dash_double.width = canvas_line_dash_double.offsetWidth * dpr_line_dash_double;
      canvas_line_dash_double.height = canvas_line_dash_double.offsetHeight * dpr_line_dash_double;
      ctx_line_dash_double.scale(dpr_line_dash_double, dpr_line_dash_double);

      // 动画参数
      let startTime = null;
      const totalDuration = 5.55; // 总动画时长：0.5 + 0.5 + 0.5 + 0.5 + 0.5 + 0.5 + 2.0 + 0.05 = 5.55秒

      // 矩形参数
      const dashRectWidth = 250;
      const dashRectHeight = 250;
      const centerY = canvas_line_dash_double.offsetHeight / 2 - dashRectHeight / 2;
      const whiteRectX = canvas_line_dash_double.offsetWidth / 4 - dashRectWidth / 2;
      const blackRectX = (canvas_line_dash_double.offsetWidth * 3) / 4 - dashRectWidth / 2;
      const overlapX = (whiteRectX + blackRectX) / 2;

      function animate(currentTime) {
        if (!startTime) startTime = currentTime;
        const elapsed = (currentTime - startTime) / 1000; // 转换为秒
        const cycleTime = elapsed % totalDuration; // 循环时间

        // 重置画布
        ctx_line_dash_double.fillStyle = "#678";
        ctx_line_dash_double.fillRect(0, 0, canvas_line_dash_double.offsetWidth, canvas_line_dash_double.offsetHeight);

        // 计算各阶段的进度
        let whiteAlpha = 0;
        let blackAlpha = 0;
        let lineDashOffset = 0;
        let whiteX = whiteRectX;
        let blackX = blackRectX;

        if (cycleTime < 0.5) {
          // 阶段1: 白色矩形淡入 (0-0.5s)
          whiteAlpha = cycleTime / 0.5;
        } else if (cycleTime < 1.0) {
          // 阶段2: 白色矩形保持显示 (0.5-1.0s)
          whiteAlpha = 1;
        } else if (cycleTime < 1.5) {
          // 阶段3: 黑色矩形淡入 (1.0-1.5s)
          whiteAlpha = 1;
          blackAlpha = (cycleTime - 1.0) / 0.5;
        } else if (cycleTime < 2.0) {
          // 阶段4: 黑色矩形保持显示 (1.5-2.0s)
          whiteAlpha = 1;
          blackAlpha = 1;
        } else if (cycleTime < 2.5) {
          // 阶段5: lineDashOffset动画 (2.0-2.5s)
          whiteAlpha = 1;
          blackAlpha = 1;
          lineDashOffset = ((cycleTime - 2.0) / 0.5) * 20;
        } else if (cycleTime < 3.0) {
          // 阶段6: 等待阶段 (2.5-3.0s) - lineDashOffset完成后等待0.5s
          whiteAlpha = 1;
          blackAlpha = 1;
          lineDashOffset = 20;
        } else if (cycleTime < 3.5) {
          // 阶段7: 矩形重合动画 (3.0-3.5s)
          whiteAlpha = 1;
          blackAlpha = 1;
          lineDashOffset = 20;
          const moveProgress = (cycleTime - 3.0) / 0.5;
          whiteX = whiteRectX + (overlapX - whiteRectX) * moveProgress;
          blackX = blackRectX + (overlapX - blackRectX) * moveProgress;
        } else if (cycleTime < 5.5) {
          // 阶段8: 重合后等待阶段 (3.5-5.5s) - 等待2秒
          whiteAlpha = 1;
          blackAlpha = 1;
          lineDashOffset = 20;
          whiteX = overlapX;
          blackX = overlapX;
        } else {
          // 阶段9: 最终等待阶段 (5.5-5.55s)
          whiteAlpha = 1;
          blackAlpha = 1;
          lineDashOffset = 20;
          whiteX = overlapX;
          blackX = overlapX;
        }

        // 绘制白色矩形
        if (whiteAlpha > 0) {
          ctx_line_dash_double.save();
          ctx_line_dash_double.globalAlpha = whiteAlpha;
          ctx_line_dash_double.strokeStyle = "white";
          ctx_line_dash_double.lineWidth = 2;
          ctx_line_dash_double.setLineDash([20, 20]);
          ctx_line_dash_double.beginPath();
          ctx_line_dash_double.rect(whiteX, centerY, dashRectWidth, dashRectHeight);
          ctx_line_dash_double.stroke();
          ctx_line_dash_double.restore();
        }

        // 绘制黑色矩形
        if (blackAlpha > 0) {
          ctx_line_dash_double.save();
          ctx_line_dash_double.globalAlpha = blackAlpha;
          ctx_line_dash_double.strokeStyle = "black";
          ctx_line_dash_double.lineWidth = 2;
          ctx_line_dash_double.setLineDash([20, 20]);
          ctx_line_dash_double.lineDashOffset = lineDashOffset;
          ctx_line_dash_double.beginPath();
          ctx_line_dash_double.rect(blackX, centerY, dashRectWidth, dashRectHeight);
          ctx_line_dash_double.stroke();
          ctx_line_dash_double.restore();
        }

        requestAnimationFrame(animate);
      }

      // 开始动画
      requestAnimationFrame(animate);
    </script>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">绘制渐变</h2>

    <h3 class="分区标题 分区3级标题"><span class="行内代码">CanvasGradient</span>对象</h3>
    <p class="分区普通文本">我们可以将使用渐变的步骤分解为<span class="行内专业名词">3</span>步：</p>
    <ol class="分区列表 有序列表">
      <li class="分区列表项">
        <span class="行内专业名词">创建渐变对象</span>：参数为<span class="行内专业名词">渐变起始坐标</span>和<span
          class="行内专业名词"
          >渐变结束坐标</span
        >
      </li>
      <li class="分区列表项">
        <span class="行内专业名词">添加色标</span>：参数为<span class="行内专业名词">位置</span>和<span
          class="行内专业名词"
          >颜色</span
        >
      </li>
      <li class="分区列表项"><span class="行内专业名词">将填充和描边设置为渐变对象</span></li>
    </ol>

    <h3 class="分区标题 分区3级标题">绘制线性渐变</h3>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制矩形 ----------------
        const 矩形宽度 = 400;
        const 矩形高度 = 200;
        const 矩形起始坐标 = { x: 200, y: 100 };
        ctx.rect(矩形起始坐标.x, 矩形起始坐标.y, 矩形宽度, 矩形高度);

        //创建渐变对象
        const 渐变起始坐标 = { x: 0, y: 100 };
        const 渐变结束坐标 = { x: canvas.offsetWidth, y: 100 };
        const 渐变对象 = ctx.createLinearGradient(
          渐变起始坐标.x, 
          渐变起始坐标.y, 
          渐变结束坐标.x, 
          渐变结束坐标.y
        );

        //添加色标
        const 色标1位置 = 0;    //代表 0% 的位置
        const 色标1颜色 = "blue";
        const 色标2位置 = 0.5;  //代表 50% 的位置
        const 色标2颜色 = "green";
        const 色标3位置 = 1;    //代表 100% 的位置
        const 色标3颜色 = "red";
        渐变对象.addColorStop(色标1位置, 色标1颜色);   //添加色标1
        渐变对象.addColorStop(色标2位置, 色标2颜色);   //添加色标2
        渐变对象.addColorStop(色标3位置, 色标3颜色);   //添加色标3

        //将填充设置为渐变对象
        ctx.fillStyle = 渐变对象;
        //绘制矩形
        ctx.fill();  //填充
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-linear-gradient"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <script>
      const canvas_linear_gradient = document.getElementById("canvas-linear-gradient");
      const ctx_linear_gradient = canvas_linear_gradient.getContext("2d");
      const dpr_linear_gradient = window.devicePixelRatio || 1;
      canvas_linear_gradient.width = canvas_linear_gradient.offsetWidth * dpr_linear_gradient;
      canvas_linear_gradient.height = canvas_linear_gradient.offsetHeight * dpr_linear_gradient;
      ctx_linear_gradient.scale(dpr_linear_gradient, dpr_linear_gradient);
      const 线性渐变矩形宽度 = 400;
      const 线性渐变矩形高度 = 200;
      const 线性渐变矩形起始坐标 = { x: 200, y: 100 };
      ctx_linear_gradient.rect(线性渐变矩形起始坐标.x, 线性渐变矩形起始坐标.y, 线性渐变矩形宽度, 线性渐变矩形高度);

      const 线性渐变起始坐标 = { x: 0, y: 100 };
      const 线性渐变结束坐标 = { x: canvas_linear_gradient.offsetWidth, y: 100 };
      const 线性渐变对象 = ctx_linear_gradient.createLinearGradient(
        线性渐变起始坐标.x,
        线性渐变起始坐标.y,
        线性渐变结束坐标.x,
        线性渐变结束坐标.y
      );

      const 线性渐变色标1位置 = 0;
      const 线性渐变色标1颜色 = "blue";
      const 线性渐变色标2位置 = 0.5;
      const 线性渐变色标2颜色 = "green";
      const 线性渐变色标3位置 = 1;
      const 线性渐变色标3颜色 = "red";
      线性渐变对象.addColorStop(线性渐变色标1位置, 线性渐变色标1颜色);
      线性渐变对象.addColorStop(线性渐变色标2位置, 线性渐变色标2颜色);
      线性渐变对象.addColorStop(线性渐变色标3位置, 线性渐变色标3颜色);

      ctx_linear_gradient.fillStyle = 线性渐变对象;
      ctx_linear_gradient.fill(); //填充
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        你是否感觉这个渐变两端的颜色没有完全展现出来？没错，渐变对象的应用范围<span class="强调">是</span
        ><span class="行内专业名词">整个Canvas</span>，<span class="强调">不是</span
        ><span class="行内专业名词">某个路径</span>。
      </p>
    </section>

    <h3 class="分区标题 分区3级标题">绘制径向渐变</h3>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制矩形 ----------------
        const 矩形宽度 = 500;
        const 矩形高度 = 300;
        const 矩形起始坐标 = { x: 150, y: 50 };
        ctx.rect(矩形起始坐标.x, 矩形起始坐标.y, 矩形宽度, 矩形高度);

        //创建径向渐变对象
        const 渐变起始圆心 = { 
          x: 矩形起始坐标.x + 矩形宽度 / 2,
          y: 矩形起始坐标.y + 矩形高度 / 2
        };
        const 渐变起始圆半径 = 50;

        const 渐变结束圆心 = {
          x: 矩形起始坐标.x + 矩形宽度 / 2,
          y: 矩形起始坐标.y + 矩形高度 / 2
        };
        const 渐变结束圆半径 = 矩形宽度 < 矩形高度 ? 矩形宽度 / 2 : 矩形高度 / 2;

        const 渐变对象 = ctx.createRadialGradient(
          渐变起始圆心.x,
          渐变起始圆心.y,
          渐变起始圆半径,
          渐变结束圆心.x,
          渐变结束圆心.y,
          渐变结束圆半径
        );

        //添加色标
        const 色标1位置 = 0;    //代表 0% 的位置
        const 色标1颜色 = "darkgoldenrod";
        const 色标2位置 = 0.5;  //代表 50% 的位置
        const 色标2颜色 = "green";
        const 色标3位置 = 1;    //代表 100% 的位置
        const 色标3颜色 = "silver";
        渐变对象.addColorStop(色标1位置, 色标1颜色);   //添加色标1
        渐变对象.addColorStop(色标2位置, 色标2颜色);   //添加色标2
        渐变对象.addColorStop(色标3位置, 色标3颜色);   //添加色标3

        //将填充设置为渐变对象
        ctx.fillStyle = 渐变对象;
        //绘制矩形
        ctx.fill();  //填充
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-radial-gradient"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <script>
      const canvas_radial_gradient = document.getElementById("canvas-radial-gradient");
      const ctx_radial_gradient = canvas_radial_gradient.getContext("2d");
      const dpr_radial_gradient = window.devicePixelRatio || 1;
      canvas_radial_gradient.width = canvas_radial_gradient.offsetWidth * dpr_radial_gradient;
      canvas_radial_gradient.height = canvas_radial_gradient.offsetHeight * dpr_radial_gradient;
      ctx_radial_gradient.scale(dpr_radial_gradient, dpr_radial_gradient);
      const 径向渐变矩形宽度 = 500;
      const 径向渐变矩形高度 = 300;
      const 径向渐变矩形起始坐标 = { x: 150, y: 50 };
      ctx_radial_gradient.rect(径向渐变矩形起始坐标.x, 径向渐变矩形起始坐标.y, 径向渐变矩形宽度, 径向渐变矩形高度);

      const 径向渐变起始圆心 = {
        x: 径向渐变矩形起始坐标.x + 径向渐变矩形宽度 / 2,
        y: 径向渐变矩形起始坐标.y + 径向渐变矩形高度 / 2,
      };
      const 径向渐变起始圆半径 = 50;
      const 径向渐变结束圆心 = {
        x: 径向渐变矩形起始坐标.x + 径向渐变矩形宽度 / 2,
        y: 径向渐变矩形起始坐标.y + 径向渐变矩形高度 / 2,
      };
      const 径向渐变结束圆半径 = 径向渐变矩形宽度 < 径向渐变矩形高度 ? 径向渐变矩形宽度 / 2 : 径向渐变矩形高度 / 2;
      const 径向渐变对象 = ctx_radial_gradient.createRadialGradient(
        径向渐变起始圆心.x,
        径向渐变起始圆心.y,
        径向渐变起始圆半径,
        径向渐变结束圆心.x,
        径向渐变结束圆心.y,
        径向渐变结束圆半径
      );

      const 径向渐变色标1位置 = 0;
      const 径向渐变色标1颜色 = "darkgoldenrod";
      const 径向渐变色标2位置 = 0.5;
      const 径向渐变色标2颜色 = "green";
      const 径向渐变色标3位置 = 1;
      const 径向渐变色标3颜色 = "silver";
      径向渐变对象.addColorStop(径向渐变色标1位置, 径向渐变色标1颜色);
      径向渐变对象.addColorStop(径向渐变色标2位置, 径向渐变色标2颜色);
      径向渐变对象.addColorStop(径向渐变色标3位置, 径向渐变色标3颜色);

      ctx_radial_gradient.fillStyle = 径向渐变对象;
      ctx_radial_gradient.fill(); //填充
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本"><span class="行内专业名词">Canvas</span>径向渐变目前只能为正圆，不能为椭圆。</p>
    </section>

    <h3 class="分区标题 分区3级标题">绘制角度渐变</h3>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制矩形 ----------------
        const 矩形宽度 = canvas.offsetWidth;
        const 矩形高度 = canvas.offsetHeight;
        const 矩形起始坐标 = { x: 0, y: 0 };
        ctx.rect(矩形起始坐标.x, 矩形起始坐标.y, 矩形宽度, 矩形高度);

        //创建角度渐变对象
        const 角度渐变起始弧度 = Math.PI;   //从默认起始角度顺时针旋转180°
        const 角度渐变圆心 = { x: canvas.offsetWidth / 2, y: canvas.offsetHeight / 2 };
        const 角度渐变对象 = ctx.createConicGradient(角度渐变起始弧度, 角度渐变圆心.x, 角度渐变圆心.y);

        //添加色标
        const 色标1位置 = 0;     //代表 0% 的位置
        const 色标1颜色 = "blue";
        const 色标2位置 = 0.25;  //代表 50% 的位置
        const 色标2颜色 = "orange";
        const 色标3位置 = 0.5;   //代表 50% 的位置
        const 色标3颜色 = "green";
        const 色标4位置 = 0.75;  //代表 75% 的位置
        const 色标4颜色 = "yellow";
        const 色标5位置 = 1;     //代表 100% 的位置
        const 色标5颜色 = "purple";
        角度渐变对象.addColorStop(色标1位置, 色标1颜色);   //添加色标1
        角度渐变对象.addColorStop(色标2位置, 色标2颜色);   //添加色标2
        角度渐变对象.addColorStop(色标3位置, 色标3颜色);   //添加色标3
        角度渐变对象.addColorStop(色标4位置, 色标4颜色);   //添加色标4
        角度渐变对象.addColorStop(色标5位置, 色标5颜色);   //添加色标5

        //将填充设置为角度渐变对象
        ctx.fillStyle = 角度渐变对象;
        //绘制矩形
        ctx.fill();  //填充
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-conic-gradient"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <script>
      const canvas_conic_gradient = document.getElementById("canvas-conic-gradient");
      const ctx_conic_gradient = canvas_conic_gradient.getContext("2d");
      const dpr_conic_gradient = window.devicePixelRatio || 1;
      canvas_conic_gradient.width = canvas_conic_gradient.offsetWidth * dpr_conic_gradient;
      canvas_conic_gradient.height = canvas_conic_gradient.offsetHeight * dpr_conic_gradient;
      ctx_conic_gradient.scale(dpr_conic_gradient, dpr_conic_gradient);
      const 角度渐变矩形宽度 = canvas_conic_gradient.offsetWidth;
      const 角度渐变矩形高度 = canvas_conic_gradient.offsetHeight;
      const 角度渐变矩形起始坐标 = { x: 0, y: 0 };
      ctx_conic_gradient.rect(角度渐变矩形起始坐标.x, 角度渐变矩形起始坐标.y, 角度渐变矩形宽度, 角度渐变矩形高度);

      const 角度渐变起始弧度 = Math.PI;
      const 角度渐变圆心 = { x: canvas_conic_gradient.offsetWidth / 2, y: canvas_conic_gradient.offsetHeight / 2 };
      const 角度渐变对象 = ctx_conic_gradient.createConicGradient(角度渐变起始弧度, 角度渐变圆心.x, 角度渐变圆心.y);

      const 角度渐变色标1位置 = 0;
      const 角度渐变色标1颜色 = "blue";
      const 角度渐变色标2位置 = 0.25;
      const 角度渐变色标2颜色 = "orange";
      const 角度渐变色标3位置 = 0.5;
      const 角度渐变色标3颜色 = "green";
      const 角度渐变色标4位置 = 0.75;
      const 角度渐变色标4颜色 = "yellow";
      const 角度渐变色标5位置 = 1;
      const 角度渐变色标5颜色 = "purple";
      角度渐变对象.addColorStop(角度渐变色标1位置, 角度渐变色标1颜色);
      角度渐变对象.addColorStop(角度渐变色标2位置, 角度渐变色标2颜色);
      角度渐变对象.addColorStop(角度渐变色标3位置, 角度渐变色标3颜色);
      角度渐变对象.addColorStop(角度渐变色标4位置, 角度渐变色标4颜色);
      角度渐变对象.addColorStop(角度渐变色标5位置, 角度渐变色标5颜色);

      ctx_conic_gradient.fillStyle = 角度渐变对象;
      ctx_conic_gradient.fill(); //填充
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        <span class="行内专业名词">Canvas</span>角度渐变默认起始弧度为<span class="行内代码">0</span
        >，但却是水平向右的，因此顺时针旋转<span class="行内代码">180°</span>后，起始角度变成水平向左。
      </p>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">绘制图像</h2>

    <h3 class="分区标题 分区3级标题">函数语法</h3>
    <p class="分区普通文本">绘制图像用<span class="行内代码">ctx.drawImage()</span>函数，它有3个重载：</p>
    <ol class="分区列表 有序列表">
      <li class="分区列表项">
        <span class="行内专业名词">3</span>个参数：
        <pre style="margin-top: 30px">
          <code class="lang-javascript">
            ctx.drawImage(源图像, 画布坐标.x, 画布坐标.y);
          </code>
        </pre>
        <p class="分区普通文本">
          所谓的<span class="行内专业名词">画布</span>就是指<span class="行内代码">Canvas</span
          >元素，但是这么做会将源图像尺寸原封不动地搬到画布上，如果源图像尺寸过大，就会溢出画布。因此这个重载方式很少使用。
        </p>
      </li>
      <li class="分区列表项">
        <span class="行内专业名词">5</span>个参数：
        <pre style="margin-top: 30px">
          <code class="lang-javascript">
            ctx.drawImage(源图像, 画布坐标.x, 画布坐标.y, 画布图像宽度, 画布图像高度);
          </code>
        </pre>
        <p class="分区普通文本">这个重载可以指定图像在画布上的尺寸，是最常用的一种重载。</p>
      </li>
      <li class="分区列表项">
        <span class="行内专业名词">9</span>个参数：
        <pre style="margin-top: 30px">
          <code class="lang-javascript">
            ctx.drawImage(
              源图像, 
              源图像裁剪坐标.x,
              源图像裁剪坐标.y,
              源图像裁剪宽度,
              源图像裁剪高度,
              画布坐标.x, 
              画布坐标.y, 
              画布图像宽度, 
              画布图像高度
            );
          </code>
        </pre>
        <p class="分区普通文本">说简单一点就是：你可以只选取源图像的一部分进行绘制。</p>
      </li>
    </ol>

    <h3 class="分区标题 分区3级标题">用法展示</h3>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        图像加载是异步的，意味着一边是图像正在加载中，而另一边，后续的程序不会等待图形的加载。这很有可能导致图像还没有加载完成，<span
          class="行内代码"
          >drawImage()</span
        >就已经开始运行了，导致绘图失败。
      </p>
      <p class="分区普通文本">
        举个例子，假设图像加载需要<span class="行内专业名词">0.01s</span>，可是后续的<span class="行内代码"
          >drawImage()</span
        >只需要<span class="行内专业名词">0.000001s</span>，那么，<span class="行内代码">drawImage()</span
        >就会在图像加载完成之前开始运行，导致绘图失败。
      </p>
      <p class="分区普通文本">
        因此，必须等待图像加载完成，才能运行<span class="行内代码">drawImage()</span
        >以及任何需要读取图像尺寸的代码。其代码为：
      </p>
      <pre>
        <code class="lang-javascript">
          图像.onload = 函数(绘图代码, 读取尺寸代码);
        </code>
      </pre>
    </section>
    <p class="分区普通文本">为了更好地展示效果，我们选一张尺寸非常大的图像，将其绘制到画布上。</p>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制图像 ----------------
        const 源图像 = new Image();   //创建图像对象
        源图像.src = "/Images/Background-Images/轮播图-09.jpg";   //设置图像源
        const 画布坐标 = { x: 0, y: 0 };   //设置图像在画布上的坐标

        //重要！！！！！不能直接运行 drawImage()，必须等待图像加载完成！！！！！
        源图像.onload = function () {
          ctx.drawImage(源图像, 画布坐标.x, 画布坐标.y);
        }
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-draw-image" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      图像从画布左上角开始绘制，由于图像尺寸过大，绝大部分内容都溢出了<span class="行内专业名词">Canvas</span>。
    </p>
    <script>
      const canvas_draw_image = document.getElementById("canvas-draw-image");
      const ctx_draw_image = canvas_draw_image.getContext("2d");
      const dpr_draw_image = window.devicePixelRatio || 1;
      canvas_draw_image.width = canvas_draw_image.offsetWidth * dpr_draw_image;
      canvas_draw_image.height = canvas_draw_image.offsetHeight * dpr_draw_image;
      ctx_draw_image.scale(dpr_draw_image, dpr_draw_image);

      const 源图像 = new Image();
      源图像.src = "/Images/Background-Images/轮播图-09.jpg";
      const 画布坐标 = { x: 0, y: 0 };
      源图像.onload = function () {
        ctx_draw_image.drawImage(源图像, 画布坐标.x, 画布坐标.y);
      };
      源图像.onerror = function () {
        console.warn("图像加载失败:", 源图像.src);
      };
    </script>
    <p class="分区普通文本">现在，让我们用<span class="行内专业名词">5</span>参数方式指定图形绘制尺寸：</p>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制图像 ----------------
        const 源图像 = new Image();   //创建图像对象
        源图像.src = "/Images/Background-Images/轮播图-09.jpg";   //设置图像源
        const 画布坐标 = { x: 0, y: 0 };   //设置图像在画布上的坐标

        源图像.onload = function () {
          ctx.drawImage(源图像, 画布坐标.x, 画布坐标.y, 画布宽度, 画布高度);  //指定宽高
        }
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-draw-image-5-params"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <p class="分区普通文本">
      绘制尺寸指定为正好和画布尺寸相同。看起来很完美是不是？这只是巧合！！！因为源图像和画布的宽高比正好差不多，所以图像没有出现比例失调的情况。
    </p>
    <script>
      const canvas_draw_image_5_params = document.getElementById("canvas-draw-image-5-params");
      const ctx_draw_image_5_params = canvas_draw_image_5_params.getContext("2d");
      const dpr_draw_image_5_params = window.devicePixelRatio || 1;
      canvas_draw_image_5_params.width = canvas_draw_image_5_params.offsetWidth * dpr_draw_image_5_params;
      canvas_draw_image_5_params.height = canvas_draw_image_5_params.offsetHeight * dpr_draw_image_5_params;
      ctx_draw_image_5_params.scale(dpr_draw_image_5_params, dpr_draw_image_5_params);

      const 源图像_5_params = new Image();
      源图像_5_params.src = "/Images/Background-Images/轮播图-09.jpg";
      const 画布坐标_5_params = { x: 0, y: 0 };
      const 画布图像宽度_5_params = canvas_draw_image_5_params.offsetWidth;
      const 画布图像高度_5_params = canvas_draw_image_5_params.offsetHeight;
      源图像_5_params.onload = function () {
        ctx_draw_image_5_params.drawImage(
          源图像_5_params,
          画布坐标_5_params.x,
          画布坐标_5_params.y,
          画布图像宽度_5_params,
          画布图像高度_5_params
        );
      };
      源图像_5_params.onerror = function () {
        console.warn("图像加载失败:", 源图像_5_params.src);
      };
    </script>
    <p class="分区普通文本">让我们换一张正方形的图像试一试就知道了：</p>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-draw-image-5-params-vertical"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <p class="分区普通文本">&#128561;&#128561;&#128561; 麦麦你怎么了！！！如山的压力把麦麦压扁了！！！</p>
    <script>
      const canvas_draw_image_5_params_vertical = document.getElementById("canvas-draw-image-5-params-vertical");
      const ctx_draw_image_5_params_vertical = canvas_draw_image_5_params_vertical.getContext("2d");
      const dpr_draw_image_5_params_vertical = window.devicePixelRatio || 1;
      canvas_draw_image_5_params_vertical.width =
        canvas_draw_image_5_params_vertical.offsetWidth * dpr_draw_image_5_params_vertical;
      canvas_draw_image_5_params_vertical.height =
        canvas_draw_image_5_params_vertical.offsetHeight * dpr_draw_image_5_params_vertical;
      ctx_draw_image_5_params_vertical.scale(dpr_draw_image_5_params_vertical, dpr_draw_image_5_params_vertical);

      const 源图像_5_params_vertical = new Image();
      源图像_5_params_vertical.src = "/Interactive-Hub/Object-Fit/03.jpg";
      const 画布坐标_5_params_vertical = { x: 0, y: 0 };
      const 画布图像宽度_5_params_vertical = canvas_draw_image_5_params_vertical.offsetWidth;
      const 画布图像高度_5_params_vertical = canvas_draw_image_5_params_vertical.offsetHeight;
      源图像_5_params_vertical.onload = function () {
        ctx_draw_image_5_params_vertical.drawImage(
          源图像_5_params_vertical,
          画布坐标_5_params_vertical.x,
          画布坐标_5_params_vertical.y,
          画布图像宽度_5_params_vertical,
          画布图像高度_5_params_vertical
        );
      };
      源图像_5_params_vertical.onerror = function () {
        console.warn("图像加载失败:", 源图像_5_params_vertical.src);
      };
    </script>

    <h3 class="分区标题 分区3级标题">处理宽高比</h3>
    <p class="分区普通文本">
      想要在<span class="行内专业名词">Canvas</span
      >中处理好图像比例，不是一件容易的事。我们必须先算出源图像的宽高比，在绘制的时候使用相同的宽高比，才能保证图像的比例不失调。
    </p>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制图像 ----------------
        const 源图像 = new Image();   //创建图像对象
        源图像.src = "/Images/Background-Images/轮播图-09.jpg";   //设置图像源

        源图像.onload = function () {
          //这些代码都要放在 onload 内部，否则图像还没有加载完成，得到的宽度高度都是 0
          const 源图像宽度 = 源图像.naturalWidth;
          const 源图像高度 = 源图像.naturalHeight;
          const 源图像宽高比 = 源图像宽度 / 源图像高度;

          const 画布_宽高中更小值 = 
            canvas.offsetWidth &lt; canvas.offsetHeight ? canvas.offsetWidth : canvas.offsetHeight;

          const 画布坐标 = {
            x: (canvas.offsetWidth - 画布_宽高中更小值) / 2,   //图像在画布中水平居中
            y: 0
          };  

          if(画布_宽高中更小值 === canvas.offsetWidth) {
            ctx.drawImage(
              源图像, 
              画布坐标.x, 
              画布坐标.y, 
              画布_宽高中更小值,   //绘制宽度
              画布_宽高中更小值 / 源图像宽高比   //绘制高度
            );
          } else {
            ctx.drawImage(
              源图像, 
              画布坐标.x, 
              画布坐标.y, 
              画布_宽高中更小值 * 源图像宽高比,   //绘制宽度
              画布_宽高中更小值   //绘制高度
            );
          }
        }
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-draw-image-5-params-vertical-fixed"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <p class="分区普通文本">&#129401;&#129401;&#129401; 麦麦你终于正常了！！！</p>
    <script>
      const canvas_draw_image_5_params_vertical_fixed = document.getElementById(
        "canvas-draw-image-5-params-vertical-fixed"
      );
      const ctx_draw_image_5_params_vertical_fixed = canvas_draw_image_5_params_vertical_fixed.getContext("2d");
      const dpr_draw_image_5_params_vertical_fixed = window.devicePixelRatio || 1;
      canvas_draw_image_5_params_vertical_fixed.width =
        canvas_draw_image_5_params_vertical_fixed.offsetWidth * dpr_draw_image_5_params_vertical_fixed;
      canvas_draw_image_5_params_vertical_fixed.height =
        canvas_draw_image_5_params_vertical_fixed.offsetHeight * dpr_draw_image_5_params_vertical_fixed;
      ctx_draw_image_5_params_vertical_fixed.scale(
        dpr_draw_image_5_params_vertical_fixed,
        dpr_draw_image_5_params_vertical_fixed
      );

      const 源图像_5_params_vertical_fixed = new Image();
      源图像_5_params_vertical_fixed.src = "/Interactive-Hub/Object-Fit/03.jpg";
      源图像_5_params_vertical_fixed.onload = function () {
        const 源图像实际宽度 = 源图像_5_params_vertical_fixed.naturalWidth;
        const 源图像实际高度 = 源图像_5_params_vertical_fixed.naturalHeight;
        const 源图像宽高比 = 源图像实际宽度 / 源图像实际高度;
        const 画布宽高比 =
          canvas_draw_image_5_params_vertical_fixed.offsetWidth /
          canvas_draw_image_5_params_vertical_fixed.offsetHeight;
        let 画布图像宽度_5_params_vertical_fixed = 0;
        let 画布图像高度_5_params_vertical_fixed = 0;
        const 画布图像_更小尺寸_5_params_vertical_fixed =
          canvas_draw_image_5_params_vertical_fixed.offsetWidth < canvas_draw_image_5_params_vertical_fixed.offsetHeight
            ? canvas_draw_image_5_params_vertical_fixed.offsetWidth
            : canvas_draw_image_5_params_vertical_fixed.offsetHeight;
        if (画布图像_更小尺寸_5_params_vertical_fixed === canvas_draw_image_5_params_vertical_fixed.offsetWidth) {
          画布图像宽度_5_params_vertical_fixed = 画布图像_更小尺寸_5_params_vertical_fixed;
          画布图像高度_5_params_vertical_fixed = 画布图像_更小尺寸_5_params_vertical_fixed / 源图像宽高比;
        } else {
          画布图像高度_5_params_vertical_fixed = 画布图像_更小尺寸_5_params_vertical_fixed;
          画布图像宽度_5_params_vertical_fixed = 画布图像高度_5_params_vertical_fixed * 源图像宽高比;
        }
        const 画布坐标_5_params_vertical_fixed = {
          x: (canvas_draw_image_5_params_vertical_fixed.offsetWidth - 画布图像_更小尺寸_5_params_vertical_fixed) / 2,
          y: 0,
        };

        ctx_draw_image_5_params_vertical_fixed.drawImage(
          源图像_5_params_vertical_fixed,
          画布坐标_5_params_vertical_fixed.x,
          画布坐标_5_params_vertical_fixed.y,
          画布图像宽度_5_params_vertical_fixed,
          画布图像高度_5_params_vertical_fixed
        );
      };
      源图像_5_params_vertical_fixed.onerror = function () {
        console.warn("图像加载失败:", 源图像_5_params_vertical_fixed.src);
      };
    </script>
  </article>
</div>
