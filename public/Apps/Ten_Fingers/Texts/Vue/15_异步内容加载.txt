Async content - like data fetched from APIs or lazy-loaded components - can cause awkward loading states in Vue apps: blank spaces, janky UI shifts, or broken layouts. Vue 3's built-in Suspense component solves this by providing a unified way to handle loading and error states for async content. This article explains how Suspense works, its key features, and how to use it in your Vue 3 apps.​
First, it's important to note what Suspense does (and doesn't do). Suspense is not a data-fetching library - it's a wrapper component that waits for async dependencies to resolve, then renders the content. It works with two types of async content: async components (loaded via defineAsyncComponent) and components with async setup functions (functions that return a promise, e.g., fetching data in setup() with await).​
The basic structure of Suspense is simple: it uses two slots - #default for the content to render once async dependencies are ready, and #fallback for the loading state to show while waiting. For example, if you're lazy-loading a ProductList component, you'd wrap it in Suspense: the #fallback slot might show a spinner or "Loading products..." text, and the #default slot holds the ProductList component. While ProductList loads, users see the fallback; once loaded, Suspense swaps the fallback with the component.​
Suspense also handles async data fetching in setup(). If your component's setup() function is async (e.g., it uses await to fetch data from an API), Suspense will wait for the promise to resolve before rendering the component. This eliminates the need for manual loading state management (like tracking isLoading flags) and keeps your component code cleaner.​
Error handling is another useful feature of Suspense - though it doesn't handle errors directly, it works with Vue's error boundaries. An error boundary is a component that uses the errorCaptured hook to catch errors from its children. If an async component fails to load or an async setup() throws an error, the error boundary can catch it and render an error message (e.g., "Failed to load content") instead of breaking the entire app. By combining Suspense with error boundaries, you create a robust async content flow: loading → success/error.​
But Suspense has limitations. It's still marked as "experimental" in Vue 3 (though it's stable for most use cases) and doesn't support nested Suspense components reliably. It also can't handle async content in all places - for example, it won't wait for async data fetched in onMounted() (since onMounted() runs after the component renders). For such cases, you'll still need manual loading states.​
In practice, Suspense shines in scenarios like lazy-loading route components (with Vue Router) or fetching initial data for a page. For example, using Suspense with a lazy-loaded Checkout component ensures users see a clear loading state while the component and its dependencies load, improving user experience.​
In summary, Vue 3's Suspense component simplifies async content management by unifying loading states. While it has minor limitations, it's a valuable tool for creating smooth, user-friendly experiences when dealing with async components or data - especially when combined with error boundaries for robust error handling.
