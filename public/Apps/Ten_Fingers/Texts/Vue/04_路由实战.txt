Vue Router is more than just a tool for navigating between pages - it offers advanced features that help you control access to routes, customize navigation behavior, and pass additional data to routes. For developers building complex single-page applications (SPAs), mastering these advanced features is essential to creating secure, flexible, and user-friendly experiences. This article will dive into three key advanced features of Vue Router: route guards, dynamic route matching, and route meta information, with practical examples of how to implement them in real-world projects.​
Let's begin with route guards, which are functions that run before or after a route is navigated to or away from. They allow you to control whether a navigation should proceed, redirect to another route, or perform actions like loading data or validating authentication. Vue Router provides three main types of route guards: global guards (apply to all routes), per-route guards (apply to a specific route), and in-component guards (apply to a component when it's entered or left).​
Global guards are defined when creating the router instance and affect every navigation in the app. The most commonly used global guard is beforeEach, which runs before each navigation is confirmed. This is ideal for authentication checks - for example, if a user tries to access a protected route (like a dashboard) without being logged in, beforeEach can redirect them to the login page. To implement beforeEach, you pass a function that takes three arguments: to (the target route object), from (the current route being left), and next (a function to resolve the navigation). The next function must be called to confirm or modify the navigation - you can call next() to proceed, next('/login') to redirect, or next(false) to abort the navigation.​
Another useful global guard is afterEach, which runs after a navigation is confirmed. Unlike beforeEach, afterEach doesn't take a next function because the navigation has already completed. This guard is great for actions like logging navigation events (to track user behavior) or updating the page title based on the target route. For example, you can use afterEach to set document.title = to.meta.title (using route meta information, which we'll cover later) to ensure the browser tab displays a relevant title for each page.​
Per-route guards are defined directly in the route configuration and apply only to that specific route. The most common per-route guard is beforeEnter, which runs before navigating to the route. This is useful for route-specific checks - for example, if a route requires a specific user role (like an admin route), beforeEnter can validate the user's role and redirect if they don't have permission. Unlike beforeEach, beforeEnter is only triggered when navigating to the route directly, not when navigating between child routes of the same parent.​
In-component guards are defined inside a component and run when the component is entered or left via routing. The three main in-component guards are beforeRouteEnter, beforeRouteUpdate, and beforeRouteLeave. beforeRouteEnter runs before the component is created, so you can't access this (the component instance) directly - instead, you can pass a callback to next that receives the component instance as an argument. This is useful for fetching data that the component needs before it's rendered. beforeRouteUpdate runs when the route changes but the component remains the same (e.g., navigating from /user/1 to /user/2), allowing you to update the component's data without reloading the component. beforeRouteLeave runs when leaving the component, which is ideal for prompting the user to save changes before navigating away (e.g., if they're editing a form with unsaved data).​
Next, let's explore dynamic route matching, a feature that allows you to create flexible routes with variable segments. Dynamic routes are defined by adding a colon (:) to a route path - for example, /user/:id where id is a dynamic parameter. This lets you match multiple routes to the same component, with the dynamic parameter changing based on the URL. For example, /user/1 and /user/2 both render the same UserProfile component, but the component can access the id parameter to fetch and display the correct user data.​
To access dynamic parameters in a component, you can use the $route object (in Options API) or the useRoute hook (in Composition API). The $route.params object contains all dynamic parameters for the current route - for example, $route.params.id gives you the id value from the URL. One important thing to note is that when navigating between dynamic routes that use the same component (e.g., from /user/1 to /user/2), the component is not recreated. This means the component's lifecycle hooks (like created or mounted) won't run again, so you need to use the beforeRouteUpdate guard or watch the $route.params object to update the component's data when the parameter changes.​
Dynamic routes can also include optional segments (by adding a question mark ?), wildcard segments (using an asterisk *), or repeated segments (using a plus sign +). Optional segments allow a route to match with or without a specific part - for example, /user/:id? matches both /user and /user/1. Wildcard segments match any characters (including slashes) and are useful for catch-all routes - for example, * can be used to create a 404 page that matches any undefined route. Repeated segments allow a parameter to be repeated multiple times - for example, /user/:ids+ matches /user/1 and /user/1,2,3 (though you'll need to parse the ids parameter as a list in the component).​
Finally, let's discuss route meta information (or "meta" for short), which is additional data you can attach to a route in its configuration. Meta information is stored in the meta property of the route object and can include any data you need - like page titles, authentication requirements, role permissions, or breadcrumb labels. This data is accessible in route guards, the $route object, and components, making it a flexible way to pass configuration to routes.​
One common use case for meta information is setting page titles. Instead of hardcoding the title in each component, you can define a title property in the route's meta object (e.g., meta: { title: 'User Profile' }) and use a global afterEach guard to update the document title on each navigation. This ensures consistency across the app and makes it easy to update titles without modifying component code.​
Another use case is marking routes as protected. You can add a requiresAuth property to the route's meta object (e.g., meta: { requiresAuth: true }) and use a global beforeEach guard to check if the route requires authentication. If the user is not logged in and the route requires authentication, the guard can redirect them to the login page. You can also use meta information to define role-based access control - for example, meta: { requiresRole: 'admin' } - and the guard can validate the user's role before allowing access.​
Meta information is also inherited by child routes. If a parent route has a meta property, all its child routes will inherit that property unless they override it. For example, if a parent route /dashboard has meta: { requiresAuth: true }, then child routes like /dashboard/profile and /dashboard/settings will also require authentication, even if they don't define their own meta object. This is useful for grouping routes with similar requirements and reducing code duplication.​
In conclusion, Vue Router's advanced features - route guards, dynamic route matching, and route meta information - provide the tools you need to build secure, flexible, and user-friendly SPAs. By using route guards to control navigation and validate access, dynamic routes to create flexible URL patterns, and meta information to pass configuration data, you can handle complex routing scenarios with ease. Whether you're building a small app or a large enterprise project, mastering these features will help you create a better navigation experience for your users.
