Electron apps often need to store data locally - user settings, offline content, or app state - and integrating a local database simplifies this process. The best databases for Electron are lightweight, file-based (no server required), and compatible with Node.js, ensuring seamless integration with the main process. Popular choices include SQLite (via sqlite3), IndexedDB (for renderer process), and NeDB (a NoSQL option).​
For SQLite (a relational database), use the sqlite3 npm package, which works well in the main process. Install it with npm install sqlite3 --save - note that you may need to rebuild the package for Electron (use electron-rebuild if you get errors: npx electron-rebuild -f -w sqlite3). In the main process, connect to a database file: const sqlite3 = require('sqlite3').verbose(); const db = new sqlite3.Database('user-data.db'); (this creates the file if it doesn't exist). Create tables for your data (e.g., a settings table for user preferences) with db.run('CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY, value TEXT)'). Use db.get() to fetch data (e.g., db.get('SELECT value FROM settings WHERE key = ?', ['theme'], (err, row) => { ... })) and db.run() to insert/update data.​
For IndexedDB (a browser-based NoSQL database), use it in the renderer process - since it's built into Chromium, no extra packages are needed. IndexedDB is ideal for storing large datasets (e.g., offline notes) and works with front-end frameworks. To use it, create a database connection in the renderer: const request = indexedDB.open('NotesDB', 1); (the second argument is the database version). Handle the onupgradeneeded event to create object stores (similar to tables): request.onupgradeneeded = (event) => { const db = event.target.result; db.createObjectStore('notes', { keyPath: 'id' }); }. Use transactions to add/retrieve data - for example, inserting a note: const transaction = db.transaction('notes', 'readwrite'); const store = transaction.objectStore('notes'); store.add({ id: 1, content: 'Hello World', date: new Date() });.​
For NeDB (a NoSQL database similar to MongoDB), use it in the main process for simple, file-based storage. Install it with npm install nedb --save. Create a database instance: const Datastore = require('nedb'); const db = new Datastore({ filename: 'user-settings.db', autoload: true }); (autoloads the database on startup). Insert data with db.insert({ theme: 'dark', notifications: true }, (err, newDoc) => { ... }) and fetch data with db.findOne({ theme: { $exists: true } }, (err, doc) => { ... }). NeDB is lightweight (no extra dependencies) and great for small to medium datasets - perfect for app settings or user profiles.​
Best practices: Store database files in the app's user data directory (accessed via app.getPath('userData') in the main process) instead of the app's installation folder - this avoids permission issues (installation folders are often read-only) and ensures data persists across updates. For sensitive data (e.g., passwords), encrypt the database: use crypto (Node.js module) to encrypt data before storing and decrypt after fetching. Back up the database periodically - add a "Backup Data" feature that copies the database file to the user's Downloads folder.​
Test database functionality across OSes: SQLite and NeDB files work consistently on Windows/macOS/Linux, but IndexedDB may have subtle differences in Chromium versions - test to ensure data is saved and retrieved correctly. Avoid long-running database operations in the main process (e.g., bulk inserts) as they block the event loop - use setImmediate() or offload to a background process if needed.​
In short, integrating a local database into your Electron app lets you store data reliably offline. Choose SQLite for relational data, IndexedDB for renderer-side storage, or NeDB for simple NoSQL needs - all work seamlessly with Electron, ensuring your app can handle user data without relying on cloud services.
