A closure is the combination of a function and the lexical environment within which it was declared. This environment consists of any local variables that were in scope at the time the closure was created. Closures allow data privacy and stateful functions without relying on global variables. A classic example is a counter factory: function createCounter() { let count = 0; return () => ++count; }. Each invocation of createCounter returns a new function that retains its own count variable, inaccessible from the outside world. Closures are heavily used in event handlers, callbacks, and module patterns. Common pitfalls include the infamous loop problem in early JavaScript, where all callbacks created inside a for loop referenced the same variable i, leading to every callback logging the final value. The solution is to use let or an IIFE to capture the current value. Memory leaks can also occur if closures reference large DOM nodes or objects that are no longer needed, preventing garbage collection. Understanding how scope chains and garbage collection interact helps prevent retaining unnecessary memory. Used wisely, closures enable elegant encapsulation, partial application, and functional programming techniques such as currying and memoization.
