JavaScript runs on a single thread, so asynchronous patterns are essential for performing long-running operations such as network requests, file I/O, or timers without freezing the user interface. The original approach was callbacks: you pass a function that will be executed once the operation completes. While simple, callbacks can lead to deeply nested structures nicknamed "callback hell" or "pyramid of doom," making error handling and readability difficult. Promises were introduced to flatten this structure. A Promise represents a value that may be available now, later, or never, and it exists in one of three states: pending, fulfilled, or rejected. The then method chains subsequent operations, while catch handles rejections. Static methods like Promise.all, Promise.race, and Promise.allSettled coordinate multiple async operations. ES2017 introduced async/await, syntactic sugar that makes asynchronous code look and behave like synchronous code. Inside an async function, the await keyword pauses execution until the Promise settles, but it does not block the event loop. Error handling uses familiar try/catch blocks. Mixing callbacks and async/await requires careful promisification, often using util.promisify in Node.js or wrapping functions manually. Understanding the evolution from callbacks to async/await helps maintain legacy codebases while adopting cleaner, more maintainable patterns for new projects.
