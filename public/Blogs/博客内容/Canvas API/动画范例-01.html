<article class="专题简介">
  <h1 class="简介标题">
    <span>动画范例<span class="次要">-</span><span class="行内专业名词 等宽">01</span></span
    ><span class="原创">原创</span>
  </h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本">待定</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/Extreme Hunter.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">波浪线</h2>

    <h3 class="分区标题 分区3级标题">动画原理</h3>

    <h3 class="分区标题 分区3级标题">动画效果</h3>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-波浪线-动画" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      class 波浪线动画 {
        constructor() {
          this.canvas = document.getElementById("canvas-波浪线-动画");
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);

          // 波浪线基准参数
          this.waveConfig = {
            amplitude: 40, // 波浪振幅
            frequency: 0.02, // 波浪频率
            speed: 0.15, // 波浪移动速度（加快4倍）
            segments: 200, // 波浪线段数
            baseY: this.canvas.height * 0.3, // 垂直坐标
          };

          // 动画状态
          this.animation = {
            time: 0,
            isPlaying: true,
            lastTime: 0,
          };

          // 绘制模式选择
          this.drawMode = "wave"; // "wave" 或 "points"

          // 单选按钮配置
          this.radioButtons = {
            wave: {
              x: this.canvas.offsetWidth - 180,
              y: 20,
              width: 90,
              height: 35,
              text: "绘制波浪线",
              selected: true,
              hovered: false,
            },
            points: {
              x: this.canvas.offsetWidth - 90,
              y: 20,
              width: 70,
              height: 35,
              text: "绘制点",
              selected: false,
              hovered: false,
            },
          };

          // 随机波峰波谷变化
          this.randomVariations = [];
          this.generateRandomVariations();

          // 绑定点击事件
          this.绑定鼠标事件();

          // 开始动画
          this.animate();
        }

        // 生成随机波峰波谷变化
        generateRandomVariations() {
          this.randomVariations = [];
          for (let i = 0; i < this.waveConfig.segments; i++) {
            // 为每个段生成随机振幅变化
            this.randomVariations.push({
              amplitude: 0.3 + Math.random() * 1.4, // 0.3到1.7倍振幅，更大的变化范围
              phase: Math.random() * Math.PI * 4, // 随机相位，0到4π
              frequency: 0.5 + Math.random() * 1.0, // 0.5到1.5倍频率，更大的频率变化
              noise: Math.random() * 2 - 1, // -1到1的随机噪声
              timeOffset: Math.random() * Math.PI * 2, // 随机时间偏移
            });
          }
        }

        // 动画循环
        animate() {
          if (!this.animation.isPlaying) return;

          // 计算时间增量，确保不同刷新率下速度一致
          const currentTime = performance.now();
          const deltaTime = this.animation.lastTime === 0 ? 0 : currentTime - this.animation.lastTime;
          this.animation.lastTime = currentTime;

          // 基于时间增量更新动画时间
          this.animation.time += this.waveConfig.speed * (deltaTime / 16.67); // 16.67ms = 60fps基准
          this.draw();
          requestAnimationFrame(() => this.animate());
        }

        // 绑定点击事件
        绑定鼠标事件() {
          this.canvas.addEventListener("click", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 检查是否点击了单选按钮
            for (const [key, button] of Object.entries(this.radioButtons)) {
              if (x >= button.x && x <= button.x + button.width && y >= button.y && y <= button.y + button.height) {
                this.selectRadioButton(key);
                break;
              }
            }
          });

          // 添加鼠标悬停效果
          this.canvas.addEventListener("mousemove", (e) => {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 检查鼠标是否悬停在按钮上
            let isHovering = false;
            for (const [key, button] of Object.entries(this.radioButtons)) {
              if (x >= button.x && x <= button.x + button.width && y >= button.y && y <= button.y + button.height) {
                this.canvas.style.cursor = 'url("/Images/Common/鼠标-指向.cur"), pointer';
                isHovering = true;
                button.hovered = true;
              } else {
                button.hovered = false;
              }
            }

            if (!isHovering) {
              this.canvas.style.cursor = 'url("/Images/Common/鼠标-默认.cur"), auto';
            }
          });
        }

        // 选择单选按钮
        selectRadioButton(selectedKey) {
          // 重置所有按钮状态
          for (const key in this.radioButtons) {
            this.radioButtons[key].selected = false;
          }
          // 设置选中状态
          this.radioButtons[selectedKey].selected = true;
          this.drawMode = selectedKey;
        }

        // 绘制波浪线
        draw() {
          // 清空画布
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // 绘制背景网格
          this.drawGrid();

          // 绘制波浪线
          this.drawWave();

          // 绘制单选按钮
          this.drawRadioButtons();

          // 绘制信息
          this.drawInfo();
        }

        // 绘制背景网格
        drawGrid() {
          this.ctx.strokeStyle = "#333";
          this.ctx.lineWidth = 1;

          // 绘制垂直线
          for (let x = 0; x <= this.canvas.width; x += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
          }

          // 绘制水平线
          for (let y = 0; y <= this.canvas.height; y += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
          }
        }

        // 绘制波浪线
        drawWave() {
          this.ctx.strokeStyle = "#4CAF50";
          this.ctx.lineWidth = 3;
          this.ctx.lineCap = "round";

          this.ctx.beginPath();

          // 绘制波浪线
          for (let i = 0; i <= this.waveConfig.segments; i++) {
            const x = (i / this.waveConfig.segments) * this.canvas.width;

            // 计算Y坐标，包含多个正弦波叠加和随机变化
            let y = this.waveConfig.baseY;

            // 主要波浪
            const mainWave = Math.sin(x * this.waveConfig.frequency + this.animation.time) * this.waveConfig.amplitude;

            // 次要波浪（不同频率）
            const secondaryWave1 =
              Math.sin(x * this.waveConfig.frequency * 2.3 + this.animation.time * 1.7) *
              this.waveConfig.amplitude *
              0.4;
            const secondaryWave2 =
              Math.sin(x * this.waveConfig.frequency * 1.7 + this.animation.time * 0.6) *
              this.waveConfig.amplitude *
              0.3;
            const secondaryWave3 =
              Math.sin(x * this.waveConfig.frequency * 3.1 + this.animation.time * 1.2) *
              this.waveConfig.amplitude *
              0.25;

            // 随机变化 - 确保索引在有效范围内
            const index = Math.min(
              Math.floor((i * this.randomVariations.length) / this.waveConfig.segments),
              this.randomVariations.length - 1
            );
            const randomVariation = this.randomVariations[index];

            // 多个随机波浪叠加
            const randomWave1 =
              Math.sin(
                x * this.waveConfig.frequency * randomVariation.frequency + this.animation.time + randomVariation.phase
              ) *
              this.waveConfig.amplitude *
              0.5 *
              randomVariation.amplitude;
            const randomWave2 =
              Math.sin(
                x * this.waveConfig.frequency * randomVariation.frequency * 1.8 +
                  this.animation.time * 0.9 +
                  randomVariation.timeOffset
              ) *
              this.waveConfig.amplitude *
              0.3 *
              randomVariation.amplitude;

            // 添加随机噪声
            const noise = randomVariation.noise * this.waveConfig.amplitude * 0.2;

            // 添加基于时间的随机变化
            const timeBasedRandom = Math.sin(this.animation.time * 0.3 + i * 0.1) * this.waveConfig.amplitude * 0.15;

            // 组合所有波浪和随机因素
            y +=
              mainWave +
              secondaryWave1 +
              secondaryWave2 +
              secondaryWave3 +
              randomWave1 +
              randomWave2 +
              noise +
              timeBasedRandom;

            if (this.drawMode === "wave") {
              if (i === 0) {
                this.ctx.moveTo(x, y);
              } else {
                this.ctx.lineTo(x, y);
              }
            } else {
              this.ctx.beginPath();
              this.ctx.arc(x, y, 2, 0, 2 * Math.PI);
              this.ctx.fill();
            }
          }

          this.ctx.stroke();
        }

        // 绘制单选按钮
        drawRadioButtons() {
          for (const [key, button] of Object.entries(this.radioButtons)) {
            // 绘制文本
            this.ctx.fillStyle = "#fff";
            this.ctx.font = "14px sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";

            // 如果选中，绘制背景矩形
            if (button.selected) {
              this.ctx.fillStyle = "#1C7F20";
              this.ctx.fillRect(button.x, button.y, button.width, button.height);
            } else if (button.hovered) {
              this.ctx.fillStyle = "#1C7F2036";
              this.ctx.fillRect(button.x, button.y, button.width, button.height);
            }

            // 绘制文本
            this.ctx.fillStyle = button.selected ? "#fff" : "#ccc";
            this.ctx.fillText(button.text, button.x + button.width / 2, button.y + button.height / 2);
          }
        }

        // 绘制标题信息
        drawInfo() {
          this.ctx.fillStyle = "#fff";
          this.ctx.font = "16px sans-serif";
          this.ctx.textAlign = "left";
          this.ctx.fillText("波浪线动画", 20, 30);
        }
      }

      new 波浪线动画();
    </script>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">曲线滚动</h2>

    <h3 class="分区标题 分区3级标题">动画原理</h3>

    <h3 class="分区标题 分区3级标题">动画效果</h3>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.25">
      <canvas id="canvas-曲线滚动" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      class 曲线滚动 {
        constructor() {
          this.canvas = document.getElementById("canvas-曲线滚动");
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.cssWidth = this.canvas.offsetWidth;
          this.cssHeight = this.canvas.offsetHeight;
          this.ctx.scale(this.dpr, this.dpr);
          this.显示控制点 = false;

          this.摇摆路径控制点 = {
            P0: { x: 25, y: 150 },
            P1: { x: 150, y: this.cssHeight / 2 + 250 },
            P2: { x: this.cssWidth - 150, y: this.cssHeight / 2 + 250 },
            P3: { x: this.cssWidth - 25, y: 150 },
          };

          // 复选框配置
          this.checkbox = {
            x: 20,
            y: 20,
            width: 20,
            height: 20,
            checked: false,
            text: "绘制路径控制点",
            hovered: false,
          };

          // 拖拽状态
          this.dragging = {
            isDragging: false,
            draggedPoint: null,
            offset: { x: 0, y: 0 },
          };

          // 圆球属性
          this.ball = {
            radius: 15,
            t: 0, // 贝塞尔曲线参数 t (0-1)
            direction: 1, // 1: 正向, -1: 反向
            baseSpeed: 0.0025, // 基础速度（加快5倍）
            currentSpeed: 0.0025,
            position: { x: 0, y: 0 },
            tangent: { x: 0, y: 0 },
            image: null, // 小球图片
            rotation: 0, // 旋转角度
          };

          // 加载小球图片
          this.loadBallImage();

          // 动画状态
          this.animation = {
            isPlaying: true,
            lastTime: 0,
          };

          // 绑定事件
          this.绑定鼠标事件();

          // 动画将在图片加载完成后开始
        }

        // 主绘制函数
        draw() {
          // 清空画布
          this.ctx.clearRect(0, 0, this.cssWidth, this.cssHeight);

          // 绘制背景网格
          this.drawGrid();

          // 绘制摇摆路径
          this.绘制摇摆路径();

          // 绘制圆球
          this.drawBall();

          // 如果复选框选中，绘制控制点
          if (this.checkbox.checked) {
            this.显示控制点 = true;
            this.绘制摇摆路径控制点();
          } else {
            this.显示控制点 = false;
          }

          // 绘制复选框
          this.drawCheckbox();
        }

        // 绘制背景网格
        drawGrid() {
          this.ctx.strokeStyle = "#333";
          this.ctx.lineWidth = 1;

          // 绘制垂直线
          for (let x = 0; x <= this.cssWidth; x += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.cssHeight);
            this.ctx.stroke();
          }

          // 绘制水平线
          for (let y = 0; y <= this.cssHeight; y += 50) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.cssWidth, y);
            this.ctx.stroke();
          }
        }

        绘制摇摆路径() {
          const { P0, P1, P2, P3 } = this.摇摆路径控制点;
          this.ctx.save();
          this.ctx.beginPath();
          this.ctx.moveTo(P0.x, P0.y);
          this.ctx.bezierCurveTo(P1.x, P1.y, P2.x, P2.y, P3.x, P3.y);
          this.ctx.strokeStyle = "#4CAF50";
          this.ctx.lineWidth = 2;
          this.ctx.stroke();
          this.ctx.restore();
        }

        绘制摇摆路径控制点() {
          const { P0, P1, P2, P3 } = this.摇摆路径控制点;

          // 绘制控制点连线
          this.ctx.save();
          this.ctx.strokeStyle = "#666";
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([5, 5]);

          // P0 到 P1 的连线
          this.ctx.beginPath();
          this.ctx.moveTo(P0.x, P0.y);
          this.ctx.lineTo(P1.x, P1.y);
          this.ctx.stroke();

          // P2 到 P3 的连线
          this.ctx.beginPath();
          this.ctx.moveTo(P2.x, P2.y);
          this.ctx.lineTo(P3.x, P3.y);
          this.ctx.stroke();

          this.ctx.restore();

          // 绘制控制点
          const points = [P0, P1, P2, P3];
          const colors = ["#aF2B2B", "#aE5e00", "#055771", "#768E14"];
          const labels = ["P0", "P1", "P2", "P3"];
          const labelOffsets = [
            { x: 0, y: -20 }, // P0: 上方
            { x: 25, y: 0 }, // P1: 右侧
            { x: -25, y: 0 }, // P2: 左侧
            { x: 0, y: -20 }, // P3: 上方
          ];

          points.forEach((point, index) => {
            // 绘制控制点圆圈
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
            this.ctx.fillStyle = colors[index];
            this.ctx.fill();
            this.ctx.strokeStyle = "#fff";
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            this.ctx.restore();

            // 绘制标签（移到控制点外部）
            this.ctx.save();
            this.ctx.fillStyle = "#fff";
            this.ctx.font = "12px 'Google Sans Code', sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.textBaseline = "middle";

            const labelX = point.x + labelOffsets[index].x;
            const labelY = point.y + labelOffsets[index].y;

            // 绘制标签文本
            this.ctx.fillStyle = "#fff";
            this.ctx.fillText(labels[index], labelX, labelY);
            this.ctx.restore();
          });
        }

        // 绘制复选框
        drawCheckbox() {
          const checkbox = this.checkbox;

          // 绘制复选框背景
          this.ctx.save();
          if (checkbox.hovered) {
            this.ctx.fillStyle = "#333";
            this.ctx.fillRect(checkbox.x - 2, checkbox.y - 2, checkbox.width + 4, checkbox.height + 4);
          }

          // 绘制复选框边框
          this.ctx.strokeStyle = checkbox.checked ? "#aaa" : "#666";
          this.ctx.lineWidth = 1;
          this.ctx.strokeRect(checkbox.x, checkbox.y, checkbox.width, checkbox.height);

          // 如果选中，绘制勾选标记
          if (checkbox.checked) {
            this.ctx.strokeStyle = "#4CAF50";
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.moveTo(checkbox.x + 4, checkbox.y + checkbox.height / 2);
            this.ctx.lineTo(checkbox.x + checkbox.width / 2, checkbox.y + checkbox.height - 4);
            this.ctx.lineTo(checkbox.x + checkbox.width - 4, checkbox.y + 4);
            this.ctx.stroke();
          }

          this.ctx.restore();

          // 绘制复选框文本
          this.ctx.save();
          this.ctx.fillStyle = "#fff";
          this.ctx.font = "14px sans-serif";
          this.ctx.textAlign = "left";
          this.ctx.textBaseline = "middle";
          this.ctx.fillText(checkbox.text, checkbox.x + checkbox.width + 8, checkbox.y + checkbox.height / 2);
          this.ctx.restore();
        }

        // 绑定事件
        绑定鼠标事件() {
          this.canvas.addEventListener("mousedown", (e) => this.handleMouseDown(e));
          this.canvas.addEventListener("mousemove", (e) => this.handleMouseMove(e));
          this.canvas.addEventListener("mouseup", (e) => this.handleMouseUp(e));
          this.canvas.addEventListener("mouseleave", (e) => this.handleMouseLeave(e));
        }

        // 处理鼠标按下事件
        handleMouseDown(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          // 检查是否点击了复选框
          if (this.isPointInCheckbox(x, y)) {
            this.checkbox.checked = !this.checkbox.checked;
            this.draw();
            return;
          }

          // 如果复选框选中，检查是否点击了控制点
          if (this.显示控制点) {
            const clickedPoint = this.getClickedControlPoint(x, y);
            if (clickedPoint) {
              this.dragging.isDragging = true;
              this.dragging.draggedPoint = clickedPoint;
              this.dragging.offset.x = x - clickedPoint.x;
              this.dragging.offset.y = y - clickedPoint.y;
              this.canvas.style.cursor = "grabbing";
            }
          }
        }

        // 处理鼠标移动事件
        handleMouseMove(e) {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          // 检查鼠标是否悬停在复选框上
          this.checkbox.hovered = this.isPointInCheckbox(x, y);

          // 如果正在拖拽控制点
          if (this.dragging.isDragging && this.dragging.draggedPoint) {
            this.dragging.draggedPoint.x = x - this.dragging.offset.x;
            this.dragging.draggedPoint.y = y - this.dragging.offset.y;
            this.draw();
            return;
          }

          // 更新鼠标样式
          if (this.显示控制点) {
            const hoveredPoint = this.getClickedControlPoint(x, y);
            if (hoveredPoint) {
              this.canvas.style.cursor = "grab";
            } else if (this.checkbox.hovered) {
              this.canvas.style.cursor = 'url("/Images/Common/鼠标-指向.cur"), pointer';
            } else {
              this.canvas.style.cursor = 'url("/Images/Common/鼠标-默认.cur"), auto';
            }
          } else if (this.checkbox.hovered) {
            this.canvas.style.cursor = 'url("/Images/Common/鼠标-指向.cur"), pointer';
          } else {
            this.canvas.style.cursor = 'url("/Images/Common/鼠标-默认.cur"), auto';
          }

          this.draw();
        }

        // 处理鼠标抬起事件
        handleMouseUp(e) {
          this.dragging.isDragging = false;
          this.dragging.draggedPoint = null;
          this.canvas.style.cursor = 'url("/Images/Common/鼠标-默认.cur"), auto';
        }

        // 处理鼠标离开事件
        handleMouseLeave(e) {
          this.dragging.isDragging = false;
          this.dragging.draggedPoint = null;
          this.checkbox.hovered = false;
          this.canvas.style.cursor = 'url("/Images/Common/鼠标-默认.cur"), auto';
          this.draw();
        }

        // 检查点是否在复选框内
        isPointInCheckbox(x, y) {
          const checkbox = this.checkbox;
          return (
            x >= checkbox.x &&
            x <= checkbox.x + checkbox.width + 8 + this.ctx.measureText(checkbox.text).width &&
            y >= checkbox.y &&
            y <= checkbox.y + checkbox.height
          );
        }

        // 获取点击的控制点
        getClickedControlPoint(x, y) {
          const points = [
            this.摇摆路径控制点.P0,
            this.摇摆路径控制点.P1,
            this.摇摆路径控制点.P2,
            this.摇摆路径控制点.P3,
          ];
          const radius = 8;

          for (let point of points) {
            const distance = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
            if (distance <= radius) {
              return point;
            }
          }
          return null;
        }

        // 计算贝塞尔曲线上的点
        getBezierPoint(t) {
          const { P0, P1, P2, P3 } = this.摇摆路径控制点;
          const u = 1 - t;
          const tt = t * t;
          const uu = u * u;
          const uuu = uu * u;
          const ttt = tt * t;

          const x = uuu * P0.x + 3 * uu * t * P1.x + 3 * u * tt * P2.x + ttt * P3.x;
          const y = uuu * P0.y + 3 * uu * t * P1.y + 3 * u * tt * P2.y + ttt * P3.y;

          return { x, y };
        }

        // 计算贝塞尔曲线的切线向量
        getBezierTangent(t) {
          const { P0, P1, P2, P3 } = this.摇摆路径控制点;
          const u = 1 - t;
          const tt = t * t;
          const uu = u * u;

          const x = -3 * uu * P0.x + 3 * (uu - 2 * u * t) * P1.x + 3 * (2 * u * t - tt) * P2.x + 3 * tt * P3.x;
          const y = -3 * uu * P0.y + 3 * (uu - 2 * u * t) * P1.y + 3 * (2 * u * t - tt) * P2.y + 3 * tt * P3.y;

          // 归一化切线向量
          const length = Math.sqrt(x * x + y * y);
          return { x: x / length, y: y / length };
        }

        // 计算贝塞尔曲线的曲率（用于调整速度）
        getBezierCurvature(t) {
          const { P0, P1, P2, P3 } = this.摇摆路径控制点;
          const u = 1 - t;

          // 一阶导数
          const dx =
            -3 * u * u * P0.x + 3 * (u * u - 2 * u * t) * P1.x + 3 * (2 * u * t - t * t) * P2.x + 3 * t * t * P3.x;
          const dy =
            -3 * u * u * P0.y + 3 * (u * u - 2 * u * t) * P1.y + 3 * (2 * u * t - t * t) * P2.y + 3 * t * t * P3.y;

          // 二阶导数
          const ddx = 6 * u * P0.x + 3 * (-2 * u + 2 * t) * P1.x + 3 * (2 * u - 2 * t) * P2.x + 6 * t * P3.x;
          const ddy = 6 * u * P0.y + 3 * (-2 * u + 2 * t) * P1.y + 3 * (2 * u - 2 * t) * P2.y + 6 * t * P3.y;

          // 曲率公式: |x'y'' - y'x''| / (x'^2 + y'^2)^(3/2)
          const numerator = Math.abs(dx * ddy - dy * ddx);
          const denominator = Math.pow(dx * dx + dy * dy, 1.5);

          return denominator > 0 ? numerator / denominator : 0;
        }

        // 更新圆球位置
        updateBall() {
          // 计算时间增量，确保不同刷新率下速度一致
          const currentTime = performance.now();
          const deltaTime = this.animation.lastTime === 0 ? 0 : currentTime - this.animation.lastTime;
          this.animation.lastTime = currentTime;

          // 基于时间增量更新 t 值
          this.ball.t += this.ball.currentSpeed * this.ball.direction * (deltaTime / 16.67); // 16.67ms = 60fps基准

          // 检查边界，实现往返循环
          if (this.ball.t >= 1) {
            this.ball.t = 1;
            this.ball.direction = -1;
          } else if (this.ball.t <= 0) {
            this.ball.t = 0;
            this.ball.direction = 1;
          }

          // 计算当前位置
          this.ball.position = this.getBezierPoint(this.ball.t);

          // 计算切线方向
          this.ball.tangent = this.getBezierTangent(this.ball.t);

          // 根据高度调整速度（重力效果）
          // 找到曲线的最高点和最低点
          const { P0, P1, P2, P3 } = this.摇摆路径控制点;
          const maxY = Math.max(P0.y, P1.y, P2.y, P3.y);
          const minY = Math.min(P0.y, P1.y, P2.y, P3.y);

          // 当前高度相对于最低点的比例
          const heightRatio = (this.ball.position.y - minY) / (maxY - minY);

          // 速度计算：最低点最快，最高点最慢
          // 使用非常剧烈的速度变化
          const speedMultiplier = 0.1 + heightRatio * 7; // 0.1 到 5.0 之间，变化非常剧烈
          this.ball.currentSpeed = this.ball.baseSpeed * speedMultiplier;

          // 更新旋转角度（根据高度调整旋转速度）
          // 旋转速度计算：最低点最快，最高点最慢
          const baseRotationSpeed = 0.3;
          const rotationSpeedMultiplier = 0.1 + heightRatio * 2.9; // 0.1 到 3.0 之间
          const rotationSpeed = baseRotationSpeed * rotationSpeedMultiplier;
          
          this.ball.rotation += rotationSpeed * this.ball.direction * (deltaTime / 16.67); // 基于时间增量
        }

        // 加载小球图片
        loadBallImage() {
          this.ball.image = new Image();
          this.ball.image.src = "/Images/Blogs/Canvas API/动画范例-01/ball.webp";
          this.ball.image.onload = () => {
            // 图片加载完成后开始动画
            this.animate();
          };
        }

        // 绘制圆球
        drawBall() {
          const { position, radius, tangent, image, rotation } = this.ball;

          // 计算圆球中心位置（球在曲线的上方滚动）
          const centerX = position.x;
          const centerY = position.y - radius;

          // 如果图片已加载，使用图片绘制
          if (image && image.complete) {
            // 绘制圆球主体（带旋转，不透明度100%）
            this.ctx.save();
            // 移动到球心位置
            this.ctx.translate(centerX, centerY);
            // 旋转
            this.ctx.rotate(rotation);
            // 绘制图片
            this.ctx.globalAlpha = 1.0; // 确保不透明度为100%
            this.ctx.drawImage(image, -radius, -radius, radius * 2, radius * 2);
            this.ctx.restore();
          } else {
            // 图片未加载时，绘制默认圆球（带旋转）
            this.ctx.save();
            // 移动到球心位置
            this.ctx.translate(centerX, centerY);
            // 旋转
            this.ctx.rotate(rotation);

            this.ctx.beginPath();
            this.ctx.arc(0, 0, radius, 0, 2 * Math.PI);
            this.ctx.fillStyle = "#FFD700";
            this.ctx.fill();
            this.ctx.strokeStyle = "#FF6B35";
            this.ctx.lineWidth = 2;
            this.ctx.stroke();

            // 绘制旋转标记线（显示快速旋转效果）
            this.ctx.strokeStyle = "#FF6B35";
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(radius * 0.7, 0);
            this.ctx.stroke();

            this.ctx.restore();
          }
        }

        // 动画循环
        animate() {
          if (!this.animation.isPlaying) return;

          // 更新圆球位置
          this.updateBall();

          // 绘制
          this.draw();

          // 继续动画
          requestAnimationFrame(() => this.animate());
        }
      }

      new 曲线滚动();
    </script>
  </article>
</div>
