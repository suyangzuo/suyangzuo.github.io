Keyboard shortcuts improve productivity, but OS-specific differences (e.g., Cmd on macOS vs. Ctrl on Windows/Linux) can confuse users. A unified shortcut scheme for Electron apps balances consistency with OS conventions, ensuring shortcuts feel natural on every platform while working the same way. Electron's accelerator property and OS detection tools make this achievable.​
Start with core shortcut patterns that map to OS conventions. Use CommandOrControl (abbreviated as CmdOrCtrl in Electron) for common actions - this automatically maps to Cmd on macOS and Ctrl on Windows/Linux. For example, a "Copy" shortcut becomes CmdOrCtrl+C, "Paste" becomes CmdOrCtrl+V, and "Undo" becomes CmdOrCtrl+Z. This maintains familiarity for users while keeping your code simple - no need for separate logic for each OS.​
Handle OS-specific shortcuts that don't map directly. Some shortcuts are unique to a platform and can't be unified. For example, macOS uses Cmd+Q to quit apps, while Windows uses Alt+F4. Instead of forcing a unified shortcut, adapt to these conventions using process.platform in the main process. For the quit action, add a conditional accelerator: const quitAccelerator = process.platform === 'darwin' ? 'Cmd+Q' : 'Alt+F4'; then use it in the menu template: { label: 'Quit', accelerator: quitAccelerator, click: () => app.quit() }. For macOS-specific shortcuts like Cmd+W (close window), add them conditionally - Windows/Linux users can use Ctrl+W (a common web convention) instead.​
Unify app-specific shortcuts with clear documentation. For custom actions (e.g., "New Note" in a note app), use CmdOrCtrl+N across all platforms - this is a common convention that users will recognize. Avoid platform-specific custom shortcuts unless necessary (e.g., a macOS-only feature). Document all shortcuts in an accessible place (e.g., a "Keyboard Shortcuts" section in the app's help menu)  - list both the platform-specific and unified versions (e.g., "New Note: Cmd+N (macOS) / Ctrl+N (Windows/Linux)").​
Test shortcuts on all target OSes to ensure consistency. On macOS, verify that Cmd-based shortcuts work with the app menu and don't conflict with system shortcuts (e.g., Cmd+Space for Spotlight). On Windows, check that Ctrl-based shortcuts don't clash with OS actions (e.g., Ctrl+S for Save vs. Windows' Ctrl+S for nothing). On Linux, test across desktop environments (GNOME, KDE)  - some DEs have default shortcuts that may conflict (e.g., Ctrl+Alt+T for terminal). Use Electron's globalShortcut.isRegistered() method to check for conflicts: if (globalShortcut.isRegistered('CmdOrCtrl+N')) { console.warn('New Note shortcut is already in use!'); }.​
Let users customize shortcuts for flexibility. Some users prefer different shortcuts (e.g., a developer who uses Vim-style keys), so add a "Customize Shortcuts" setting. Store custom shortcuts in a local database (e.g., SQLite)  - when the app starts, load the custom shortcuts and register them with globalShortcut.register() (for global shortcuts) or update the menu template (for app-specific shortcuts). Ensure custom shortcuts respect OS conventions (e.g., don't let users assign Cmd+Q to a non-quit action on macOS) to avoid confusion.​
Best practices: Keep shortcuts simple and memorable - avoid complex combinations (e.g., Ctrl+Shift+Alt+N) that are hard to press. Use mnemonics where possible (e.g., "N" for New, "S" for Save) to help users remember. For global shortcuts (active when the app is not focused), limit them to critical actions (e.g., a screen recorder's "Start Recording" shortcut)  - too many global shortcuts cause conflicts with other apps.​
In short, a unified shortcut scheme for Electron apps balances consistency and OS conventions. By using CmdOrCtrl, adapting to platform-specific actions, testing across OSes, and letting users customize, you can create a shortcut system that's intuitive for everyone.
