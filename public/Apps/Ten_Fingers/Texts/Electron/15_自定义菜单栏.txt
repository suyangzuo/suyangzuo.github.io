Custom menus - both top-level application menus and right-click context menus - are key to making Electron apps intuitive. They let users access core features (like File, Edit, Help) quickly, aligning with desktop app conventions. Electron's Menu module simplifies creating and managing both menu types, with support for OS-specific adaptations.​
For top-level application menus, start by defining a menu template in the main process. The template is an array of objects, each representing a menu item (e.g., "File" or "Edit"). For example, a basic "File" menu with "New" and "Quit" items: const menuTemplate = [{ label: 'File', submenu: [{ label: 'New Note', accelerator: 'CommandOrControl+N', click: () => createNewNote() }, { type: 'separator' }, { label: 'Quit', accelerator: 'CommandOrControl+Q', click: () => app.quit() }] }, { label: 'Edit', submenu: [{ role: 'undo' }, { role: 'redo' }, { type: 'separator' }, { role: 'cut' }, { role: 'copy' }, { role: 'paste' }] }];. Use role for common actions (like undo/redo) - Electron automatically maps these to OS-specific behaviors (e.g., "Quit" becomes "Quit" on macOS and "Exit" on Windows) and adds default shortcuts.​
Build and set the menu with Menu.buildFromTemplate(menuTemplate) and Menu.setApplicationMenu(menu). On macOS, the first menu item (usually the app name) is auto-added by the OS - avoid including it in your template. For Windows and Linux, the menu appears in the app window's title bar. To hide the menu entirely (e.g., for a kiosk app), set Menu.setApplicationMenu(null).​
Context menus (right-click menus) are created in the renderer process and triggered by user clicks. In the renderer, listen for the contextmenu event on a UI element (e.g., a note editor): document.getElementById('note-editor').addEventListener('contextmenu', (e) => { e.preventDefault(); // Prevent default OS menu showContextMenu(); });. The showContextMenu function uses IPC to send a request to the main process, which creates and shows the menu: ipcRenderer.send('show-context-menu'); in the renderer, and in the main process: ipcMain.on('show-context-menu', (event) => { const contextMenu = Menu.buildFromTemplate([{ label: 'Cut', role: 'cut' }, { label: 'Copy', role: 'copy' }, { label: 'Paste', role: 'paste' }, { type: 'separator' }, { label: 'Select All', role: 'selectAll' }]); contextMenu.popup({ window: BrowserWindow.fromWebContents(event.sender) }); });. The popup method shows the menu at the cursor position.​
Best practices: Adapt menus to OS conventions - e.g., macOS uses "Services" in the app menu, while Windows doesn't. Use process.platform to conditionally add or remove menu items (e.g., if (process.platform === 'darwin') { menuTemplate.unshift({ label: app.getName(), submenu: [{ role: 'about' }, { type: 'separator' }, { role: 'quit' }] }); }). For context menus, tailor items to the element - e.g., a "Delete" item for notes but not for read-only text. Test menus on all target OSes to ensure shortcuts work and labels are consistent.​
In short, custom menus enhance Electron app usability. By using the Menu module to create top-level and context menus, and adapting to OS conventions, you can build apps that feel familiar to users.
