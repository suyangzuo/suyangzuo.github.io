Every JavaScript object is linked to another object called its prototype. When you attempt to access a property, the engine first searches the object itself; if the property is not found, it continues searching up the prototype chain until it reaches null. This mechanism is the foundation of inheritance in JavaScript. Functions have a prototype property that becomes the prototype of instances created with the new keyword. You can manually set prototypes using Object.create or modify them with Object.setPrototypeOf, though the latter is slow and should be used sparingly. ES6 classes provide syntactic sugar over this prototype system: class Child extends Parent copies Parent.prototype into Child.prototype's internal prototype, achieving the same effect with cleaner syntax. Inheritance patterns include prototypal, parasitic, and mixin. Be cautious with deep prototype chains, as property lookup time increases with depth. Also, mutating a shared prototype affects all instances, which can be powerful but dangerous. Modern alternatives like factory functions with closures or composition via Object.assign can often replace classical inheritance, leading to flatter and more flexible architectures. Understanding the prototype chain demystifies how methods are shared, why hasOwnProperty is necessary when iterating with for...in, and how instanceof works under the hood.
