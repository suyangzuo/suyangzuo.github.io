JavaScript defines seven primitive data types: undefined, null, boolean, number, bigint, string, and symbol. These types are immutable and are stored directly in memory when assigned to variables. When you copy a primitive, a new independent value is created, so modifying one variable does not affect the other. Everything else in the language - including objects, arrays, dates, regular expressions, and functions - is a reference type. Reference types are mutable, and variables do not hold the actual data but instead hold a pointer to a location in memory where the data resides. Copying a reference type merely duplicates the pointer, so both variables point to the same underlying object. This distinction explains why comparing two objects with the equality operator === returns false even when their contents are identical: the comparison checks whether the references point to the same memory address, not whether the structures are equivalent. To test structural equality, you must compare each property recursively, often with helper functions such as JSON.stringify or dedicated libraries like Lodash's isEqual. Cloning objects requires special care: shallow copies duplicate only the first level of properties, while deep copies recreate the entire nested structure. Techniques include the spread operator {...obj}, Object.assign, and structuredClone, or custom recursive functions for complex graphs. Understanding the difference between primitives and references is essential for predicting assignment behavior, avoiding accidental mutations, and debugging seemingly inexplicable side effects in large codebases.
