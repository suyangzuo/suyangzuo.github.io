Automating repetitive tasks - like daily backups, log cleaning, or system updates - saves time and reduces human error on Linux systems. The primary tool for this is Cron, a built-in task scheduler that runs commands at predefined times (e.g., every hour, every Sunday, or 3 AM on the 1st of each month). Understanding how to set up and manage Cron jobs lets you streamline routine maintenance and ensure tasks run consistently. This article covers Cron basics, job syntax, and common use cases.​
First, accessing the Cron table (the list of scheduled tasks for a user) uses the crontab command. To view your current Cron jobs, run crontab -l - this lists all tasks you've scheduled. To edit the Cron table (add, modify, or delete jobs), use crontab -e - this opens the table in your default text editor (usually Nano or Vim). If it's your first time using crontab -e, you may be prompted to choose an editor; select Nano for simplicity (it has on-screen shortcuts like Ctrl+O to save).​
Cron job syntax follows a strict format: five time fields (minute, hour, day of month, month, day of week) followed by the command to run. The fields are separated by spaces, and each accepts specific values or wildcards:​
Minute (0-59): 0 means the top of the hour, */15 means every 15 minutes.​
Hour (0-23): 2 means 2 AM, 14 means 2 PM.​
Day of month (1-31): 1 means the 1st of the month, */7 means every 7 days.​
Month (1-12 or Jan-Dec): 1 or Jan means January.​
Day of week (0-6 or Sun-Sat): 0 or Sun means Sunday, 6 or Sat means Saturday.​
A wildcard (*) in a field means "every" (e.g., * in the minute field means every minute). For example, a Cron job like 0 2 * * Sun /usr/bin/rsync -av ~/ /mnt/backup/ runs the rsync backup command at 0 minutes, 2 hours (2 AM), every day, every month, and Sunday (i.e., every Sunday at 2 AM).​
To ensure Cron jobs run correctly, always use absolute paths for commands and files - Cron uses a minimal environment, so relative paths (like ./script.sh) may not work. For example, use /home/user/clean-logs.sh instead of clean-logs.sh, and /usr/bin/date instead of date (you can find the absolute path of a command with which command, e.g., which rsync returns /usr/bin/rsync).​
Logging Cron job output helps troubleshoot failed tasks. By default, Cron sends output (stdout and stderr) to the user's email (configured on the system), but you can redirect output to a log file instead. For example, 0 2 * * Sun /usr/bin/rsync -av ~/ /mnt/backup/ >> /var/log/backup.log 2>&1 appends (>>) both standard output (stdout) and standard error (stderr, via 2>&1) to /var/log/backup.log - this lets you check if the backup succeeded or failed by reading the log.​
Managing Cron jobs for other users requires sudo privileges. To view the Cron table of the root user (system-wide tasks), run sudo crontab -u root -l. To edit root's Cron jobs (e.g., for system-wide backups), use sudo crontab -u root -e - this is useful for tasks that need administrative access (like cleaning system logs in /var/log/).​
Common Cron use cases include:​
Daily log rotation: 0 1 * * * /usr/sbin/logrotate /etc/logrotate.conf (runs logrotate at 1 AM daily).​
Weekly system updates: 0 3 * * Sun sudo apt upgrade -y >> /var/log/weekly-updates.log 2>&1 (updates packages at 3 AM Sunday, auto-accepts prompts with -y).​
Hourly disk space check: 0 * * * * /usr/bin/df -h >> /var/log/disk-space.log (logs disk usage every hour).​
In short, Cron is a powerful tool for automating Linux tasks. By mastering its syntax, using absolute paths, and logging output, you can set up reliable, hands-free maintenance - freeing up time for more important work.
