Linux systems generate detailed logs that record almost every activity - from system boot, user logins, and service startups to errors and security events. These logs are critical for troubleshooting issues (like a failed service or unexpected shutdown), monitoring system health, and investigating security incidents. Most Linux distributions store logs in the /var/log/ directory, and use tools like journalctl (for systemd-based systems) and grep to view and filter log data. This article covers how to access key logs, use essential tools, and extract useful information.​
The /var/log/ directory contains several core log files. syslog (or syslog.1 for older logs) stores general system messages, including service status updates and non-critical errors. auth.log (Debian/Ubuntu) or secure (RHEL/Fedora) logs authentication events - like user logins (via SSH or local), sudo usage, and password changes. This is vital for security checks: if you notice unknown IPs logging in via SSH, auth.log will show the timestamps and IP addresses. kern.log records kernel-related events, such as hardware detection, driver issues, or disk errors - useful for troubleshooting hardware problems like a failing hard drive.​
For systemd-based distributions (most modern Linux), the journalctl command is the primary tool for accessing logs. Unlike traditional log files (which can be split or rotated), journalctl pulls logs from a centralized binary database, making it easier to filter by time, service, or priority. To view all recent logs, run journalctl - it will display logs in reverse chronological order (newest last), and you can use arrow keys to scroll, q to quit. To show only the most recent 100 lines (to avoid long outputs), use journalctl -n 100.​
Filtering logs by service is one of the most common use cases. To view logs for a specific service (like Nginx or SSH), use journalctl -u servicename - e.g., journalctl -u nginx shows all logs related to the Nginx web server. Adding -f (follow) keeps the log open and displays new entries in real time: journalctl -u sshd -f is ideal for monitoring SSH logins as they happen. Filtering by time is also useful: journalctl --since "1 hour ago" shows logs from the last hour, and journalctl --since "2024-05-01" --until "2024-05-02" displays logs from a specific date range.​
For traditional log files (like /var/log/auth.log), the cat, tail, and grep commands are essential. cat /var/log/auth.log prints the entire log file (not recommended for large files), while tail -f /var/log/auth.log shows the last 10 lines and follows new entries - great for real-time monitoring. grep filters logs for specific keywords: grep "sshd" /var/log/auth.log finds all lines mentioning SSH (sshd is the SSH service name), and grep "Failed password" /var/log/auth.log highlights failed login attempts - helping you spot brute-force attacks.​
Log rotation is a background process that prevents logs from growing too large and filling the disk. Tools like logrotate automatically compress old logs, rename them (e.g., syslog becomes syslog.1, then syslog.2.gz), and delete the oldest logs after a set period. You can check the log rotation configuration for a service in /etc/logrotate.d/ - for example, /etc/logrotate.d/nginx defines how Nginx logs are rotated (usually daily, keeping 7 days of old logs).​
Common log management scenarios include troubleshooting a failed service (check journalctl -u servicename for error messages), investigating a security breach (search auth.log for unusual logins), or diagnosing a boot issue (use journalctl -b to view logs from the current boot). When analyzing logs, look for keywords like ERROR, FAIL, or CRITICAL - these indicate issues that need attention.​
In short, Linux logs are a treasure trove of system information. By mastering tools like journalctl, grep, and tail, and knowing where to find key log files, you can troubleshoot problems quickly, monitor system health, and keep your Linux system secure.
