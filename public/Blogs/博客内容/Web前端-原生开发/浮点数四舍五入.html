<article class="专题简介">
  <h1 class="简介标题">浮点数四舍五入<span class="原创">原创</span></h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本"
          ><span class="日期文本-数字 日期文本-年">2025</span>年<span class="日期文本-数字 日期文本-月">8</span>月<span
            class="日期文本-数字 日期文本-日"
            >21</span
          >日</span
        >
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">浮点数精确度问题</h2>

    <h3 class="分区标题 分区3级标题">精度误差不一致</h3>
    <p class="分区普通文本">
      计算机基于自身特性，是无法表示自然界所有的小数的。比如：圆周率，我们都知道圆周率是一个无穷不循环小数，计算机是无法<span
        class="行内专业名词 等宽"
        >100%</span
      >精确表示的，只能<span class="行内专业名词">尽量</span>精确。
    </p>
    <pre>
      <code class="lang-js">
        console.log(Math.PI);
      </code>
    </pre>
    <figure class="截图容器">
      <img src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/Math.PI.png" alt="Math.PI" />
    </figure>
    <p class="分区普通文本">
      即便是<span class="行内专业名词">JavaScript</span>标准内置对象<span class="行内代码">Math.PI</span
      >，也不过精确到小数点后<span class="行内专业名词 等宽">15</span>位。因此，我们使用浮点数时，常见的问题往往是：
    </p>
    <ul class="分区列表">
      <li class="分区列表项">
        <span> 精确到小数点后几位？ </span>
      </li>
      <li class="分区列表项">
        <span>
          用什么方法精确？<span class="附加说明">通常有<span class="行内专业名词 等宽">3</span>种方法</span></span
        >
        <ul class="分区列表" style="margin-bottom: 0">
          <li class="分区列表项">
            <span>向上取整</span>
          </li>
          <li class="分区列表项">
            <span>向下取整</span>
          </li>
          <li class="分区列表项">
            <span>四舍五入</span>
          </li>
        </ul>
      </li>
    </ul>
    <p class="分区普通文本">
      浮点数的计算精确度问题，大部分就出在这个<span class="行内专业名词">四舍五入</span>上。让我们用<span
        class="行内专业名词 等宽"
        >1.65</span
      >和<span class="行内专业名词 等宽">4.65</span>两个浮点数来举例说明，将它们精确到小数点后<span
        class="行内专业名词 等宽"
        >20</span
      >位：
    </p>
    <pre>
      <code class="lang-js">
        console.log(1.65.toPrecision(20));  // 获取 1.65 精确到小数点后20位的表示
        console.log(4.65.toPrecision(20));  // 获取 4.65 精确到小数点后20位的表示
      </code>
    </pre>
    <figure class="截图容器">
      <img src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/toPrecision(20).png" alt="toPrecision(20)" />
    </figure>
    <p class="分区普通文本">
      发现问题了吗？精确到小数点后<span class="行内专业名词 等宽">20</span>位，一个结果比<span class="行内专业名词 等宽"
        >1.65</span
      ><span class="强调">小</span>，一个结果比<span class="行内专业名词 等宽">4.65</span
      ><span class="强调">大</span>，假设对这两个浮点数进行<span class="专业名词"
        >四舍五入，保留<span class="行内专业名词 等宽">1</span>位小数</span
      >操作，结果如下：
    </p>
    <ul class="分区列表" style="margin-bottom: 0">
      <li class="分区列表项">
        <span class="行内专业名词 等宽">1.64999999999999999112</span>，<span class="专业名词"
          >四舍五入，小数点保留<span class="行内专业名词 等宽">1</span>位</span
        >：<span class="行内专业名词 等宽">1.6</span>
      </li>
      <li class="分区列表项">
        <span class="行内专业名词 等宽">4.65000000000000011102</span>，<span class="专业名词"
          >四舍五入，小数点保留<span class="行内专业名词 等宽">1</span>位</span
        >：<span class="行内专业名词 等宽">4.7</span>
      </li>
    </ul>
    <p class="分区普通文本">
      简而言之，浮点数在电脑内部的精确值，<span class="强调"
        >有的时候比显示的值大，有的时候比显示的值小，导致四舍五入的结果时对时错</span
      >，为什么会造成这种现象呢？这就要从浮点数在电脑内部的二进制表示说起了。
    </p>

    <h3 class="分区标题 分区3级标题">二进制截断</h3>
    <p class="分区普通文本">
      让我们使用<span class="行内代码">toString(2)</span>将数字转换成<span class="行内专业名词">二进制</span>字符串：
    </p>
    <pre>
      <code class="lang-js">
        console.log(1.65.toString(2));  // 将 1.65 转换成二进制字符串
        console.log(4.65.toString(2));  // 将 4.65 转换成二进制字符串
      </code>
    </pre>
    <figure class="截图容器">
      <img src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/转换为二进制.png" alt="转换为二进制" />
    </figure>
    <p class="分区普通文本">
      <span class="行内专业名词 等宽">1.65</span>和<span class="行内专业名词 等宽">4.65</span
      >转换为二进制，都会变成无限位，而计算机只能存储有限位，因此，计算机会在某个位进行<span class="行内专业名词"
        >截断</span
      >操作。
    </p>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-二进制截断" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">截断时，会看<span class="强调">截断处后一位</span>：</p>
    <ul class="分区列表" style="margin-bottom: 0">
      <li class="分区列表项">
        <span>
          如果是<span class="行内专业名词 等宽">0</span>，则全部<span class="强调">舍弃</span
          >，因此截断后的结果比原数字<span class="强调">小</span>；
        </span>
      </li>
      <li class="分区列表项">
        <span>
          如果是<span class="行内专业名词 等宽">1</span>，则<span class="强调">进一位</span
          >，因此截断后的结果比原数字<span class="强调">大</span>；
        </span>
      </li>
    </ul>
    <p class="分区普通文本">
      正是这种二进制截断机制，导致浮点数进行四舍五入时，有时明明应该<span class="行内专业名词">入</span>，却变成了<span
        class="行内专业名词"
        >舍</span
      >。
    </p>
    <script>
      class 二进制截断 {
        constructor() {
          this.canvas = document.getElementById("canvas-二进制截断");
          this.ctx = this.canvas.getContext("2d");
          this.dpr = window.devicePixelRatio || 1;
          this.canvas.width = this.canvas.offsetWidth * this.dpr;
          this.canvas.height = this.canvas.offsetHeight * this.dpr;
          this.ctx.scale(this.dpr, this.dpr);
          this.画布中心 = {
            x: this.canvas.offsetWidth / 2,
            y: this.canvas.offsetHeight / 2,
          };

          this.数字组 = [
            {
              数字: 1.65,
              二进制: (1.65).toString(2),
            },
            {
              数字: 4.65,
              二进制: (4.65).toString(2),
            },
          ];

          this.绘制();
        }

        设置字体() {
          this.ctx.font = "18px 'Google Sans Code', 'Consolas', sans-serif";
          this.ctx.fillStyle = "silver";
          this.ctx.textBaseline = "top";
        }

        绘制165() {
          this.ctx.save();
          this.设置字体();
          const 全文本测量宽度 = this.ctx.measureText(this.数字组[0].二进制).width;
          const 单字符宽度 = 全文本测量宽度 / this.数字组[0].二进制.length;
          const 文本坐标 = {
            x: 25,
            y: this.画布中心.y - 75,
          };

          for (let i = 4; i < this.数字组[0].二进制.length; i += 1) {
            const 索引奇偶 = Math.floor((i - 4) / 4) % 2;
            this.ctx.fillStyle = 索引奇偶 === 0 ? "#740" : "darkgreen";
            this.ctx.fillRect(文本坐标.x + i * 单字符宽度, 文本坐标.y - 2, 单字符宽度, 20);
          }

          this.ctx.font = "20px 'Google Sans Code', 'Consolas', sans-serif";
          this.ctx.fillStyle = "lightcyan";
          this.ctx.fillText("1.65 二进制截断", 文本坐标.x, 文本坐标.y - 65);

          this.设置字体();
          this.ctx.fillText(this.数字组[0].二进制, 文本坐标.x, 文本坐标.y);
          this.ctx.fillStyle = "#f346";
          this.ctx.fillRect(文本坐标.x + 全文本测量宽度, 文本坐标.y - 27, 单字符宽度, 20);
          this.ctx.fillStyle = "gray";
          this.ctx.fillText(`${this.数字组[0].二进制}00110011001 ……`, 文本坐标.x, 文本坐标.y - 25);
          this.ctx.restore();
        }

        绘制465() {
          this.ctx.save();
          this.设置字体();
          const 全文本测量宽度 = this.ctx.measureText(this.数字组[1].二进制).width;
          const 单字符宽度 = 全文本测量宽度 / this.数字组[1].二进制.length;
          const 文本坐标 = {
            x: 25,
            y: this.画布中心.y + 75,
          };

          for (let i = 6; i < this.数字组[1].二进制.length; i += 1) {
            const 索引奇偶 = Math.floor((i - 6) / 4) % 2;
            this.ctx.fillStyle = 索引奇偶 === 0 ? "#740" : "darkgreen";
            this.ctx.fillRect(文本坐标.x + i * 单字符宽度, 文本坐标.y - 2, 单字符宽度, 20);
          }

          this.ctx.font = "20px 'Google Sans Code', 'Consolas', sans-serif";
          this.ctx.fillStyle = "lightcyan";
          this.ctx.fillText("4.65 二进制截断", 文本坐标.x, 文本坐标.y - 65);

          this.设置字体();
          this.ctx.fillText(this.数字组[1].二进制, 文本坐标.x, 文本坐标.y);
          this.ctx.fillStyle = "#f346";
          this.ctx.fillRect(文本坐标.x + 全文本测量宽度, 文本坐标.y - 27, 单字符宽度, 20);
          this.ctx.fillStyle = "gray";
          this.ctx.fillText(`${this.数字组[1].二进制.slice(0, -1)}01100110011001 ……`, 文本坐标.x, 文本坐标.y - 25);
          this.ctx.restore();
        }

        绘制() {
          this.绘制165();
          this.绘制465();
          this.绘制截断线();
        }

        绘制截断线() {
          this.ctx.save();
          this.设置字体();
          const 全文本测量宽度 = this.ctx.measureText(this.数字组[1].二进制).width;
          const 截断线起点 = {
            x: 25 + 全文本测量宽度,
            y: this.画布中心.y - 150,
          };

          this.ctx.moveTo(截断线起点.x, 截断线起点.y);
          this.ctx.lineTo(截断线起点.x, this.画布中心.y + 150);
          this.ctx.strokeStyle = "#4af7";
          this.ctx.lineWidth = 1.5;
          this.ctx.stroke();
          this.ctx.restore();
        }
      }

      new 二进制截断();
    </script>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">四舍五入</h2>

    <h3 class="分区标题 分区3级标题"><span class="行内代码">toFixed()</span><span class="附加说明">慎用</span></h3>
    <p class="分区普通文本">
      我一开始也喜欢用<span class="行内代码">toFixed()</span
      >进行四舍五入，因为写起来特别方便，但多次踩坑后，我发现使用这个函数真的要慎之又慎。先来看看<a
        class="超链接"
        href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed"
        target="_blank"
        >MDN</a
      >对<span class="行内代码">toFixed()</span>的描述：
    </p>
    <figure class="截图容器">
      <img src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/toFixed().png" alt="toFixed()" />
    </figure>
    <p class="分区普通文本">
      从描述上看似乎没啥问题，<span class="行内代码">toFixed()</span>确实可以用来做四舍五入，然而，它的四舍五入是<span
        class="强调"
        >不准确</span
      >的。
    </p>
    <pre>
      <code class="lang-js">
        console.log(1.65.toFixed(1));  // 四舍五入"理应"为"1.7"
        console.log(4.65.toFixed(1));  // 四舍五入"理应"为"4.7"
      </code>
    </pre>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/不同小数tofixed()结果不同.png"
        alt="不同小数tofixed()结果不同"
      />
    </figure>
    <p class="分区普通文本">
      奇怪，<span class="行内专业名词 等宽">1.65</span>四舍五入应该是<span class="行内专业名词 等宽">1.7</span
      >，结果却变成<span class="行内专业名词 等宽">1.6</span>，相信看完前面章节的你，应该已经明白怎么回事了。
    </p>
    <p class="分区普通文本">
      不推荐使用<span class="行内代码">toFixed()</span>还有另一个原因，就是它返回的是<span class="强调">字符串</span
      >，不是数字：
    </p>
    <figure class="截图容器">
      <img src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/toFixed()-语法.png" alt="toFixed()-语法" />
    </figure>
    <p class="分区普通文本">
      如果<span class="行内代码">toFixed()</span>的返回值需要继续参与运算，就得再次手动转换为数字，非常麻烦。
    </p>

    <h3 class="分区标题 分区3级标题"><span class="行内代码">Math.round()</span><span class="附加说明">推荐</span></h3>
    <p class="分区普通文本">
      为了解决<span class="行内代码">toFixed()</span>的两大痛点：<span class="强调">转换结果不准确</span>、<span
        class="强调"
        >转换结果是字符串</span
      >，我们可以用<span class="行内代码">Math.round()</span>：
    </p>
    <figure class="截图容器">
      <img src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/Math.round()-语法.png" alt="Math.round()-语法" />
    </figure>
    <p class="分区普通文本">
      <span class="行内代码">Math.round()</span>返回的是一个整数，我们怎么才能得到浮点数呢？答案是：<span class="强调"
        >先乘后除</span
      >。
    </p>
    <pre>
      <code class="lang-js">
        console.log(Math.round(1.65 * 10) / 10);  // 想获取小数点后几位，就用10的几次方
        console.log(Math.round(4.65 * 10) / 10);  // 想获取小数点后几位，就用10的几次方
      </code>
    </pre>
    <figure class="截图容器">
      <img src="/Images/Blogs/Web前端-原生开发/浮点数四舍五入/Math.round()-结果.png" alt="Math.round()-结果" />
    </figure>
    <p class="分区普通文本">
      这个办法能得到准确的结果，并且最终的结果是<span class="行内专业名词">数字</span
      >，可以直接参与运算。注意：假设想保留小数点后<span class="行内专业名词 等宽">2</span>位，就改成<span class="代码"
        >Math<span style="color: gray">.</span>round<span style="color: yellowgreen">(</span>1.65
        <span style="color: orange">*</span> 100<span style="color: yellowgreen">)</span>
        <span style="color: silver">/</span> 100</span
      >，以此类推。
    </p>
  </article>
</div>
