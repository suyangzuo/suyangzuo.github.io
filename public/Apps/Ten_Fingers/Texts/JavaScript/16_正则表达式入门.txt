Regular expressions describe patterns in strings and are created with /pattern/flags or the RegExp constructor. Flags include g for global (find all matches), i for ignore case, m for multiline, s for dotAll (dot matches newline), u for Unicode, and y for sticky (match only from lastIndex). Character classes like \d match digits, \w matches word characters, \s matches whitespace, and . matches any character except newline by default. Quantifiers * (zero or more), + (one or more), ? (zero or one), and {n,m} control repetition. Anchors ^ and $ match start and end of input, or start and end of lines in multiline mode. Groups (...) capture submatches and can be referenced in replacements with $1, $2, etc. Non-capturing groups use (?:...). Lookaheads (?=...) and lookbehinds (?<=...) assert conditions without consuming characters. Be cautious with catastrophic backtracking when nested quantifiers can overlap, leading to exponential time on certain inputs. Test patterns online with tools like regex101 or RegExr. While powerful, readability suffers; comment complex patterns or build them from smaller, named parts. Regex is ideal for validation, extraction, and replacement, but should not replace proper parsers for nested structures like JSON or HTML.
