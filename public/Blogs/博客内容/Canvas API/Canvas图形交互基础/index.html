<article class="专题简介">
  <h1 class="简介标题">
    <span><span class="行内专业名词">Canvas</span>图形交互基础</span><span class="原创">原创</span>
  </h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本"><span class="日期文本-数字 日期文本-年">2025</span>年<span class="日期文本-数字 日期文本-月">8</span>月<span class="日期文本-数字 日期文本-日">10</span>日</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">鼠标与图形的位置关系</h2>

    <h3 class="分区标题 分区3级标题">判断的原理</h3>
    <p class="分区普通文本">
      <span class="行内专业名词">Canvas</span>中没有元素，只有纯粹的图形，因此无法使用<span class="代码">:hover</span
      >选择器来提供鼠标悬停时的样式，也无法为图形添加事件侦听器。因此，我们只能为整个<span class="代码">Canvas</span
      >添加鼠标<span class="行内专业名词">移动</span
      >事件监听器，并实时判断鼠标的坐标是否位于图形内部。无论是检测鼠标进入、离开，还是实现拖拽、点击，前提都要用整个<span
        class="行内专业名词"
        >Canvas</span
      >的<span class="行内代码">mousemove</span>事件来判断鼠标位置。
    </p>
    <p class="分区普通文本">
      另外，必须将图形的参数存储起来，才能判断鼠标是否在图形内部。如果仅仅用<span class="行内代码">Path2D</span
      >对象保存路径，这是不够的，因为<span class="行内代码">Path2D</span>无法访问路径的参数。
    </p>
    <p class="分区普通文本">
      举个例子：我们都知道矩形的参数其实就是<span class="行内专业名词">坐标</span>、<span class="行内专业名词"
        >宽度</span
      >、<span class="行内专业名词">高度</span>，因此矩形可以用对象存储：
    </p>
    <pre>
      <code class="lang-js">
        const 矩形 = {
          坐标: { x: 200, y: 200 },
          宽度: 150,
          高度: 150
        };
      </code>
    </pre>
    <p class="分区普通文本">
      只有相关参数被存储起来，才能实现各种交互效果，仅仅把图形渲染到<span class="行内专业名词">Canvas</span>上是不够的。
    </p>

    <h3 class="分区标题 分区3级标题">矩形</h3>
    <pre class="line-numbers">
      <code class="lang-js">
        //使用面向对象写法，便于命名管理
        class 矩形鼠标位置关系演示器 {
          constructor() {
            this.canvas = document.getElementById("矩形鼠标交互");
            this.ctx = this.canvas.getContext("2d");
            this.dpr = window.devicePixelRatio || 1;
            this.canvas.width = this.canvas.offsetWidth * this.dpr;
            this.canvas.height = this.canvas.offsetHeight * this.dpr;
            this.ctx.scale(this.dpr, this.dpr);
            this.画布中心 = {
              x: this.canvas.offsetWidth / 2,
              y: this.canvas.offsetHeight / 2,
            };

            // 存储图形数据，否则无法判断鼠标是否在其内部
            this.演示矩形 = {
              宽度: 250,
              高度: 150,
              坐标: {
                x: this.画布中心.x - 250 / 2,
                y: this.画布中心.y - 150 / 2,
              },
            };

            this.鼠标在演示矩形内部 = false;
            this.绘制全部();
            this.添加鼠标事件();
          }
  
          渲染Canvas背景() {
            this.ctx.save();
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = "rgba(35, 35, 35, 1)";
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.restore();
          }
  
          绘制矩形(矩形) {
            this.ctx.save();
            this.ctx.fillStyle = this.鼠标在演示矩形内部 ? "#fff3" : "#fff2";
            this.ctx.fillRect(矩形.坐标.x, 矩形.坐标.y, 矩形.宽度, 矩形.高度);
            this.ctx.restore();
          }
  
          绘制文本() {
            this.ctx.save();
            this.ctx.font = "18px sans-serif";
            this.ctx.textBaseline = "middle";
            this.ctx.textAlign = "center";

            if (this.鼠标在演示矩形内部) {
              this.ctx.fillStyle = "lightgreen";
              this.ctx.fillText("鼠标在矩形内部", this.画布中心.x, this.画布中心.y);
            } else {
              this.ctx.fillStyle = "#e45";
              this.ctx.fillText("鼠标在矩形外侧", this.画布中心.x, this.画布中心.y);
            }
            
            this.ctx.restore();
          }
  
          绘制全部() {
            this.渲染Canvas背景();
            this.绘制矩形(this.演示矩形);
            this.绘制文本();
          }
          
          // 核心判断逻辑
          鼠标位于矩形内部(鼠标相对坐标, 矩形) {
            return (
              鼠标相对坐标.x >= 矩形.坐标.x &&
              鼠标相对坐标.x <= 矩形.坐标.x + 矩形.宽度 &&
              鼠标相对坐标.y >= 矩形.坐标.y &&
              鼠标相对坐标.y <= 矩形.坐标.y + 矩形.高度
            );
          }
  
          获取鼠标相对坐标(e) {
            const 鼠标视口坐标 = {
              x: e.clientX,
              y: e.clientY,
            };
  
            const 边界矩形 = this.canvas.getBoundingClientRect();
  
            return {
              x: Math.round(鼠标视口坐标.x - 边界矩形.left),
              y: Math.round(鼠标视口坐标.y - 边界矩形.top),
            };
          }
  
          添加鼠标事件() {
            // 事件侦听器必须添加到 Canvas 上
            this.canvas.addEventListener("mousemove", (e) => {
              const 鼠标相对坐标 = this.获取鼠标相对坐标(e);
              this.鼠标在演示矩形内部 = this.鼠标位于矩形内部(鼠标相对坐标, this.演示矩形);
              this.绘制全部();
            });
          }
        }
  
        new 矩形鼠标位置关系演示器();
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas id="矩形鼠标位置关系" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    

    <h3 class="分区标题 分区3级标题">正圆</h3>
    <p class="分区普通文本">
      判断的核心逻辑：计算鼠标到圆心的距离，如果<span class="专业名词">距离<span class="行内代码"><=</span>半径</span
      >，则鼠标在圆<span class="行内专业名词">内部</span>。
    </p>
    <p class="分区普通文本">
      <span class="强调">注意：</span><span class="专业名词">距离<span class="行内代码"><=</span>半径</span>等同于<span
        class="专业名词"
        >距离<sup>2</sup><span class="行内代码"><=</span>半径<sup>2</sup></span
      >，为了避免开方运算，实际编码时往往直接使用后者。
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        class 正圆鼠标位置关系演示器 {
          constructor() {
            // ------------- 其它代码与矩形基本相同 -------------
            this.演示正圆 = {
              半径: 100,
              圆心: {
                x: this.画布中心.x,
                y: this.画布中心.y,
              },
            };
            
            this.鼠标在演示正圆内部 = false;
            this.绘制全部();
            this.添加鼠标事件();
          }

          渲染Canvas背景() {
            // ------------- 其它代码与矩形基本相同 -------------
          }

          绘制正圆(正圆) {
            this.ctx.save();
            this.ctx.beginPath();
            this.ctx.arc(正圆.圆心.x, 正圆.圆心.y, 正圆.半径, 0, 2 * Math.PI);
            this.ctx.fillStyle = this.鼠标在演示正圆内部 ? "#fff3" : "#fff2";
            this.ctx.fill();
            this.ctx.restore();
          }

          绘制文本() {
            // ------------- 其它代码与矩形基本相同 -------------
          }

          绘制全部() {
            this.渲染Canvas背景();
            this.绘制正圆(this.演示正圆);
            this.绘制文本();
          }

          // 核心判断逻辑
          鼠标位于正圆内部(鼠标相对坐标, 正圆) {
            // 不需要用 Math.sqrt 开方计算距离，因为开方运算比较耗时，直接用距离平方即可
            const 距离平方 = 
              Math.pow(鼠标相对坐标.x - 正圆.圆心.x, 2) + 
              Math.pow(鼠标相对坐标.y - 正圆.圆心.y, 2);

            // 距离平方和半径平方比较，等价于距离和半径比较
            return 距离平方 <= Math.pow(正圆.半径, 2);
          }

          获取鼠标相对坐标(e) {
            // ------------- 其它代码与矩形基本相同 -------------
          }

          添加鼠标事件() {
            // 事件侦听器必须添加到 Canvas 上
            this.canvas.addEventListener("mousemove", (e) => {
              const 鼠标相对坐标 = this.获取鼠标相对坐标(e);
              this.鼠标在演示正圆内部 = this.鼠标位于正圆内部(鼠标相对坐标, this.演示正圆);
              this.绘制全部();
            });
          }
        }

        new 正圆鼠标位置关系演示器();
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas id="正圆鼠标位置关系" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    

    <h3 class="分区标题 分区3级标题">椭圆</h3>
    <p class="分区普通文本">
      椭圆和正圆最大的区别在于椭圆有<span class="行内专业名词">两个半径</span
      >，这导致圆心到圆边的距离计算相对于正圆更加复杂。
    </p>
    <p class="分区普通文本">
      判断的核心逻辑：计算<span class="专业名词"
        ><span class="行内专业名词">鼠标与圆心水平距离</span><sup>2</sup><span class="行内代码">/</span
        ><span class="行内专业名词">横向半径</span><sup>2</sup><span class="行内代码">+</span
        ><span class="行内专业名词">鼠标与圆心垂直距离</span><sup>2</sup><span class="行内代码">/</span
        ><span class="行内专业名词">纵向半径</span><sup>2</sup></span
      >，<br />如果<span class="专业名词" style="margin-left: 2px">计算结果<span class="行内代码"><=</span>1</span
      >，则鼠标在椭圆<span class="行内专业名词">内部</span>。
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        class 椭圆鼠标位置关系演示器 {
          constructor() {
            // ------------- 其它代码与正圆基本相同 -------------
            
            this.演示椭圆 = {
              横向半径: 200,
              纵向半径: 150,
              圆心: {
                x: this.画布中心.x,
                y: this.画布中心.y,
              },
            };
            this.鼠标在演示椭圆内部 = false;
            this.绘制全部();
            this.添加鼠标事件();
          }

          渲染Canvas背景() {
            // ------------- 其它代码与正圆基本相同 -------------
          }

          绘制椭圆(椭圆) {
            this.ctx.save();
            this.ctx.beginPath();
            const 旋转弧度 = 0;
            const 起始弧度 = 0;
            const 结束弧度 = 2 * Math.PI;
            this.ctx.ellipse(
              椭圆.圆心.x, 
              椭圆.圆心.y, 
              椭圆.横向半径, 
              椭圆.纵向半径, 
              旋转弧度, 
              起始弧度, 
              结束弧度
            );
            this.ctx.fillStyle = this.鼠标在演示椭圆内部 ? "#fff3" : "#fff2";
            this.ctx.fill();
            this.ctx.restore();
          }

          绘制文本() {
            // ------------- 其它代码与正圆基本相同 -------------
          }

          绘制全部() {
            this.渲染Canvas背景();
            this.绘制椭圆(this.演示椭圆);
            this.绘制文本();
          }

          // 核心判断逻辑
          鼠标位于椭圆内部(鼠标相对坐标, 椭圆) {
            // 使用椭圆标准方程：
            // 鼠标与圆心水平距离² / 横向半径² + 鼠标与圆心垂直距离² / 纵向半径² <= 1
            const 鼠标与圆心水平距离 = 鼠标相对坐标.x - 椭圆.圆心.x;
            const 鼠标与圆心垂直距离 = 鼠标相对坐标.y - 椭圆.圆心.y;
            
            const 椭圆方程值 = 
              Math.pow(鼠标与圆心水平距离, 2) / Math.pow(椭圆.横向半径, 2) + 
              Math.pow(鼠标与圆心垂直距离, 2) / Math.pow(椭圆.纵向半径, 2);
            
            // 如果 椭圆方程值 <= 1，则点在椭圆内部或边界上
            return 椭圆方程值 <= 1;
          }

          获取鼠标相对坐标(e) {
            // ------------- 其它代码与正圆基本相同 -------------
          }

          添加鼠标事件() {
            this.canvas.addEventListener("mousemove", (e) => {
              const 鼠标相对坐标 = this.获取鼠标相对坐标(e);
              this.鼠标在演示椭圆内部 = this.鼠标位于椭圆内部(鼠标相对坐标, this.演示椭圆);
              this.绘制全部();
            });
          }
        }

        new 椭圆鼠标位置关系演示器();
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas id="椭圆鼠标位置关系" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    

    <h3 class="分区标题 分区3级标题">多边形</h3>
    <p class="分区普通文本">
      对于不规则的形状，包括任意多边形，<span class="行内专业名词">Canvas API</span>提供了一个原生函数<span
        class="行内代码"
        >isPointInPath</span
      >，用来判断某个<span class="行内专业名词">坐标</span>是否位于<span class="行内专业名词">路径内部</span
      >。其最常见的用法是：
    </p>
    <pre>
      <code class="lang-js">
        ctx.isPointInPath(Path2D路径, 水平坐标, 垂直坐标);
      </code>
    </pre>
    <pre class="line-numbers">
      <code class="lang-js">
        class 多边形鼠标位置关系演示器 {
          constructor() {
            // ------------- 其它代码与矩形基本相同 -------------
            this.演示多边形 = {
              顶点数组: [
                { x: this.画布中心.x - 100, y: this.画布中心.y - 80 },
                { x: this.画布中心.x + 120, y: this.画布中心.y - 60 },
                { x: this.画布中心.x + 80, y: this.画布中心.y + 100 },
                { x: this.画布中心.x - 60, y: this.画布中心.y + 120 },
                { x: this.画布中心.x - 120, y: this.画布中心.y + 20 },
              ],
            };
            this.演示多边形路径 = new Path2D();
            this.鼠标在演示多边形内部 = false;
            this.绘制全部();
            this.添加鼠标事件();
          }

          渲染Canvas背景() {
            // ------------- 其它代码与矩形基本相同 -------------
          }

          绘制多边形(多边形) {
            this.ctx.save();
            this.演示多边形路径 = new Path2D();
            
            // 移动到第一个顶点
            this.演示多边形路径.moveTo(多边形.顶点数组[0].x, 多边形.顶点数组[0].y);
            
            // 连接所有顶点
            for (let i = 1; i < 多边形.顶点数组.length; i++) {
              this.演示多边形路径.lineTo(多边形.顶点数组[i].x, 多边形.顶点数组[i].y);
            }
            
            // 闭合路径
            this.演示多边形路径.closePath();
            
            this.ctx.fillStyle = this.鼠标在演示多边形内部 ? "#fff3" : "#fff2";
            this.ctx.fill(this.演示多边形路径);
            this.ctx.restore();
          }

          绘制文本() {
            // ------------- 其它代码与矩形基本相同 -------------
          }

          绘制全部() {
            this.渲染Canvas背景();
            this.绘制多边形(this.演示多边形);
            this.绘制文本();
          }

          // 多边形路径对象是 Path2D 类型
          鼠标位于多边形内部(鼠标相对坐标, 多边形路径对象) {
            return this.ctx.isPointInPath(
              多边形路径对象,
              // isPointInPath 检测的是物理像素，因此鼠标坐标必须 ✗ DPI缩放比例
              鼠标相对坐标.x * this.dpr, 
              鼠标相对坐标.y * this.dpr
            );
          }

          获取鼠标相对坐标(e) {
            // ------------- 其它代码与矩形基本相同 -------------
          }

          添加鼠标事件() {
            this.canvas.addEventListener("mousemove", (e) => {
              const 鼠标相对坐标 = this.获取鼠标相对坐标(e);
              this.鼠标在演示多边形内部 = this.鼠标位于多边形内部(鼠标相对坐标, this.演示多边形路径);
              this.绘制全部();
            });
          }
        }

        new 多边形鼠标位置关系演示器();
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas id="多边形鼠标位置关系" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">拖放图形</h2>

    <h3 class="分区标题 分区3级标题">拖放原理</h3>
    <p class="分区普通文本">
      <span class="行内专业名词">Canvas</span>中的图形都是纯像素，不是DOM元素，因此无法对图形添加<span class="代码"
        >Drag<span class="次要">&</span>Drop</span
      >事件。我们只能通过对整个<span class="行内专业名词">Canvas</span>添加<span class="行内代码">mousedown</span
      >、<span class="行内代码">mouseup</span>、<span class="行内代码">mousemove</span>事件侦听器，来模拟拖放：
    </p>
    <ul class="分区列表">
      <li class="分区列表项">
        每个图形配套<span class="行内专业名词 等宽">2</span>个<span class="行内专业名词">布尔</span>变量，分别表示
        <ul class="分区列表">
          <li class="分区列表项">鼠标是否位于图形内部</li>
          <li class="分区列表项">图形是否被拖拽</li>
        </ul>
      </li>
      <li class="分区列表项">
        <span
          >添加<span class="行内代码">mousemove</span>事件侦听器，判断鼠标是否在图形内部，如果<span class="强调"
            >鼠标位于图形内部</span
          >且<span class="强调">图形被拖拽</span>，则更新形状路径。</span
        >最后重绘整个<span class="行内专业名词">Canvas</span>。
      </li>
      <li class="分区列表项">
        添加<span class="行内代码">mousedown</span>事件侦听器，如果<span class="行内专业名词">鼠标位于图形内部</span
        >，则将<span class="行内专业名词">被拖拽</span>改为<span class="行内代码">true</span>，并记录<span
          class="行内专业名词"
          >鼠标坐标</span
        >与<span class="行内专业名词">图形基点坐标</span>的<span class="行内专业名词">差值</span>。
      </li>
      <li class="分区列表项">
        <span
          >添加<span class="行内代码">mouseup</span>事件侦听器，只要鼠标抬起，则将所有图形的<span class="行内专业名词"
            >被拖拽</span
          >改为<span class="行内代码">false</span>。</span
        >
      </li>
    </ul>
    <p class="分区普通文本">
      所谓的<span class="行内专业名词">图形基点</span>，就是决定图形位置的关键坐标。<span class="行内专业名词"
        >矩形</span
      >的基点就是<span class="行内专业名词">左上角</span>，<span class="行内专业名词">圆</span>的基点就是<span
        class="行内专业名词"
        >圆心</span
      >。任意多边形的基点可以用<span class="行内专业名词">矩形包含块的左上角</span>来表示，但是比较麻烦。
    </p>

    <h3 class="分区标题 分区3级标题">拖放范例</h3>
    <pre class="line-numbers">
      <code class="lang-javascript">
        class 拖放图形演示器 {
          constructor() {
            this.canvas = document.getElementById("拖放图形");
            this.ctx = this.canvas.getContext("2d");
            this.dpr = window.devicePixelRatio || 1;
            this.canvas.width = this.canvas.offsetWidth * this.dpr;
            this.canvas.height = this.canvas.offsetHeight * this.dpr;
            this.ctx.scale(this.dpr, this.dpr);
            this.矩形 = {
              路径: new Path2D(),
              参数: {
                左上角: { x: 100, y: (this.canvas.offsetHeight - 200) / 2 },
                宽度: 150,
                高度: 200,
                鼠标差值: { x: 0, y: 0 },
              },
              鼠标位于内部: false,
              拖拽中: false,
            };
            this.正圆 = {
              路径: new Path2D(),
              参数: {
                圆心: { x: this.canvas.offsetWidth - 200, y: this.canvas.offsetHeight / 2 },
                半径: 100,
                鼠标差值: { x: 0, y: 0 },
              },
              鼠标位于内部: false,
              拖拽中: false,
            };
            this.矩形.路径.rect(
              this.矩形.参数.左上角.x,
              this.矩形.参数.左上角.y,
              this.矩形.参数.宽度,
              this.矩形.参数.高度
            );
            this.正圆.路径.arc(
              this.正圆.参数.圆心.x, 
              this.正圆.参数.圆心.y, 
              this.正圆.参数.半径, 
              0, 
              2 * Math.PI
            );
  
            this.绘制全部();
            this.添加鼠标移动事件();
            this.添加鼠标按下事件();
            this.添加鼠标抬起事件();
          }
  
          刷新矩形坐标与路径(矩形, 鼠标相对坐标) {
            矩形.参数.左上角.x = 鼠标相对坐标.x - 矩形.参数.鼠标差值.x;
            矩形.参数.左上角.y = 鼠标相对坐标.y - 矩形.参数.鼠标差值.y;
  
            矩形.路径 = new Path2D();
            矩形.路径.rect(矩形.参数.左上角.x, 矩形.参数.左上角.y, 矩形.参数.宽度, 矩形.参数.高度);
          }
  
          刷新正圆坐标与路径(正圆, 鼠标相对坐标) {
            正圆.参数.圆心.x = 鼠标相对坐标.x - 正圆.参数.鼠标差值.x;
            正圆.参数.圆心.y = 鼠标相对坐标.y - 正圆.参数.鼠标差值.y;
  
            正圆.路径 = new Path2D();
            正圆.路径.arc(正圆.参数.圆心.x, 正圆.参数.圆心.y, 正圆.参数.半径, 0, 2 * Math.PI);
          }
  
          刷新鼠标与矩形差值(鼠标相对坐标) {
            const 矩形左上角 = this.矩形.参数.左上角;
            this.矩形.参数.鼠标差值.x = 鼠标相对坐标.x - 矩形左上角.x;
            this.矩形.参数.鼠标差值.y = 鼠标相对坐标.y - 矩形左上角.y;
          }
  
          刷新鼠标与正圆差值(鼠标相对坐标) {
            const 圆心 = this.正圆.参数.圆心;
            this.正圆.参数.鼠标差值.x = 鼠标相对坐标.x - 圆心.x;
            this.正圆.参数.鼠标差值.y = 鼠标相对坐标.y - 圆心.y;
          }
  
          获取鼠标与Canvas相对坐标(e) {
            const 鼠标视口坐标 = {
              x: e.clientX,
              y: e.clientY,
            };
  
            const 边界矩形 = this.canvas.getBoundingClientRect();
  
            return {
              x: Math.round(鼠标视口坐标.x - 边界矩形.left),
              y: Math.round(鼠标视口坐标.y - 边界矩形.top),
            };
          }
  
          绘制提示文本() {
            this.ctx.save();
            this.ctx.font = "20px sans-serif";
            this.ctx.textBaseline = "top";
            this.ctx.textAlign = "right";
            this.ctx.fillStyle = "white";
            this.ctx.fillText("请尝试拖放图形", this.canvas.offsetWidth - 25, 25);
            this.ctx.restore();
          }
  
          绘制矩形(矩形) {
            this.ctx.save();
            if (this.矩形.鼠标位于内部 && 矩形.拖拽中) {
              this.ctx.lineWidth = 2;
              this.ctx.strokeStyle = "#adff2f30";
              this.ctx.fillStyle = "#fa51";
            } else if (this.矩形.鼠标位于内部) {
              this.ctx.lineWidth = 2;
              this.ctx.strokeStyle = "greenyellow";
              this.ctx.fillStyle = "#fa55";
            } else {
              this.ctx.lineWidth = 0;
              this.ctx.strokeStyle = "transparent";
              this.ctx.fillStyle = "#fa5";
            }
            this.ctx.stroke(矩形.路径);
            this.ctx.fill(矩形.路径);
  
            if (this.矩形.鼠标位于内部 && 矩形.拖拽中) {
              this.ctx.beginPath();
              this.ctx.arc(矩形.参数.左上角.x, 矩形.参数.左上角.y, 6, 0, 2 * Math.PI);
              this.ctx.fillStyle = "lightseagreen";
              this.ctx.fill();
              this.ctx.closePath();
            }
  
            this.ctx.restore();
          }
  
          绘制正圆(正圆) {
            this.ctx.save();
            if (this.正圆.鼠标位于内部 && 正圆.拖拽中) {
              this.ctx.lineWidth = 2;
              this.ctx.strokeStyle = "#ffd70030";
              this.ctx.fillStyle = "#5af1";
            } else if (this.正圆.鼠标位于内部) {
              this.ctx.lineWidth = 2;
              this.ctx.strokeStyle = "gold";
              this.ctx.fillStyle = "#5af5";
            } else {
              this.ctx.lineWidth = 0;
              this.ctx.strokeStyle = "transparent";
              this.ctx.fillStyle = "#5af";
            }
            this.ctx.stroke(正圆.路径);
            this.ctx.fill(正圆.路径);
  
            // 绘制圆之后，再绘制圆心
            if (this.正圆.鼠标位于内部 && 正圆.拖拽中) {
              this.ctx.beginPath();
              this.ctx.arc(正圆.参数.圆心.x, 正圆.参数.圆心.y, 6, 0, 2 * Math.PI);
              this.ctx.fillStyle = "yellowgreen";
              this.ctx.fill();
              this.ctx.closePath();
            }
  
            this.ctx.restore();
          }
  
          绘制全部() {
            this.ctx.save();
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.绘制矩形(this.矩形);
            this.绘制正圆(this.正圆);
            this.绘制提示文本();
            this.ctx.restore();
          }
  
          鼠标位于矩形内部(鼠标相对坐标, 矩形) {
            return (
              鼠标相对坐标.x >= 矩形.参数.左上角.x &&
              鼠标相对坐标.x <= 矩形.参数.左上角.x + 矩形.参数.宽度 &&
              鼠标相对坐标.y >= 矩形.参数.左上角.y &&
              鼠标相对坐标.y <= 矩形.参数.左上角.y + 矩形.参数.高度
            );
          }
  
          鼠标位于正圆内部(鼠标相对坐标, 正圆) {
            const 距离平方 =
                Math.pow(鼠标相对坐标.x - 正圆.参数.圆心.x, 2) 
              + Math.pow(鼠标相对坐标.y - 正圆.参数.圆心.y, 2);
            return 距离平方 <= Math.pow(正圆.参数.半径, 2);
          }
    
          添加鼠标移动事件() {
            this.canvas.onmousemove = (e) => {
              const 鼠标相对坐标 = this.获取鼠标与Canvas相对坐标(e);
              this.正圆.鼠标位于内部 = this.鼠标位于正圆内部(鼠标相对坐标, this.正圆);
              this.矩形.鼠标位于内部 = this.鼠标位于矩形内部(鼠标相对坐标, this.矩形);
  
              if (this.正圆.拖拽中 && this.正圆.鼠标位于内部) {
                this.刷新正圆坐标与路径(this.正圆, 鼠标相对坐标);
              } else if (this.矩形.拖拽中 && this.矩形.鼠标位于内部) {
                this.刷新矩形坐标与路径(this.矩形, 鼠标相对坐标);
              }
  
              this.绘制全部();
            };
          }
  
          添加鼠标按下事件() {
            this.canvas.onmousedown = (e) => {
              const 鼠标相对坐标 = this.获取鼠标与Canvas相对坐标(e);
              this.正圆.鼠标位于内部 = this.鼠标位于正圆内部(鼠标相对坐标, this.正圆);
              this.矩形.鼠标位于内部 = this.鼠标位于矩形内部(鼠标相对坐标, this.矩形);
  
              if (this.正圆.鼠标位于内部) {
                this.正圆.拖拽中 = true;
                this.刷新鼠标与正圆差值(鼠标相对坐标);
              } else if (this.矩形.鼠标位于内部) {
                this.矩形.拖拽中 = true;
                this.刷新鼠标与矩形差值(鼠标相对坐标);
              }
            };
          }
  
          添加鼠标抬起事件() {
            this.canvas.onmouseup = () => {
              this.矩形.拖拽中 = false;
              this.正圆.拖拽中 = false;
              this.绘制全部();
            };
          }
        }
  
        new 拖放图形演示器();
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas id="拖放图形" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">拖拽图形的本质，就是拖拽基点：拖拽矩形，就是拖拽左上角；拖拽圆，就是拖拽圆心。</p>
    
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">重叠处理</h2>

    <h3 class="分区标题 分区3级标题">重叠层级关系</h3>
    <p class="分区普通文本">
      有的时候，我们会遇到多个图形彼此重叠的情况，鼠标可能同时位于多个图形内部，那鼠标究竟应该和哪个图形进行交互呢？
    </p>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas id="图形重叠" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      五边形在最上方，正圆在中间，矩形在最下方；但是，当鼠标位置处于路径重叠范围时，所有符合条件的图形都能触发效果、都能被拖拽；而正常的逻辑应该是：<span
        class="强调"
        >只有处于最上方的图形能触发效果、能被拖拽</span
      >。为什么会这样？因为当前的拖拽代码没有进行<span class="强调">互斥</span>处理：
    </p>
    
    <pre class="line-numbers">
      <code class="language-javascript">
        开始拖拽(鼠标相对坐标) {
          // 检测所有被点击的图形，允许多个图形同时拖拽

          // 独立的 if
          if (this.鼠标位于五边形内部(鼠标相对坐标)) {
            this.拖拽状态.正在拖拽 = true;
            this.拖拽状态.拖拽开始位置 = { ...鼠标相对坐标 };
            this.五边形.拖拽偏移 = {
              x: 鼠标相对坐标.x - this.五边形.参数.圆心.x,
              y: 鼠标相对坐标.y - this.五边形.参数.圆心.y,
            };
            this.五边形.正在拖拽 = true;
          }

          // 独立的 if
          if (this.鼠标位于正圆内部(鼠标相对坐标)) {
            this.拖拽状态.正在拖拽 = true;
            this.拖拽状态.拖拽开始位置 = { ...鼠标相对坐标 };
            this.正圆.拖拽偏移 = {
              x: 鼠标相对坐标.x - this.正圆.参数.圆心.x,
              y: 鼠标相对坐标.y - this.正圆.参数.圆心.y,
            };
            this.正圆.正在拖拽 = true;
          }

          // 独立的 if
          if (this.鼠标位于矩形内部(鼠标相对坐标)) {
            this.拖拽状态.正在拖拽 = true;
            this.拖拽状态.拖拽开始位置 = { ...鼠标相对坐标 };
            this.矩形.拖拽偏移 = {
              x: 鼠标相对坐标.x - this.矩形.参数.左上角.x,
              y: 鼠标相对坐标.y - this.矩形.参数.左上角.y,
            };
            this.矩形.正在拖拽 = true;
          }
        }
      </code>
    </pre>
    <p class="分区普通文本">所有的<span class="行内代码">if</span>都是独立的，它们之间没有互斥关系。</p>

    <h3 class="分区标题 分区3级标题">使用<span class="行内专业名词">分支互斥</span>处理层叠关系</h3>
    <p class="分区普通文本">我们来修改一下<span class="行内代码">if</span>语句，让分支之间具有互斥性：</p>
    <pre class="line-numbers">
      <code class="language-javascript">
        // 按照绘制顺序，排放分支顺序
        开始拖拽(鼠标相对坐标) {
          // 只有一个 if 语句，分支具有互斥性，只允许一个图形拖拽
          if (this.鼠标位于五边形内部(鼠标相对坐标)) {
            this.拖拽状态.正在拖拽 = true;
            this.拖拽状态.拖拽开始位置 = { ...鼠标相对坐标 };
            this.五边形.拖拽偏移 = {
              x: 鼠标相对坐标.x - this.五边形.参数.圆心.x,
              y: 鼠标相对坐标.y - this.五边形.参数.圆心.y,
            };
            this.五边形.正在拖拽 = true;
          } else if (this.鼠标位于正圆内部(鼠标相对坐标)) {
            this.拖拽状态.正在拖拽 = true;
            this.拖拽状态.拖拽开始位置 = { ...鼠标相对坐标 };
            this.正圆.拖拽偏移 = {
              x: 鼠标相对坐标.x - this.正圆.参数.圆心.x,
              y: 鼠标相对坐标.y - this.正圆.参数.圆心.y,
            };
            this.正圆.正在拖拽 = true;
          } else if (this.鼠标位于矩形内部(鼠标相对坐标)) {
            this.拖拽状态.正在拖拽 = true;
            this.拖拽状态.拖拽开始位置 = { ...鼠标相对坐标 };
            this.矩形.拖拽偏移 = {
              x: 鼠标相对坐标.x - this.矩形.参数.左上角.x,
              y: 鼠标相对坐标.y - this.矩形.参数.左上角.y,
            };
            this.矩形.正在拖拽 = true;
          }
        }
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas id="图形重叠互斥" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">现在拖拽是不是正常了？</p>
    

    <h3 class="分区标题 分区3级标题">使用<span class="行内专业名词">索引</span>处理层叠关系</h3>
    <p class="分区普通文本">
      仔细思考一下，用<span class="行内专业名词">分支互斥</span>虽然有效，但这种做法好吗？让我们来看看问题所在：
    </p>
    <ul class="分区列表">
      <li class="分区列表项">
        <span class="行内专业名词 等宽">3</span>个图形，就写了<span class="行内专业名词 等宽">3</span>个<span
          class="行内代码"
          >if</span
        >分支，如果是<span class="行内专业名词 等宽">30</span>个图形呢？<span class="行内专业名词 等宽">300</span
        >个呢？能这么写代码吗？
      </li>
      <li class="分区列表项">
        虽然拖拽问题解决了，但是鼠标悬停到图形重叠范围内时，所有符合条件的图形依然会触发鼠标悬停效果。
      </li>
      <li class="分区列表项">
        检测鼠标是否位于矩形、正圆、多边形内部，用了<span class="行内专业名词 等宽">3</span>种不同的逻辑，写成了<span
          class="行内专业名词 等宽"
          >3</span
        >个函数，不具备通用性。
      </li>
    </ul>
    <p class="分区普通文本">我们需要解决上面3个问题，其思路为：</p>
    <ul class="分区列表">
      <li class="分区列表项">
        将<span class="行内专业名词 等宽">3</span>个图形按照绘制顺序，放到<span class="行内专业名词">数组</span
        >中，<span class="行内专业名词">索引</span>就是天然的层叠顺序，越靠后的图形，越在上方。
      </li>
      <li class="分区列表项">
        鼠标移动时，对<span class="行内专业名词">图形数组</span>进行<span class="强调">从后往前</span
        >依次检测，当检测到第一个符合条件的图形时，立刻停止检测，这样就能确保只有最上方的图形能触发效果。
      </li>
      <li class="分区列表项">所有图形全部使用<span class="行内代码">isPointInPath</span>检测鼠标是否位于内部。</li>
    </ul>
    <pre class="line-numbers">
      <code class="language-javascript">
        class 图形重叠正确处理演示器 {
          constructor() {
            this.canvas = document.getElementById("图形重叠正确处理演示器");
            this.ctx = this.canvas.getContext("2d");
            this.dpr = window.devicePixelRatio || 1;
            this.canvas.width = this.canvas.offsetWidth * this.dpr;
            this.canvas.height = this.canvas.offsetHeight * this.dpr;
            this.ctx.scale(this.dpr, this.dpr);
  
            this.画布中心 = {
              x: this.canvas.offsetWidth / 2,
              y: this.canvas.offsetHeight / 2,
            };
  
            // 拖拽状态
            this.拖拽状态 = {
              正在拖拽: false,
              拖拽开始位置: { x: 0, y: 0 },
            };
  
            // 图形栈：按照绘制顺序，越靠后的图形越在上方
            this.图形栈 = [
              {
                形状: "矩形",
                路径: new Path2D(),
                参数: {
                  左上角: { x: this.画布中心.x - 180, y: this.画布中心.y - 120 },
                  宽度: 300,
                  高度: 180,
                },
                鼠标位于内部: false,
                颜色: "#c54b6b", // 红色
                正在拖拽: false,
                拖拽偏移: { x: 0, y: 0 },
              },
              {
                形状: "正圆",
                路径: new Path2D(),
                参数: {
                  圆心: { x: this.画布中心.x + 60, y: this.画布中心.y - 40 },
                  半径: 120,
                },
                鼠标位于内部: false,
                颜色: "#edd700", // 青色
                正在拖拽: false,
                拖拽偏移: { x: 0, y: 0 },
              },
              {
                形状: "五边形",
                路径: new Path2D(),
                参数: {
                  中心点: { x: this.画布中心.x, y: this.画布中心.y + (40 / 3) * 4 },
                  半径: 120,
                },
                鼠标位于内部: false,
                颜色: "#4587d1", // 蓝色
                正在拖拽: false,
                拖拽偏移: { x: 0, y: 0 },
              }
            ];
  
            // 构建路径
            for (const 图形 of this.图形栈) {
              this.构建图形路径(图形);
            }
  
            this.绘制全部();
            this.添加鼠标事件();
          }
          
          // "内聚"思路，将不同的形状路径构建函数，统一到同一个函数中
          构建图形路径(图形对象) {
            图形对象.路径 = new Path2D();
            
            switch (图形对象.形状) {
              case "矩形":
                this.构建矩形路径(图形对象);
                break;
              case "正圆":
                this.构建正圆路径(图形对象);
                break;
              case "五边形":
                this.构建五边形路径(图形对象);
                break;
              default:
                console.warn(`未知的图形形状: ${图形对象.形状}`);
            }
          }
  
          构建矩形路径(矩形对象) {
            矩形对象.路径 = new Path2D();
            矩形对象.路径.rect(
              矩形对象.参数.左上角.x,
              矩形对象.参数.左上角.y,
              矩形对象.参数.宽度,
              矩形对象.参数.高度
            );
          }
  
          构建正圆路径(正圆对象) {
            正圆对象.路径 = new Path2D();
            正圆对象.路径.arc(
              正圆对象.参数.圆心.x, 
              正圆对象.参数.圆心.y, 
              正圆对象.参数.半径, 
              0, 
              2 * Math.PI
            );
          }
  
          构建五边形路径(五边形对象) {
            五边形对象.路径 = new Path2D();
  
            // 正五边形的顶点计算
            const 中心点 = 五边形对象.参数.中心点;
            const 半径 = 五边形对象.参数.半径;
            const 顶点数量 = 5;
  
            // 从顶部开始，顺时针绘制正五边形
            for (let i = 0; i < 顶点数量; i++) {
              const 角度 = (i * 2 * Math.PI) / 顶点数量 - Math.PI / 2; // 从顶部开始
              const x = 中心点.x + 半径 * Math.cos(角度);
              const y = 中心点.y + 半径 * Math.sin(角度);
  
              if (i === 0) {
                五边形对象.路径.moveTo(x, y);
              } else {
                五边形对象.路径.lineTo(x, y);
              }
            }
  
            五边形对象.路径.closePath();
          }
  
          绘制图形(图形对象) {
            this.ctx.save();
  
            // 根据鼠标位置和拖拽状态决定填充色透明度
            if (图形对象.正在拖拽) {
              this.ctx.fillStyle = 图形对象.颜色 + "50"; // 拖拽时半透明
              this.ctx.lineWidth = 3;
              this.ctx.strokeStyle = "#00ff00"; // 拖拽时绿色边框
            } else if (!this.拖拽状态.正在拖拽 && 图形对象.鼠标位于内部) {
              this.ctx.fillStyle = 图形对象.颜色 + "a0"; // 悬停时半透明
              this.ctx.lineWidth = 2;
              this.ctx.strokeStyle = "#ffffff";
            } else {
              this.ctx.fillStyle = 图形对象.颜色;
              this.ctx.lineWidth = 0;
              this.ctx.strokeStyle = "transparent";
            }
  
            this.ctx.fill(图形对象.路径);
            this.ctx.stroke(图形对象.路径);
  
            this.ctx.restore();
          }
  
          绘制全部() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            // 按顺序绘制，后面的会覆盖前面的
            for (const 图形 of this.图形栈) {
              this.绘制图形(图形);
            }
          }
          
          // 全部采用 isPointInPath，不再对矩形或者圆使用单独的检测方法，增强通用性
          鼠标位于图形内部(鼠标相对坐标, 路径) {
            return this.ctx.isPointInPath(
              路径, 
              鼠标相对坐标.x * this.dpr, 
              鼠标相对坐标.y * this.dpr
            );
          }
  
          // 检测鼠标位于哪个图形内部（考虑层叠顺序）
          获取鼠标位于其内部的最上方图形(鼠标相对坐标) {
            // 重置所有图形的鼠标状态
            for (const 图形 of this.图形栈) {
              图形.鼠标位于内部 = false;
            }
  
            // 从后往前检测（从最上方的图形开始）
            for (let i = this.图形栈.length - 1; i >= 0; i--) {
              const 图形 = this.图形栈[i];
              
              if (this.鼠标位于图形内部(鼠标相对坐标, 图形.路径)) {
                图形.鼠标位于内部 = true;
                return 图形; // 找到第一个符合条件的图形，立即返回
              }
            }
            
            return null; // 没有找到任何图形
          }
  
          获取鼠标相对坐标(e) {
            const 鼠标视口坐标 = {
              x: e.clientX,
              y: e.clientY,
            };
  
            const 边界矩形 = this.canvas.getBoundingClientRect();
  
            return {
              x: Math.round(鼠标视口坐标.x - 边界矩形.left),
              y: Math.round(鼠标视口坐标.y - 边界矩形.top),
            };
          }
  
          添加鼠标事件() {
            // 鼠标移动事件
            this.canvas.addEventListener("mousemove", (e) => {
              const 鼠标相对坐标 = this.获取鼠标相对坐标(e);
  
              if (this.拖拽状态.正在拖拽) {
                // 正在拖拽时，更新所有被拖拽的图形位置
                this.更新拖拽图形位置(鼠标相对坐标);
              }
  
              // 这一句仅用于鼠标悬停的视觉反馈，即将图形对象的鼠标位于内部状态设置为 true
              this.获取鼠标位于其内部的最上方图形(鼠标相对坐标);
  
              // 重新绘制
              this.绘制全部();
            });
  
            // 鼠标按下事件
            this.canvas.addEventListener("mousedown", (e) => {
              const 鼠标相对坐标 = this.获取鼠标相对坐标(e);
              this.开始拖拽(鼠标相对坐标);
            });
  
            // 鼠标松开事件
            this.canvas.addEventListener("mouseup", (e) => {
              this.结束拖拽();
              this.绘制全部();
            });

            this.canvas.addEventListener("mouseleave", (e) => {
              this.结束拖拽();
            });
          }
  
          开始拖拽(鼠标相对坐标) {
            // 使用栈结构从后往前检测，确保只有最上方的图形能被拖拽
            const 被点击的图形 = this.获取鼠标位于其内部的最上方图形(鼠标相对坐标);
            
            if (被点击的图形) {
              this.拖拽状态.正在拖拽 = true;
              this.拖拽状态.拖拽开始位置 = { ...鼠标相对坐标 };
              
              if (被点击的图形.形状 === "五边形") {
                被点击的图形.拖拽偏移 = {
                  x: 鼠标相对坐标.x - 被点击的图形.参数.中心点.x,
                  y: 鼠标相对坐标.y - 被点击的图形.参数.中心点.y,
                };
                被点击的图形.正在拖拽 = true;
              } else if (被点击的图形.形状 === "正圆") {
                被点击的图形.拖拽偏移 = {
                  x: 鼠标相对坐标.x - 被点击的图形.参数.圆心.x,
                  y: 鼠标相对坐标.y - 被点击的图形.参数.圆心.y,
                };
                被点击的图形.正在拖拽 = true;
              } else if (被点击的图形.形状 === "矩形") {
                被点击的图形.拖拽偏移 = {
                  x: 鼠标相对坐标.x - 被点击的图形.参数.左上角.x,
                  y: 鼠标相对坐标.y - 被点击的图形.参数.左上角.y,
                };
                被点击的图形.正在拖拽 = true;
              }
            }
          }
  
          更新拖拽图形位置(鼠标相对坐标) {
            // 更新所有正在拖拽的图形位置
            for (const 图形 of this.图形栈) {
              if (图形.正在拖拽) {
                if (图形.形状 === "五边形") {
                  // 更新五边形圆心位置
                  图形.参数.中心点.x = 鼠标相对坐标.x - 图形.拖拽偏移.x;
                  图形.参数.中心点.y = 鼠标相对坐标.y - 图形.拖拽偏移.y;
                  this.构建五边形路径(图形);
                } else if (图形.形状 === "正圆") {
                  // 更新正圆圆心位置
                  图形.参数.圆心.x = 鼠标相对坐标.x - 图形.拖拽偏移.x;
                  图形.参数.圆心.y = 鼠标相对坐标.y - 图形.拖拽偏移.y;
                  this.构建正圆路径(图形);
                } else if (图形.形状 === "矩形") {
                  // 更新矩形左上角位置
                  图形.参数.左上角.x = 鼠标相对坐标.x - 图形.拖拽偏移.x;
                  图形.参数.左上角.y = 鼠标相对坐标.y - 图形.拖拽偏移.y;
                  this.构建矩形路径(图形);
                }
              }
            }
          }
  
          结束拖拽() {
            // 结束所有图形的拖拽状态
            for (const 图形 of this.图形栈) {
              图形.正在拖拽 = false;
            }
            this.拖拽状态.正在拖拽 = false;
          }
        }
  
        new 图形重叠正确处理演示器();  
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.5">
      <canvas
        id="图形重叠正确处理演示器"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <p class="分区普通文本">再次尝试移动鼠标、拖拽图形，只有处于重叠范围最上方的图形会触发效果。</p>
    
  </article>
</div>