<article class="专题简介">
  <h1 class="简介标题">
    <span><span class="行内专业名词">2D</span>绘图进阶</span><span class="原创">原创</span>
  </h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本">2025年7月14日</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">透明度<span class="次要">和</span>阴影</h2>

    <h3 class="分区标题 分区3级标题">全局<span class="行内专业名词">透明度</span></h3>
    <p class="分区普通文本">
      透明度属性是<span class="行内代码">globalAlpha</span>，从名称就可以看出，<span class="行内代码">global</span
      >是<span class="行内专业名词">全局</span>的意思，也就是说，所有绘制的图形都会受到透明度的影响。<span
        class="行内代码"
        >globalAlpha</span
      >的范围是：<span class="代码">0 <span style="color: darkgoldenrod">-</span> 1</span>。
    </p>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //此时 globalAlpha 的值为 1.0
        //绘制第1个矩形
        
        ctx.globalAlpha = 0.25;
        //绘制第2个矩形

        ctx.globalAlpha = 0.05;
        //绘制第3个矩形
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75; background: none">
      <canvas id="canvas-global-alpha" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_global_alpha = document.getElementById("canvas-global-alpha");
      const ctx_global_alpha = canvas_global_alpha.getContext("2d");
      const dpr_global_alpha = window.devicePixelRatio || 1;
      canvas_global_alpha.width = canvas_global_alpha.offsetWidth * dpr_global_alpha;
      canvas_global_alpha.height = canvas_global_alpha.offsetHeight * dpr_global_alpha;
      ctx_global_alpha.scale(dpr_global_alpha, dpr_global_alpha);
      ctx_global_alpha.fillStyle = "darkgreen";
      ctx_global_alpha.strokeStyle = "gold";
      const rect_width_ga = 150;
      const rect_height_ga = 100;
      const gap_ga = 50;
      const total_width_ga = rect_width_ga * 3 + gap_ga * 2;
      ctx_global_alpha.rect(
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2,
        rect_width_ga,
        rect_height_ga
      );
      ctx_global_alpha.fill();
      ctx_global_alpha.stroke();
      ctx_global_alpha.save();
      ctx_global_alpha.fillStyle = "white";
      ctx_global_alpha.font = "bold 16px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_global_alpha.textBaseline = "middle";
      ctx_global_alpha.textAlign = "center";
      ctx_global_alpha.fillText(
        "100% 不透明度",
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga / 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2 + rect_height_ga / 2
      );
      ctx_global_alpha.restore();
      ctx_global_alpha.globalAlpha = 0.25;
      ctx_global_alpha.rect(
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga + gap_ga,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2,
        rect_width_ga,
        rect_height_ga
      );
      ctx_global_alpha.fill();
      ctx_global_alpha.stroke();
      ctx_global_alpha.save();
      ctx_global_alpha.globalAlpha = 1.0;
      ctx_global_alpha.fillStyle = "#aaa";
      ctx_global_alpha.font = "bold 16px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_global_alpha.textBaseline = "middle";
      ctx_global_alpha.textAlign = "center";
      ctx_global_alpha.fillText(
        "25% 不透明度",
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga / 2 + rect_width_ga + gap_ga,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2 + rect_height_ga / 2
      );
      ctx_global_alpha.restore();
      ctx_global_alpha.globalAlpha = 0.05;
      ctx_global_alpha.rect(
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga * 2 + gap_ga * 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2,
        rect_width_ga,
        rect_height_ga
      );
      ctx_global_alpha.fill();
      ctx_global_alpha.stroke();
      ctx_global_alpha.save();
      ctx_global_alpha.globalAlpha = 1.0;
      ctx_global_alpha.fillStyle = "#aaa";
      ctx_global_alpha.font = "bold 16px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_global_alpha.textBaseline = "middle";
      ctx_global_alpha.textAlign = "center";
      ctx_global_alpha.fillText(
        "5% 不透明度",
        (canvas_global_alpha.offsetWidth - total_width_ga) / 2 + rect_width_ga / 2 + rect_width_ga * 2 + gap_ga * 2,
        (canvas_global_alpha.offsetHeight - rect_height_ga) / 2 + rect_height_ga / 2
      );
      ctx_global_alpha.restore();
    </script>

    <h3 class="分区标题 分区3级标题">绘制<span class="行内专业名词">阴影</span></h3>
    <p class="分区普通文本">
      想一想，在<span class="行内专业名词">CSS</span>中的各种阴影，<span class="行内代码">box-shadow</span>、<span
        class="行内代码"
        >drop-shadow</span
      >、<span class="行内代码">text-shadow</span>，它们有哪些共同的属性？
    </p>
    <ul class="分区无序列表">
      <li class="分区列表项"><span class="行内专业名词">偏移量</span>：水平、垂直</li>
      <li class="分区列表项"><span class="行内专业名词">颜色</span></li>
      <li class="分区列表项"><span class="行内专业名词">模糊</span></li>
    </ul>
    <p class="分区普通文本">没错，在<span class="行内专业名词">Canvas</span>中，阴影的属性也是一样的：</p>
    <ul class="分区无序列表">
      <li class="分区列表项"><span class="行内代码">shadowOffsetX</span>：水平偏移量</li>
      <li class="分区列表项"><span class="行内代码">shadowOffsetY</span>：垂直偏移量</li>
      <li class="分区列表项"><span class="行内代码">shadowColor</span>：颜色</li>
      <li class="分区列表项"><span class="行内代码">shadowBlur</span>：模糊</li>
    </ul>
    <pre style="margin-top: 50px">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        ctx.shadowColor = "black";  //阴影颜色
        ctx.shadowOffsetX = 50;     //水平偏移量
        ctx.shadowOffsetY = 50;     //垂直偏移量
        ctx.shadowBlur = 20;        //模糊

        //绘制矩形代码：省略
        ctx.fill();    //填充
        ctx.stroke();  //描边

        //绘制文本代码：省略
        ctx.shadowColor = "black";  //阴影颜色
        ctx.shadowOffsetX = 10;     //水平偏移量
        ctx.shadowOffsetY = 10;     //垂直偏移量
        ctx.shadowBlur = 10;        //模糊

        //---------------- 填充文本 ----------------
        ctx.fillText("阴影", x + rectWidth / 2, y + rectHeight / 2);
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-shadow" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_shadow = document.getElementById("canvas-shadow");
      const ctx_shadow = canvas_shadow.getContext("2d");
      const dpr_shadow = window.devicePixelRatio || 1;
      canvas_shadow.width = canvas_shadow.offsetWidth * dpr_shadow;
      canvas_shadow.height = canvas_shadow.offsetHeight * dpr_shadow;
      ctx_shadow.scale(dpr_shadow, dpr_shadow);
      ctx_shadow.fillStyle = "darkgreen";
      ctx_shadow.strokeStyle = "gold";
      ctx_shadow.shadowColor = "black";
      ctx_shadow.shadowOffsetX = 50;
      ctx_shadow.shadowOffsetY = 50;
      ctx_shadow.shadowBlur = 20;

      // 计算矩形位置：水平1/3，垂直居中
      const rectWidth = 200;
      const rectHeight = 200;
      const x = (canvas_shadow.offsetWidth - rectWidth) / 2;
      const y = (canvas_shadow.offsetHeight - rectHeight) / 2;

      ctx_shadow.rect(x, y, rectWidth, rectHeight);
      ctx_shadow.fill();
      ctx_shadow.stroke();

      ctx_shadow.save();
      ctx_shadow.fillStyle = "white";
      ctx_shadow.font = "bold 24px 'JetBrains Mono', 'Consolas', sans-serif";
      ctx_shadow.textBaseline = "middle";
      ctx_shadow.textAlign = "center";
      ctx_shadow.shadowColor = "black";
      ctx_shadow.shadowOffsetX = 10;
      ctx_shadow.shadowOffsetY = 10;
      ctx_shadow.shadowBlur = 10;
      ctx_shadow.fillText("阴影", x + rectWidth / 2, y + rectHeight / 2);
      ctx_shadow.restore();
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        细心的同学肯定发现了：<span class="行内专业名词">描边</span>的阴影<span class="强调">覆盖了</span
        ><span class="行内专业名词">填充</span>的阴影。为什么会这样呢？因为代码中是<span class="行内专业名词"
          >先填充，后描边</span
        >，谁在后面，谁就处于更上方。因此描边的阴影在填充的上方。
      </p>
      <p class="分区普通文本">怎么办呢？最简单直接的想法是：<span class="强调">先描边，后填充</span>，我们来试试：</p>
      <pre>
        <code class="lang-javascript">
          //其它代码不变
          ctx.stroke();  //描边在前
          ctx.fill();    //填充在后
          //其它代码不变
        </code>
      </pre>
      <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
        <canvas
          id="canvas-shadow-stroke-before"
          style="width: 100%; height: calc(100% - 42px); background-color: #222"
        ></canvas>
      </figure>
      <p class="分区普通文本">
        还是有问题！描边又被填充的阴影覆盖了！因为描边在前，填充在后，因此填充的阴影处于描边的上方。
      </p>
      <script>
        const canvas_shadow_stroke_before = document.getElementById("canvas-shadow-stroke-before");
        const ctx_shadow_stroke_before = canvas_shadow_stroke_before.getContext("2d");
        const dpr_shadow_stroke_before = window.devicePixelRatio || 1;
        canvas_shadow_stroke_before.width = canvas_shadow_stroke_before.offsetWidth * dpr_shadow_stroke_before;
        canvas_shadow_stroke_before.height = canvas_shadow_stroke_before.offsetHeight * dpr_shadow_stroke_before;
        ctx_shadow_stroke_before.scale(dpr_shadow_stroke_before, dpr_shadow_stroke_before);
        ctx_shadow_stroke_before.fillStyle = "darkgreen";
        ctx_shadow_stroke_before.strokeStyle = "gold";
        ctx_shadow_stroke_before.lineWidth = 5;
        ctx_shadow_stroke_before.shadowColor = "black";
        ctx_shadow_stroke_before.shadowOffsetX = 50;
        ctx_shadow_stroke_before.shadowOffsetY = 50;
        ctx_shadow_stroke_before.shadowBlur = 20;

        // 计算矩形位置：水平1/3，垂直居中
        const rectWidthBefore = 200;
        const rectHeightBefore = 200;
        const xBefore = (canvas_shadow_stroke_before.offsetWidth - rectWidthBefore) / 2;
        const yBefore = (canvas_shadow_stroke_before.offsetHeight - rectHeightBefore) / 2;

        ctx_shadow_stroke_before.rect(xBefore, yBefore, rectWidthBefore, rectHeightBefore);
        ctx_shadow_stroke_before.stroke();
        ctx_shadow_stroke_before.fill();
      </script>
      <p class="分区普通文本">
        仔细思考一下，到底应该怎么办？此时比较好的办法是：放弃描边的阴影，只保留填充的阴影。但是，阴影的设置代码会同时应用到填充和描边。因此，我们要将<span
          class="强调"
          >阴影仅仅应用到填充</span
        >。
      </p>
      <pre>
        <code class="lang-javascript">
          //其它代码不变
          ctx.save();   //将"没有阴影"的上下文保存起来
          ctx.shadowColor = "black";  //阴影颜色
          ctx.shadowOffsetX = 50;     //水平偏移量
          ctx.shadowOffsetY = 50;     //垂直偏移量
          ctx.shadowBlur = 20;        //模糊
          ctx.fill();    //填充
          ctx.restore(); //恢复"没有阴影"的上下文

          ctx.stroke();  //现在描边就不会有阴影了，且描边在后，所以不会被填充的阴影挡住
        </code>
      </pre>
      <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
        <canvas
          id="canvas-shadow-stroke-after"
          style="width: 100%; height: calc(100% - 42px); background-color: #222"
        ></canvas>
      </figure>
      <p class="分区普通文本">这回看上去正常了。虽然失去了描边的阴影，但不影响整体的视觉效果。</p>
      <script>
        const canvas_shadow_stroke_after = document.getElementById("canvas-shadow-stroke-after");
        const ctx_shadow_stroke_after = canvas_shadow_stroke_after.getContext("2d");
        const dpr_shadow_stroke_after = window.devicePixelRatio || 1;
        canvas_shadow_stroke_after.width = canvas_shadow_stroke_after.offsetWidth * dpr_shadow_stroke_after;
        canvas_shadow_stroke_after.height = canvas_shadow_stroke_after.offsetHeight * dpr_shadow_stroke_after;
        ctx_shadow_stroke_after.scale(dpr_shadow_stroke_after, dpr_shadow_stroke_after);
        ctx_shadow_stroke_after.fillStyle = "darkgreen";
        ctx_shadow_stroke_after.strokeStyle = "gold";
        ctx_shadow_stroke_after.lineWidth = 3;

        const rectWidthAfter = 200;
        const rectHeightAfter = 200;
        const xAfter = (canvas_shadow_stroke_after.offsetWidth - rectWidthAfter) / 2;
        const yAfter = (canvas_shadow_stroke_after.offsetHeight - rectHeightAfter) / 2;

        ctx_shadow_stroke_after.rect(xAfter, yAfter, rectWidthAfter, rectHeightAfter);
        ctx_shadow_stroke_after.save();
        ctx_shadow_stroke_after.shadowColor = "black";
        ctx_shadow_stroke_after.shadowOffsetX = 50;
        ctx_shadow_stroke_after.shadowOffsetY = 50;
        ctx_shadow_stroke_after.shadowBlur = 20;
        ctx_shadow_stroke_after.fill();
        ctx_shadow_stroke_after.restore();
        ctx_shadow_stroke_after.stroke();
      </script>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">绘制虚线</h2>

    <h3 class="分区标题 分区3级标题">设置虚线</h3>
    <p class="分区普通文本">
      虚线用<span class="行内代码">setLineDash()</span
      >设置，其要点是：一段实线、一段透明线，交替绘制，我们只需要给出实线的长度和透明线的长度，两个数字用数组形式表示。
    </p>
    <pre>
      <code class="lang-javascript">
        //其它代码
        const 实线长度 = 20;
        const 透明线长度 = 10;
        ctx.setLineDash([实线长度, 透明线长度]);   //设置虚线
        ctx.stroke();  //描边
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-line-dash" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_line_dash = document.getElementById("canvas-line-dash");
      const ctx_line_dash = canvas_line_dash.getContext("2d");
      const dpr_line_dash = window.devicePixelRatio || 1;
      canvas_line_dash.width = canvas_line_dash.offsetWidth * dpr_line_dash;
      canvas_line_dash.height = canvas_line_dash.offsetHeight * dpr_line_dash;
      ctx_line_dash.scale(dpr_line_dash, dpr_line_dash);
      ctx_line_dash.strokeStyle = "darkgoldenrod";
      ctx_line_dash.lineWidth = 2;
      ctx_line_dash.setLineDash([20, 10]);
      ctx_line_dash.rect(300, 100, 200, 200);
      ctx_line_dash.stroke();
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">要从虚线恢复到实现，直接将虚线数组设置为空即可：</p>
      <pre>
        <code class="lang-javascript">
          ctx.setLineDash([]);  //将虚线数组设置为空，恢复实线
        </code>
      </pre>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">绘制渐变</h2>

    <h3 class="分区标题 分区3级标题"><span class="行内代码">CanvasGradient</span>对象</h3>
    <p class="分区普通文本">我们可以将使用渐变的步骤分解为<span class="行内专业名词">3</span>步：</p>
    <ol class="分区列表 有序列表">
      <li class="分区列表项">
        <span class="行内专业名词">创建渐变对象</span>：参数为<span class="行内专业名词">渐变起始坐标</span>和<span
          class="行内专业名词"
          >渐变结束坐标</span
        >
      </li>
      <li class="分区列表项">
        <span class="行内专业名词">添加色标</span>：参数为<span class="行内专业名词">位置</span>和<span
          class="行内专业名词"
          >颜色</span
        >
      </li>
      <li class="分区列表项"><span class="行内专业名词">将填充和描边设置为渐变对象</span></li>
    </ol>

    <h3 class="分区标题 分区3级标题">绘制线性渐变</h3>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制矩形 ----------------
        const 矩形宽度 = 400;
        const 矩形高度 = 200;
        const 矩形起始坐标 = { x: 200, y: 100 };
        ctx.rect(矩形起始坐标.x, 矩形起始坐标.y, 矩形宽度, 矩形高度);

        //创建渐变对象
        const 渐变起始坐标 = { x: 0, y: 100 };
        const 渐变结束坐标 = { x: canvas.offsetWidth, y: 100 };
        const 渐变对象 = ctx.createLinearGradient(
          渐变起始坐标.x, 
          渐变起始坐标.y, 
          渐变结束坐标.x, 
          渐变结束坐标.y
        );

        //添加色标
        const 色标1位置 = 0;    //代表 0% 的位置
        const 色标1颜色 = "blue";
        const 色标2位置 = 0.5;  //代表 50% 的位置
        const 色标2颜色 = "green";
        const 色标3位置 = 1;    //代表 100% 的位置
        const 色标3颜色 = "red";
        渐变对象.addColorStop(色标1位置, 色标1颜色);   //添加色标1
        渐变对象.addColorStop(色标2位置, 色标2颜色);   //添加色标2
        渐变对象.addColorStop(色标3位置, 色标3颜色);   //添加色标3

        //将填充设置为渐变对象
        ctx.fillStyle = 渐变对象;
        //绘制矩形
        ctx.fill();  //填充
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-linear-gradient"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <script>
      const canvas_linear_gradient = document.getElementById("canvas-linear-gradient");
      const ctx_linear_gradient = canvas_linear_gradient.getContext("2d");
      const dpr_linear_gradient = window.devicePixelRatio || 1;
      canvas_linear_gradient.width = canvas_linear_gradient.offsetWidth * dpr_linear_gradient;
      canvas_linear_gradient.height = canvas_linear_gradient.offsetHeight * dpr_linear_gradient;
      ctx_linear_gradient.scale(dpr_linear_gradient, dpr_linear_gradient);
      const 线性渐变矩形宽度 = 400;
      const 线性渐变矩形高度 = 200;
      const 线性渐变矩形起始坐标 = { x: 200, y: 100 };
      ctx_linear_gradient.rect(线性渐变矩形起始坐标.x, 线性渐变矩形起始坐标.y, 线性渐变矩形宽度, 线性渐变矩形高度);

      const 线性渐变起始坐标 = { x: 0, y: 100 };
      const 线性渐变结束坐标 = { x: canvas_linear_gradient.offsetWidth, y: 100 };
      const 线性渐变对象 = ctx_linear_gradient.createLinearGradient(
        线性渐变起始坐标.x,
        线性渐变起始坐标.y,
        线性渐变结束坐标.x,
        线性渐变结束坐标.y
      );

      const 线性渐变色标1位置 = 0;
      const 线性渐变色标1颜色 = "blue";
      const 线性渐变色标2位置 = 0.5;
      const 线性渐变色标2颜色 = "green";
      const 线性渐变色标3位置 = 1;
      const 线性渐变色标3颜色 = "red";
      线性渐变对象.addColorStop(线性渐变色标1位置, 线性渐变色标1颜色);
      线性渐变对象.addColorStop(线性渐变色标2位置, 线性渐变色标2颜色);
      线性渐变对象.addColorStop(线性渐变色标3位置, 线性渐变色标3颜色);

      ctx_linear_gradient.fillStyle = 线性渐变对象;
      ctx_linear_gradient.fill(); //填充
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        你是否感觉这个渐变两端的颜色没有完全展现出来？没错，渐变对象的应用范围<span class="强调">是</span
        ><span class="行内专业名词">整个Canvas</span>，<span class="强调">不是</span
        ><span class="行内专业名词">某个路径</span>。
      </p>
    </section>

    <h3 class="分区标题 分区3级标题">绘制径向渐变</h3>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制矩形 ----------------
        const 矩形宽度 = 500;
        const 矩形高度 = 300;
        const 矩形起始坐标 = { x: 150, y: 50 };
        ctx.rect(矩形起始坐标.x, 矩形起始坐标.y, 矩形宽度, 矩形高度);

        //创建径向渐变对象
        const 渐变起始圆心 = { 
          x: 矩形起始坐标.x + 矩形宽度 / 2,
          y: 矩形起始坐标.y + 矩形高度 / 2
        };
        const 渐变起始圆半径 = 50;

        const 渐变结束圆心 = {
          x: 矩形起始坐标.x + 矩形宽度 / 2,
          y: 矩形起始坐标.y + 矩形高度 / 2
        };
        const 渐变结束圆半径 = 矩形宽度 < 矩形高度 ? 矩形宽度 / 2 : 矩形高度 / 2;

        const 渐变对象 = ctx.createRadialGradient(
          渐变起始圆心.x,
          渐变起始圆心.y,
          渐变起始圆半径,
          渐变结束圆心.x,
          渐变结束圆心.y,
          渐变结束圆半径
        );

        //添加色标
        const 色标1位置 = 0;    //代表 0% 的位置
        const 色标1颜色 = "darkgoldenrod";
        const 色标2位置 = 0.5;  //代表 50% 的位置
        const 色标2颜色 = "green";
        const 色标3位置 = 1;    //代表 100% 的位置
        const 色标3颜色 = "silver";
        渐变对象.addColorStop(色标1位置, 色标1颜色);   //添加色标1
        渐变对象.addColorStop(色标2位置, 色标2颜色);   //添加色标2
        渐变对象.addColorStop(色标3位置, 色标3颜色);   //添加色标3

        //将填充设置为渐变对象
        ctx.fillStyle = 渐变对象;
        //绘制矩形
        ctx.fill();  //填充
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-radial-gradient"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <script>
      const canvas_radial_gradient = document.getElementById("canvas-radial-gradient");
      const ctx_radial_gradient = canvas_radial_gradient.getContext("2d");
      const dpr_radial_gradient = window.devicePixelRatio || 1;
      canvas_radial_gradient.width = canvas_radial_gradient.offsetWidth * dpr_radial_gradient;
      canvas_radial_gradient.height = canvas_radial_gradient.offsetHeight * dpr_radial_gradient;
      ctx_radial_gradient.scale(dpr_radial_gradient, dpr_radial_gradient);
      const 径向渐变矩形宽度 = 500;
      const 径向渐变矩形高度 = 300;
      const 径向渐变矩形起始坐标 = { x: 150, y: 50 };
      ctx_radial_gradient.rect(径向渐变矩形起始坐标.x, 径向渐变矩形起始坐标.y, 径向渐变矩形宽度, 径向渐变矩形高度);

      const 径向渐变起始圆心 = {
        x: 径向渐变矩形起始坐标.x + 径向渐变矩形宽度 / 2,
        y: 径向渐变矩形起始坐标.y + 径向渐变矩形高度 / 2,
      };
      const 径向渐变起始圆半径 = 50;
      const 径向渐变结束圆心 = {
        x: 径向渐变矩形起始坐标.x + 径向渐变矩形宽度 / 2,
        y: 径向渐变矩形起始坐标.y + 径向渐变矩形高度 / 2,
      };
      const 径向渐变结束圆半径 = 径向渐变矩形宽度 < 径向渐变矩形高度 ? 径向渐变矩形宽度 / 2 : 径向渐变矩形高度 / 2;
      const 径向渐变对象 = ctx_radial_gradient.createRadialGradient(
        径向渐变起始圆心.x,
        径向渐变起始圆心.y,
        径向渐变起始圆半径,
        径向渐变结束圆心.x,
        径向渐变结束圆心.y,
        径向渐变结束圆半径
      );

      const 径向渐变色标1位置 = 0;
      const 径向渐变色标1颜色 = "darkgoldenrod";
      const 径向渐变色标2位置 = 0.5;
      const 径向渐变色标2颜色 = "green";
      const 径向渐变色标3位置 = 1;
      const 径向渐变色标3颜色 = "silver";
      径向渐变对象.addColorStop(径向渐变色标1位置, 径向渐变色标1颜色);
      径向渐变对象.addColorStop(径向渐变色标2位置, 径向渐变色标2颜色);
      径向渐变对象.addColorStop(径向渐变色标3位置, 径向渐变色标3颜色);

      ctx_radial_gradient.fillStyle = 径向渐变对象;
      ctx_radial_gradient.fill(); //填充
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本"><span class="行内专业名词">Canvas</span>径向渐变目前只能为正圆，不能为椭圆。</p>
    </section>

    <h3 class="分区标题 分区3级标题">绘制角度渐变</h3>
    <pre>
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        //---------------- 绘制矩形 ----------------
        const 矩形宽度 = canvas.offsetWidth;
        const 矩形高度 = canvas.offsetHeight;
        const 矩形起始坐标 = { x: 0, y: 0 };
        ctx.rect(矩形起始坐标.x, 矩形起始坐标.y, 矩形宽度, 矩形高度);

        //创建角度渐变对象
        const 角度渐变起始弧度 = Math.PI;   //从默认起始角度顺时针旋转180°
        const 角度渐变圆心 = { x: canvas.offsetWidth / 2, y: canvas.offsetHeight / 2 };
        const 角度渐变对象 = ctx.createConicGradient(角度渐变起始弧度, 角度渐变圆心.x, 角度渐变圆心.y);

        //添加色标
        const 色标1位置 = 0;     //代表 0% 的位置
        const 色标1颜色 = "blue";
        const 色标2位置 = 0.25;  //代表 50% 的位置
        const 色标2颜色 = "orange";
        const 色标3位置 = 0.5;   //代表 50% 的位置
        const 色标3颜色 = "green";
        const 色标4位置 = 0.75;  //代表 75% 的位置
        const 色标4颜色 = "yellow";
        const 色标5位置 = 1;     //代表 100% 的位置
        const 色标5颜色 = "purple";
        角度渐变对象.addColorStop(色标1位置, 色标1颜色);   //添加色标1
        角度渐变对象.addColorStop(色标2位置, 色标2颜色);   //添加色标2
        角度渐变对象.addColorStop(色标3位置, 色标3颜色);   //添加色标3
        角度渐变对象.addColorStop(色标4位置, 色标4颜色);   //添加色标4
        角度渐变对象.addColorStop(色标5位置, 色标5颜色);   //添加色标5

        //将填充设置为角度渐变对象
        ctx.fillStyle = 角度渐变对象;
        //绘制矩形
        ctx.fill();  //填充
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas
        id="canvas-conic-gradient"
        style="width: 100%; height: calc(100% - 42px); background-color: #222"
      ></canvas>
    </figure>
    <script>
      const canvas_conic_gradient = document.getElementById("canvas-conic-gradient");
      const ctx_conic_gradient = canvas_conic_gradient.getContext("2d");
      const dpr_conic_gradient = window.devicePixelRatio || 1;
      canvas_conic_gradient.width = canvas_conic_gradient.offsetWidth * dpr_conic_gradient;
      canvas_conic_gradient.height = canvas_conic_gradient.offsetHeight * dpr_conic_gradient;
      ctx_conic_gradient.scale(dpr_conic_gradient, dpr_conic_gradient);
      const 角度渐变矩形宽度 = canvas_conic_gradient.offsetWidth;
      const 角度渐变矩形高度 = canvas_conic_gradient.offsetHeight;
      const 角度渐变矩形起始坐标 = { x: 0, y: 0 };
      ctx_conic_gradient.rect(角度渐变矩形起始坐标.x, 角度渐变矩形起始坐标.y, 角度渐变矩形宽度, 角度渐变矩形高度);

      const 角度渐变起始弧度 = Math.PI;
      const 角度渐变圆心 = { x: canvas_conic_gradient.offsetWidth / 2, y: canvas_conic_gradient.offsetHeight / 2 };
      const 角度渐变对象 = ctx_conic_gradient.createConicGradient(角度渐变起始弧度, 角度渐变圆心.x, 角度渐变圆心.y);

      const 角度渐变色标1位置 = 0;
      const 角度渐变色标1颜色 = "blue";
      const 角度渐变色标2位置 = 0.25;
      const 角度渐变色标2颜色 = "orange";
      const 角度渐变色标3位置 = 0.5;
      const 角度渐变色标3颜色 = "green";
      const 角度渐变色标4位置 = 0.75;
      const 角度渐变色标4颜色 = "yellow";
      const 角度渐变色标5位置 = 1;
      const 角度渐变色标5颜色 = "purple";
      角度渐变对象.addColorStop(角度渐变色标1位置, 角度渐变色标1颜色);
      角度渐变对象.addColorStop(角度渐变色标2位置, 角度渐变色标2颜色);
      角度渐变对象.addColorStop(角度渐变色标3位置, 角度渐变色标3颜色);
      角度渐变对象.addColorStop(角度渐变色标4位置, 角度渐变色标4颜色);
      角度渐变对象.addColorStop(角度渐变色标5位置, 角度渐变色标5颜色);

      ctx_conic_gradient.fillStyle = 角度渐变对象;
      ctx_conic_gradient.fill(); //填充
    </script>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        <span class="行内专业名词">Canvas</span>角度渐变默认起始弧度为<span class="行内代码">0</span
        >，但却是水平向右的，因此顺时针旋转<span class="行内代码">180°</span>后，起始角度变成水平向左。
      </p>
    </section>
  </article>
</div>
