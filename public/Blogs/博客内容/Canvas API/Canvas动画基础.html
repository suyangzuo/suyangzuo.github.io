<article class="专题简介">
  <h1 class="简介标题">
    <span><span class="行内专业名词">Canvas</span>动画基础</span><span class="原创">原创</span>
  </h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本">2025年7月16日</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">动画概念</h2>

    <h3 class="分区标题 分区3级标题">动画的本质</h3>
    <p class="分区普通文本">
      看过电影、动画的人都知道，里面有个概念叫<span class="行内专业名词">帧率</span>，比如电影的帧率一般是<span
        class="行内专业名词"
        >24</span
      >。玩游戏的时候，我们也很关注<span class="行内专业名词">帧率</span>，帧率越高，游戏越流畅。<span
        class="行内专业名词"
        >帧率</span
      >就是<span class="行内专业名词">每秒播放的静态图像数量</span>，简称<span class="行内专业名词">FPS</span
      ><span class="附加说明">Frames Per Second</span
      >。因此，动画的本质就是一个个的静态图像，将这些图像以很快的速度播放，给人的感觉就像图像动了起来。
    </p>
    <p class="分区普通文本">
      <span class="行内专业名词">Canvas 动画</span
      >也是一样，将上一幅图像擦掉，然后快速画出下一幅，不断重复，形成了动画。只是，和<span class="行内专业名词"
        >Adobe Animate</span
      >这类动画设计软件不同，<span class="行内专业名词">Canvas 动画</span>是纯粹用代码写出来的，<span
        class="行内专业名词"
        >Canvas API</span
      >不提供任何图形界面，因此，<span class="行内专业名词">Canvas API</span>不适合用来做过于复杂的动画<span
        class="附加说明"
        >如平时看的动漫</span
      >。
    </p>
    <p class="分区普通文本">
      用代码写动画有什么好处？当然有，用代码做动画，动画实际上就是一段程序，而程序中的变量是可以在运行时进行修改的。
    </p>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-speed-control" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      用代码写动画，就可以在动画播放过程中与动画进行交互，比如实时调整动画播放的速度，这是普通动画无法比拟的。此外，由于动画实际上是纯文本代码，因此占用容量非常小，非常适合部署在网页中运行。
    </p>
    <script>
      const canvas_speed_control = document.getElementById("canvas-speed-control");
      const ctx_speed_control = canvas_speed_control.getContext("2d");
      const dpr_speed_control = window.devicePixelRatio || 1;
      canvas_speed_control.width = canvas_speed_control.offsetWidth * dpr_speed_control;
      canvas_speed_control.height = canvas_speed_control.offsetHeight * dpr_speed_control;
      ctx_speed_control.scale(dpr_speed_control, dpr_speed_control);

      // 旋转小球动画参数
      let lastTime_rotation = 0;
      let rotationAngle = 0;
      let rotationSpeed = 300; // 度/秒，默认速度

      // 小球参数
      const ballRadius = 15;
      const orbitRadius = 80;
      const centerX = canvas_speed_control.offsetWidth / 2;
      const centerY = canvas_speed_control.offsetHeight / 2;

      // 滑块参数
      const sliderWidth = 200;
      const sliderHeight = 20;
      const sliderX = 100; // 向右移动40px
      const sliderY = canvas_speed_control.offsetHeight - 60;
      const sliderMin = 100;
      const sliderMax = 1000;
      const sliderStep = 50;
      let sliderValue = 300;
      let isDragging = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      // 绘制旋转小球
      function drawRotatingBall() {
        // 清除画布
        ctx_speed_control.clearRect(0, 0, canvas_speed_control.offsetWidth, canvas_speed_control.offsetHeight);

        // 绘制轨道
        ctx_speed_control.strokeStyle = "#444";
        ctx_speed_control.lineWidth = 2;
        ctx_speed_control.beginPath();
        ctx_speed_control.arc(centerX, centerY, orbitRadius, 0, Math.PI * 2);
        ctx_speed_control.stroke();

        // 计算小球位置
        const ballX = centerX + orbitRadius * Math.cos((rotationAngle * Math.PI) / 180);
        const ballY = centerY + orbitRadius * Math.sin((rotationAngle * Math.PI) / 180);

        // 绘制小球
        ctx_speed_control.fillStyle = "#ff6b6b";
        ctx_speed_control.beginPath();
        ctx_speed_control.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
        ctx_speed_control.fill();

        // 绘制小球边框
        ctx_speed_control.strokeStyle = "#fff";
        ctx_speed_control.lineWidth = 2;
        ctx_speed_control.stroke();
      }

      // 绘制滑块
      function drawSlider() {
        // 绘制"旋转速度"文字
        ctx_speed_control.fillStyle = "silver";
        ctx_speed_control.font = "16px sans-serif";
        ctx_speed_control.textAlign = "right";
        ctx_speed_control.fillText("旋转速度", sliderX - 15, sliderY + 15);

        // 绘制滑块轨道
        ctx_speed_control.fillStyle = "#333";
        ctx_speed_control.fillRect(sliderX, sliderY, sliderWidth, sliderHeight);

        // 计算滑块位置
        const sliderProgress = (sliderValue - sliderMin) / (sliderMax - sliderMin);
        const sliderPosX = sliderX + sliderProgress * sliderWidth;

        // 绘制已滑过的部分
        ctx_speed_control.fillStyle = "#4CAF50";
        ctx_speed_control.fillRect(sliderX, sliderY, sliderPosX - sliderX, sliderHeight);

        // 检查鼠标是否在滑块上
        const rect = canvas_speed_control.getBoundingClientRect();
        const mouseX = ((lastMouseX - rect.left) * (canvas_speed_control.width / rect.width)) / dpr_speed_control;
        const mouseY = ((lastMouseY - rect.top) * (canvas_speed_control.height / rect.height)) / dpr_speed_control;

        const isHovering =
          mouseX >= sliderPosX - 5 &&
          mouseX <= sliderPosX + 5 &&
          mouseY >= sliderY - 5 &&
          mouseY <= sliderY + sliderHeight + 5;

        // 绘制滑块（根据悬停状态或拖拽状态改变样式）
        if (isHovering || isDragging) {
          ctx_speed_control.fillStyle = "#ffd700"; // 悬停或拖拽时变为金色
          ctx_speed_control.shadowColor = "#ffd700";
          ctx_speed_control.shadowBlur = 10;
        } else {
          ctx_speed_control.fillStyle = "#fff";
          ctx_speed_control.shadowBlur = 0;
        }

        ctx_speed_control.fillRect(sliderPosX - 5, sliderY - 5, 10, sliderHeight + 10);
        ctx_speed_control.strokeStyle = isHovering || isDragging ? "#ffb700" : "#666";
        ctx_speed_control.lineWidth = isHovering || isDragging ? 2 : 1;
        ctx_speed_control.strokeRect(sliderPosX - 5, sliderY - 5, 10, sliderHeight + 10);

        // 重置阴影
        ctx_speed_control.shadowBlur = 0;

        // 绘制数值
        ctx_speed_control.fillStyle = "lightskyblue";
        ctx_speed_control.font = "16px 'JetBrains Mono', Consolas, monospace";
        ctx_speed_control.textAlign = "left";
        ctx_speed_control.fillText(sliderValue, sliderX + sliderWidth + 15, sliderY + 15);
      }

      // 动画循环
      function animateRotation(currentTime) {
        // 计算时间差（毫秒转换为秒）
        const deltaTime = (currentTime - lastTime_rotation) / 1000;
        lastTime_rotation = currentTime;

        // 基于时间计算旋转角度
        const angleChange = rotationSpeed * deltaTime;
        rotationAngle += angleChange;

        // 保持角度在0-360度范围内
        if (rotationAngle >= 360) {
          rotationAngle -= 360;
        }

        // 绘制动画
        drawRotatingBall();
        drawSlider();

        requestAnimationFrame(animateRotation);
      }

      // 鼠标事件处理
      canvas_speed_control.addEventListener("mousedown", function (e) {
        const rect = canvas_speed_control.getBoundingClientRect();
        const x = ((e.clientX - rect.left) * (canvas_speed_control.width / rect.width)) / dpr_speed_control;
        const y = ((e.clientY - rect.top) * (canvas_speed_control.height / rect.height)) / dpr_speed_control;

        // 检查是否点击在滑块上
        const sliderProgress = (sliderValue - sliderMin) / (sliderMax - sliderMin);
        const sliderPosX = sliderX + sliderProgress * sliderWidth;

        if (x >= sliderPosX - 5 && x <= sliderPosX + 5 && y >= sliderY - 5 && y <= sliderY + sliderHeight + 5) {
          isDragging = true;
        }
      });

      canvas_speed_control.addEventListener("mousemove", function (e) {
        // 更新鼠标位置
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;

        if (isDragging) {
          const rect = canvas_speed_control.getBoundingClientRect();
          const x = ((e.clientX - rect.left) * (canvas_speed_control.width / rect.width)) / dpr_speed_control;

          // 计算新的滑块值
          let newValue = ((x - sliderX) / sliderWidth) * (sliderMax - sliderMin) + sliderMin;
          newValue = Math.max(sliderMin, Math.min(sliderMax, newValue));

          // 按步进值调整
          sliderValue = Math.round(newValue / sliderStep) * sliderStep;

          // 更新旋转速度
          rotationSpeed = sliderValue;
        }

        // 检查鼠标是否在滑块上并更新鼠标样式
        const rect = canvas_speed_control.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) * (canvas_speed_control.width / rect.width)) / dpr_speed_control;
        const mouseY = ((e.clientY - rect.top) * (canvas_speed_control.height / rect.height)) / dpr_speed_control;

        const sliderProgress = (sliderValue - sliderMin) / (sliderMax - sliderMin);
        const sliderPosX = sliderX + sliderProgress * sliderWidth;

        const isHovering =
          mouseX >= sliderPosX - 5 &&
          mouseX <= sliderPosX + 5 &&
          mouseY >= sliderY - 5 &&
          mouseY <= sliderY + sliderHeight + 5;

        if (isHovering || isDragging) {
          canvas_speed_control.style.cursor = 'url("/Images/Common/鼠标-指向.cur"), pointer';
        } else {
          canvas_speed_control.style.cursor = "default";
        }
      });

      canvas_speed_control.addEventListener("mouseup", function () {
        isDragging = false;
      });

      canvas_speed_control.addEventListener("mouseleave", function () {
        canvas_speed_control.style.cursor = "default";
      });

      // 启动动画
      requestAnimationFrame(animateRotation);
    </script>
    <p class="分区普通文本">
      从<span class="行内专业名词">Canvas API</span>的整体设计来看，它更适合用来做科学、教学、演示这类动画。
    </p>

    <h3 class="分区标题 分区3级标题">动画的实现</h3>
    <p class="分区普通文本">
      如之前所说，动画的本质就是<span class="行内专业名词">不断更新的静态图像</span
      >，因此我们的代码的整体逻辑就是：<span class="强调"
        >擦除<span class="次要">→</span>绘图<span class="次要">→</span>擦除<span class="次要">→</span>绘图<span
          class="次要"
          >→</span
        >擦除<span class="次要">→</span>绘图<span class="次要">………</span></span
      >，如此循环往复。可以看出，每一个<span class="专业名词">擦除<span class="次要">→</span>绘图</span
      >为一次完整操作。<br />简而言之，<span class="强调">每隔一段时间</span>进行一次<span class="专业名词"
        >擦除<span class="次要">→</span>绘图</span
      >操作。
    </p>
    <p class="分区普通文本">
      问题来了，<span class="强调">每隔一段时间</span>进行一次操作，你想到了什么？<span class="行内专业名词">循环</span
      >？还算可以；<span class="行内代码">setInterval()</span>？不错不错！但这些方法都不是专门为<span
        class="行内专业名词"
        >Canvas 动画</span
      >设计的。今天，我们介绍一种专门为<span class="行内专业名词">Canvas 动画</span>设计的动画方法：<span
        class="行内代码"
        >requestAnimationFrame()</span
      >。
    </p>
    <p class="分区普通文本">
      <span class="行内代码">requestAnimationFrame()</span
      >会告诉浏览器，尽量按照显示器刷新率来执行动画。比如显示器刷新率为<span class="行内专业名词">60Hz</span>，那么<span
        class="行内代码"
        >requestAnimationFrame()</span
      >就是每秒钟运行<span class="行内专业名词">60次</span>。从编程语法上讲，<span class="行内代码"
        >requestAnimationFrame()</span
      >往往采用<span class="行内专业名词">递归调用</span>的方式，也就是<span class="强调"
        >在动画函数内部，用<span class="行内代码"
          >requestAnimationFrame(<span class="行内专业名词">函数自身</span>)</span
        >的方式，像套娃一样不断自己调用自己</span
      >。
    </p>
    <p class="分区普通文本">
      <span class="强调"
        >递归调用<span class="行内代码">requestAnimationFrame(<span class="行内专业名词">函数自身</span>)</span></span
      >，就是<span class="行内专业名词">Canvas 动画</span>的标准写法。
    </p>
    <pre>
      <code class="lang-javascript">
        // 编写动画函数
        animate() {
          // 绘制逻辑
          requestAnimationFrame(animate);  //函数内部递归调用自身
        }

        // 启动动画
        requestAnimationFrame(animate);
      </code>
    </pre>

    <h3 class="分区标题 分区3级标题">帧率问题</h3>
    <p class="分区普通文本">
      之前说过，<span class="行内代码">requestAnimationFrame()</span
      >会按照显示器刷新率来更新动画，但是，不同的显示器刷新率不一样，以前绝大部分显示器刷新率都是<span
        class="行内专业名词"
        >60Hz</span
      >，但现在出现了很多高刷新率的显示器，它们的刷新率可以到达<span class="行内专业名词">120Hz</span
      >以上，最夸张的甚至能到<span class="行内专业名词">600Hz</span>。假设动画中设置了每次向右偏移<span
        class="行内专业名词"
        >2px</span
      >，在<span class="行内专业名词">60Hz</span>刷新率上，每秒就会偏移<span class="行内专业名词">120px</span
      >，而在<span class="行内专业名词">144Hz</span>的显示器上，每秒会偏移<span class="行内专业名词">288px</span
      >！！！这肯定是不符合业务需求的，动画的速度应该在不同刷新率的显示器上一致。
    </p>
    <p class="分区普通文本">
      为了达到<span class="强调">刷新率不同，速度一致</span>的目标，我们的设计思路是：设定好<span class="行内专业名词"
        >每秒移动的距离</span
      >，然后获取<span class="行内专业名词">每两帧之间的时间差</span>，用<span class="专业名词"
        >两帧之间时间差<span class="次要" style="color: silver">×</span>每秒移动距离<span
          class="次要"
          style="color: silver; margin: 0 4px"
          >=</span
        >两帧之间移动距离</span
      >这个公式来判定每次动画应该移动的距离。这也是<a
        class="超链接"
        href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame"
        target="_blank"
        >MDN 文档</a
      >着重强调的写法：
    </p>
    <figure class="截图容器" style="width: 100%">
      <img src="/Images/Blogs/Canvas API/Canvas动画/requestAnimationFrame_推荐距离算法.png" alt="推荐距离算法" />
    </figure>
    <p class="分区普通文本">这不是建议，而是<span class="强调">警告</span>，说明这种写法是必要的，而不是可选的。</p>
    <p class="分区普通文本">
      为了计算出<span class="行内专业名词">每两帧之间的时间差</span>，我们需要一个非常重要的参数：<span
        class="行内专业名词"
        >当前时间</span
      >。每渲染一帧，我们就要知道<span class="行内专业名词">这一帧的当前时间</span>，然后减去<span class="行内专业名词"
        >上一帧的当前时间</span
      >，就得到了时间差。万幸的是，<span class="行内代码">JavaScript</span>内置了这个参数：可以叫<span class="行内代码"
        >currentTime</span
      >或者<span class="行内代码">timestamp</span
      >，这个参数的意思是：从页面加载，到运行到这一帧时，一共经过了多长时间，单位为<span class="行内专业名词">毫秒</span
      >。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        let lastTime = 0;  // 初始化"上一帧经过时间"为0
        const 每秒移动距离 = 300;  // 数字越大，速度越快

        animate(currentTime) {  // currentTime参数为内置，无需事先初始化
          const 时间差 = (currentTime - lastTime) / 1000;  // 将毫秒转换为秒
          const 移动距离 = 每秒移动距离 * 时间差;
          lastTime = currentTime;  // 更新上一帧经过时间

          当前距离 += 移动距离;  // 移动物体

          // 绘制逻辑
          requestAnimationFrame(animate);  //函数内部递归调用自身
        }

        // 启动动画
        requestAnimationFrame(animate);
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-deltaTime" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      利用内置的<span class="行内代码">currentTime</span>，我们就可以精确计算出<span class="行内专业名词"
        >两帧之间的时间差</span
      >，从而计算出<span class="行内专业名词">两帧之间移动的距离</span>。
    </p>
    <script>
      const canvas_deltaTime = document.getElementById("canvas-deltaTime");
      const ctx_deltaTime = canvas_deltaTime.getContext("2d");
      const dpr_deltaTime = window.devicePixelRatio || 1;
      canvas_deltaTime.width = canvas_deltaTime.offsetWidth * dpr_deltaTime;
      canvas_deltaTime.height = canvas_deltaTime.offsetHeight * dpr_deltaTime;
      ctx_deltaTime.scale(dpr_deltaTime, dpr_deltaTime);

      // 动画参数
      let lastTime_delta = 0;
      let currentTime_delta = 0;
      let ballX_delta = 50;
      let currentTimeBarX_delta = 50;
      let lastTimeBarX_delta = 50;
      let ballY_delta = canvas_deltaTime.offsetHeight / 2;
      let currentTimeBarY_delta = ballY_delta - 40;
      let lastTimeBarY_delta = ballY_delta + 40;
      let barWidth_delta = 20;
      let barHeight_delta = 8;
      let ballRadius_delta = 12;

      // 动画状态控制
      let animationPhase = 0; // 0: 移动, 1: 停顿, 2: 显示时间差, 3: currentTime进度条移动, 4: 等待下一次移动
      let phaseStartTime = 0;
      let moveStep = 0; // 当前移动步数 (0-7)
      let totalSteps = 8;
      let stepDistance = (canvas_deltaTime.offsetWidth - 100) / totalSteps;

      // 时间差显示相关
      let deltaTimeDisplay = 0;
      let deltaTimeBarWidth = 0;
      let lastTimeStartX = 50; // 保存lastTime移动的起始位置
      let lineGrowthStartTime = 0; // 竖线增长开始时间
      let lineGrowthProgress = 0; // 竖线增长进度

      function drawDeltaTimeAnimation(currentTimestamp) {
        // 清除画布
        ctx_deltaTime.clearRect(0, 0, canvas_deltaTime.offsetWidth, canvas_deltaTime.offsetHeight);

        // 更新currentTime
        currentTime_delta = currentTimestamp;

        // 根据动画阶段执行不同逻辑
        switch (animationPhase) {
          case 0: // 移动阶段
            if (currentTimestamp - phaseStartTime > 0) {
              // 计算350ms内的移动进度
              const progress = Math.min((currentTimestamp - phaseStartTime) / 350, 1);
              const startX = 50 + moveStep * stepDistance;
              const endX = 50 + (moveStep + 1) * stepDistance;
              ballX_delta = startX + (endX - startX) * progress;
              currentTimeBarX_delta = ballX_delta;

              // 检查是否到达下一个停顿点
              if (progress >= 1) {
                ballX_delta = endX;
                currentTimeBarX_delta = ballX_delta;
                moveStep++;
                // 无论是否是最后一步，都进入停顿阶段显示时间差
                animationPhase = 1;
                phaseStartTime = currentTimestamp;
              }
            }
            break;

          case 1: // 停顿0.15秒
            if (currentTimestamp - phaseStartTime >= 150) {
              animationPhase = 2;
              phaseStartTime = currentTimestamp;
              // 计算时间差：当前时间减去lastTime更新时的时间
              deltaTimeDisplay = (currentTime_delta - lastTime_delta) / 1000;
              deltaTimeBarWidth = Math.min(deltaTimeDisplay * 200, 150); // 将时间差转换为视觉长度
            }
            break;

          case 2: // 竖线增长0.25秒 + 显示时间差1.75秒
            if (lineGrowthStartTime === 0) {
              lineGrowthStartTime = currentTimestamp;
            }

            // 计算竖线增长进度
            const lineGrowthTime = currentTimestamp - lineGrowthStartTime;
            if (lineGrowthTime < 250) {
              // 竖线增长阶段
              lineGrowthProgress = lineGrowthTime / 250;
            } else {
              // 竖线增长完成，显示时间差
              lineGrowthProgress = 1;
              if (currentTimestamp - phaseStartTime >= 2000) {
                lastTimeStartX = lastTimeBarX_delta; // 保存起始位置
                animationPhase = 3;
                phaseStartTime = currentTimestamp;
                lineGrowthStartTime = 0; // 重置
                lineGrowthProgress = 0; // 重置
              }
            }
            break;

          case 3: // lastTime进度条移动0.35秒
            if (currentTimestamp - phaseStartTime >= 350) {
              lastTimeBarX_delta = currentTimeBarX_delta;
              // 更新lastTime为当前时间，这样下次计算时间差时就是正确的间隔
              lastTime_delta = currentTime_delta;
              // 检查是否是最后一步
              if (moveStep >= totalSteps) {
                // 最后一步完成，进入重置等待阶段
                animationPhase = 4;
                phaseStartTime = currentTimestamp;
              } else {
                // 不是最后一步，进入下一次移动等待阶段
                animationPhase = 4;
                phaseStartTime = currentTimestamp;
              }
            } else {
              // 计算过渡进度
              const progress = (currentTimestamp - phaseStartTime) / 350;
              const endX = currentTimeBarX_delta;
              lastTimeBarX_delta = lastTimeStartX + (endX - lastTimeStartX) * progress;
            }
            break;

          case 4: // 等待1秒后开始下一次移动
            if (currentTimestamp - phaseStartTime >= 1000) {
              if (moveStep >= totalSteps) {
                // 重新开始整个循环
                moveStep = 0;
                ballX_delta = 50;
                currentTimeBarX_delta = 50;
                lastTimeBarX_delta = 50;
                // lastTime_delta已经在阶段3更新，这里不需要重复更新
              }
              animationPhase = 0;
              phaseStartTime = currentTimestamp;
            }
            break;
        }

        // 绘制currentTime进度条
        ctx_deltaTime.fillStyle = "#4CAF50";
        ctx_deltaTime.fillRect(50, currentTimeBarY_delta, currentTimeBarX_delta - 50, barHeight_delta);
        ctx_deltaTime.strokeStyle = "#fff";
        ctx_deltaTime.lineWidth = 1;
        ctx_deltaTime.strokeRect(50, currentTimeBarY_delta, currentTimeBarX_delta - 50, barHeight_delta);

        // 绘制lastTime进度条
        ctx_deltaTime.fillStyle = "#2196F3";
        ctx_deltaTime.fillRect(50, lastTimeBarY_delta, lastTimeBarX_delta - 50, barHeight_delta);
        ctx_deltaTime.strokeStyle = "#fff";
        ctx_deltaTime.lineWidth = 1;
        ctx_deltaTime.strokeRect(50, lastTimeBarY_delta, lastTimeBarX_delta - 50, barHeight_delta);

        // 在阶段2显示时间差
        if (animationPhase === 2) {
          // 绘制竖线
          ctx_deltaTime.strokeStyle = "#fff";
          ctx_deltaTime.lineWidth = 2;

          // 计算竖线的当前长度
          const currentTimeLineLength = (lastTimeBarY_delta - currentTimeBarY_delta) * lineGrowthProgress;
          const lastTimeLineLength = (lastTimeBarY_delta - currentTimeBarY_delta) * lineGrowthProgress;

          // currentTime竖线：从currentTime进度条上边缘向下增长
          ctx_deltaTime.beginPath();
          ctx_deltaTime.moveTo(currentTimeBarX_delta, currentTimeBarY_delta);
          ctx_deltaTime.lineTo(currentTimeBarX_delta, currentTimeBarY_delta + currentTimeLineLength);
          ctx_deltaTime.stroke();

          // lastTime竖线：从lastTime进度条下边缘向上增长到currentTime进度条下边缘
          ctx_deltaTime.beginPath();
          ctx_deltaTime.moveTo(lastTimeBarX_delta, lastTimeBarY_delta + barHeight_delta);
          ctx_deltaTime.lineTo(lastTimeBarX_delta, lastTimeBarY_delta + barHeight_delta - lastTimeLineLength);
          ctx_deltaTime.stroke();

          // 只有当竖线增长完成时才显示填充区域和文字
          if (lineGrowthProgress >= 1) {
            // 填充区域：两条竖线之间的区域，不覆盖进度条
            ctx_deltaTime.fillStyle = "rgba(255, 152, 0, 0.25)";
            // 上方区域：从currentTime进度条下边缘到lastTime进度条上边缘
            ctx_deltaTime.fillRect(
              lastTimeBarX_delta,
              currentTimeBarY_delta + barHeight_delta,
              currentTimeBarX_delta - lastTimeBarX_delta,
              lastTimeBarY_delta - (currentTimeBarY_delta + barHeight_delta)
            );
            // 下方区域：从lastTime进度条下边缘到currentTime进度条上边缘
            ctx_deltaTime.fillRect(
              lastTimeBarX_delta,
              lastTimeBarY_delta + barHeight_delta,
              currentTimeBarX_delta - lastTimeBarX_delta,
              currentTimeBarY_delta + barHeight_delta - (lastTimeBarY_delta + barHeight_delta)
            );

            // 绘制时间差文字
            ctx_deltaTime.fillStyle = "#fff";
            ctx_deltaTime.font = "14px JetBrains Mono, Consolas, sans-serif";
            ctx_deltaTime.textAlign = "center";
            const textX = (currentTimeBarX_delta + lastTimeBarX_delta) / 2;
            const textY = (currentTimeBarY_delta + lastTimeBarY_delta + barHeight_delta) / 2 + barHeight_delta;
            ctx_deltaTime.fillText(`${deltaTimeDisplay.toFixed(3)}s`, textX, textY);
          }
        }

        // 绘制标签
        ctx_deltaTime.fillStyle = "#fff";
        ctx_deltaTime.font = "14px JetBrains Mono, Consolas, sans-serif";
        ctx_deltaTime.textAlign = "left";
        ctx_deltaTime.fillText("currentTime（内置参数）", 14, currentTimeBarY_delta - 13);
        ctx_deltaTime.fillText("lastTime", 14, lastTimeBarY_delta + 30);

        // 绘制步骤指示器
        ctx_deltaTime.fillStyle = "#666";
        for (let i = 0; i <= totalSteps; i++) {
          const x = 50 + i * stepDistance;
          // 刻度放在两个进度条之间的垂直居中位置
          const scaleY = (currentTimeBarY_delta + lastTimeBarY_delta + barHeight_delta) / 2;
          ctx_deltaTime.fillRect(x - 1, scaleY, 2, 10);
        }

        requestAnimationFrame(drawDeltaTimeAnimation);
      }

      // 启动动画
      requestAnimationFrame(drawDeltaTimeAnimation);
    </script>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">动画案例</h2>

    <h3 class="分区标题 分区3级标题">无限循环动画</h3>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        // 动画参数 - 基于时间的控制
        let 上次时间 = 0;
        const 每秒移动距离 = 450; // 单位：像素/秒，数字越大速度越快

        const 矩形宽度 = 100;
        const 矩形高度 = 100;
        let 矩形水平坐标 = 0;   //要用let，因为移动需要改变坐标
        let 矩形垂直坐标 = (canvas.offsetHeight - 矩形高度) / 2;   //要用let，因为移动需要改变坐标
        
        function 绘制矩形() {
          //绘制逻辑
        }

        function 绘制动画(当前时间) {
          // 计算时间差（毫秒转换为秒）
          const 时间差 = (当前时间 - 上次时间) / 1000;
          上次时间 = 当前时间;
          
          // 基于时间计算移动距离
          const 移动距离 = 每秒移动距离 * 时间差;
          矩形水平坐标 += 移动距离;
          
          if (矩形水平坐标 > canvas.offsetWidth - 矩形宽度) {
            矩形水平坐标 = 0;   //如果矩形的右边界到达画布的右边界，则矩形回到起点
          }
          
          绘制矩形();
          requestAnimationFrame(绘制动画);   //自己调用自己：递归调用
        }

        requestAnimationFrame(绘制动画);
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-move" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      由于没有动画停止条件，所以<span class="行内代码">requestAnimationFrame()</span
      >递归调用会一直进行下去，直到页面被关闭。
    </p>
    <script>
      const canvas_move = document.getElementById("canvas-move");
      const ctx_move = canvas_move.getContext("2d");
      const dpr_move = window.devicePixelRatio || 1;
      canvas_move.width = canvas_move.offsetWidth * dpr_move;
      canvas_move.height = canvas_move.offsetHeight * dpr_move;
      ctx_move.scale(dpr_move, dpr_move);

      // 动画参数
      let lastTime = 0;
      const px_per_second = 450;

      const rect_move_width = 100;
      const rect_move_height = 100;
      let rect_move_x = 0;
      const rect_move_y = (canvas_move.offsetHeight - rect_move_height) / 2;
      const rect_move_fillStyle = "#385";
      const rect_move_strokeStyle = "gold";
      ctx_move.lineWidth = 5;

      function rect_move_draw() {
        ctx_move.clearRect(0, 0, canvas_move.width, canvas_move.height);
        ctx_move.fillStyle = rect_move_fillStyle;
        ctx_move.strokeStyle = rect_move_strokeStyle;
        ctx_move.fillRect(rect_move_x, rect_move_y, rect_move_width, rect_move_height);
        ctx_move.strokeRect(rect_move_x, rect_move_y, rect_move_width, rect_move_height);
      }

      function draw_move(currentTime) {
        // 计算时间差（毫秒转换为秒）
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        // 基于时间计算移动距离
        const moveDistance = px_per_second * deltaTime;
        rect_move_x += moveDistance;

        // 边界检测
        if (rect_move_x > canvas_move.offsetWidth - rect_move_width) {
          rect_move_x = 0;
        }

        rect_move_draw();
        requestAnimationFrame(draw_move);
      }

      // 启动动画，传入当前时间
      requestAnimationFrame(draw_move);
    </script>

    <h3 class="分区标题 分区3级标题">添加动画停止条件</h3>
    <p class="分区普通文本">
      比较常见的做法就是设置一个<span class="行内专业名词">布尔</span>变量，然后把这个布尔变量作为<span class="行内代码"
        >requestAnimationFrame()</span
      >的条件。当动画触发停止条件时，将这个<span class="行内专业名词">布尔</span>变量设置为<span class="行内代码"
        >false</span
      >即可。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        //---------------- 获取Canvas 获取渲染上下文 ----------------
        //---------------- 设置分辨率缩放 ----------------

        // 动画参数 - 基于时间的控制
        let 停止动画 = false;  //布尔变量，用于动画播放的条件
        let 上次时间 = 0;
        const 每秒移动距离 = 600; // 单位：像素/秒，数字越大速度越快

        const 矩形宽度 = 100;
        const 矩形高度 = 100;
        let 矩形水平坐标 = 0;   //要用let，因为移动需要改变坐标
        let 矩形垂直坐标 = (canvas.offsetHeight - 矩形高度) / 2;   //要用let，因为移动需要改变坐标
        
        function 绘制矩形() {
          //绘制逻辑
        }

        function 绘制动画(当前时间) {
          // 计算时间差（毫秒转换为秒）
          const 时间差 = (当前时间 - 上次时间) / 1000;
          上次时间 = 当前时间;
          
          // 基于时间计算移动距离
          const 移动距离 = 每秒移动距离 * 时间差;
          矩形水平坐标 += 移动距离;
          
          if (矩形水平坐标 > canvas.offsetWidth - 矩形宽度) {
            停止动画 = true;   //如果矩形的右边界到达画布的右边界，停止动画
          }
          
          绘制矩形();

          // 给 requestAnimationFrame() 添加条件
          if (!停止动画) {
            requestAnimationFrame(绘制动画);   //自己调用自己：递归调用
          }
        }

        requestAnimationFrame(绘制动画);
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-move_stop" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <p class="分区普通文本">
      我们用了<span class="行内代码">停止动画</span>这个<span class="行内专业名词">布尔</span>变量作为<span
        class="行内代码"
        >requestAnimationFrame()</span
      >的条件，当矩形到达右边界时，将<span class="行内代码">停止动画</span>设置为<span class="行内代码">true</span
      >，从而停止动画。
    </p>
    <script>
      const canvas_move_stop = document.getElementById("canvas-move_stop");
      const ctx_move_stop = canvas_move_stop.getContext("2d");
      const dpr_move_stop = window.devicePixelRatio || 1;
      canvas_move_stop.width = canvas_move_stop.offsetWidth * dpr_move_stop;
      canvas_move_stop.height = canvas_move_stop.offsetHeight * dpr_move_stop;
      ctx_move_stop.scale(dpr_move_stop, dpr_move_stop);

      // 动画参数
      let bool_stop_stop = false;
      let lastTime_stop = 0;
      const px_per_second_stop = 600;

      // 鼠标位置跟踪
      let lastMouseX_stop = 0;
      let lastMouseY_stop = 0;

      const rect_move_width_stop = 100;
      const rect_move_height_stop = 100;
      let rect_move_x_stop = 0;
      const rect_move_y_stop = (canvas_move_stop.offsetHeight - rect_move_height_stop) / 2;
      const rect_move_fillStyle_stop = "#385";
      const rect_move_strokeStyle_stop = "gold";
      ctx_move_stop.lineWidth = 5;

      function rect_move_draw_stop() {
        ctx_move_stop.clearRect(0, 0, canvas_move_stop.width, canvas_move_stop.height);
        ctx_move_stop.fillStyle = rect_move_fillStyle_stop;
        ctx_move_stop.strokeStyle = rect_move_strokeStyle_stop;
        ctx_move_stop.fillRect(rect_move_x_stop, rect_move_y_stop, rect_move_width_stop, rect_move_height_stop);
        ctx_move_stop.strokeRect(rect_move_x_stop, rect_move_y_stop, rect_move_width_stop, rect_move_height_stop);

        // 如果动画停止，绘制重新播放按钮
        if (bool_stop_stop) {
          // 按钮背景
          const buttonWidth_stop = 120;
          const buttonHeight_stop = 40;
          const buttonX_stop = (canvas_move_stop.offsetWidth - buttonWidth_stop) / 2;
          const buttonY_stop = (canvas_move_stop.offsetHeight - buttonHeight_stop) / 2;

          // 检查鼠标是否悬停在按钮上
          const rect = canvas_move_stop.getBoundingClientRect();
          const mouseX = ((lastMouseX_stop - rect.left) * (canvas_move_stop.width / rect.width)) / dpr_move_stop;
          const mouseY = ((lastMouseY_stop - rect.top) * (canvas_move_stop.height / rect.height)) / dpr_move_stop;

          const isHovering =
            mouseX >= buttonX_stop &&
            mouseX <= buttonX_stop + buttonWidth_stop &&
            mouseY >= buttonY_stop &&
            mouseY <= buttonY_stop + buttonHeight_stop;

          // 绘制按钮背景
          ctx_move_stop.fillStyle = isHovering ? "#2C8F30" : "#2156a3";
          ctx_move_stop.fillRect(buttonX_stop, buttonY_stop, buttonWidth_stop, buttonHeight_stop);

          // 绘制按钮边框
          ctx_move_stop.strokeStyle = "#aaa";
          ctx_move_stop.lineWidth = 1;
          ctx_move_stop.strokeRect(buttonX_stop, buttonY_stop, buttonWidth_stop, buttonHeight_stop);

          // 绘制按钮文字
          ctx_move_stop.fillStyle = "#fff";
          ctx_move_stop.font = "16px sans-serif";
          ctx_move_stop.textAlign = "center";
          ctx_move_stop.textBaseline = "middle";
          ctx_move_stop.fillText("重新播放", buttonX_stop + buttonWidth_stop / 2, buttonY_stop + buttonHeight_stop / 2);
        }
      }

      function draw_move_stop(currentTime) {
        // 计算时间差（毫秒转换为秒）
        const deltaTime_stop = (currentTime - lastTime_stop) / 1000;
        lastTime_stop = currentTime;

        // 基于时间计算移动距离
        const moveDistance_stop = px_per_second_stop * deltaTime_stop;
        rect_move_x_stop += moveDistance_stop;

        // 边界检测
        if (rect_move_x_stop > canvas_move_stop.offsetWidth - rect_move_width_stop) {
          bool_stop_stop = true;
        }

        rect_move_draw_stop();
        if (!bool_stop_stop) {
          requestAnimationFrame(draw_move_stop);
        }
      }

      // 重新播放函数
      function restartAnimation() {
        bool_stop_stop = false;
        rect_move_x_stop = 0;
        // 重置时间，确保从最左方开始
        lastTime_stop = performance.now();
        requestAnimationFrame(draw_move_stop);
      }

      // 鼠标事件处理
      canvas_move_stop.addEventListener("mousemove", function (e) {
        lastMouseX_stop = e.clientX;
        lastMouseY_stop = e.clientY;

        // 如果动画停止，继续绘制以更新按钮悬停效果
        if (bool_stop_stop) {
          rect_move_draw_stop();
        }
      });

      canvas_move_stop.addEventListener("click", function (e) {
        if (bool_stop_stop) {
          const rect = canvas_move_stop.getBoundingClientRect();
          const clickX = ((e.clientX - rect.left) * (canvas_move_stop.width / rect.width)) / dpr_move_stop;
          const clickY = ((e.clientY - rect.top) * (canvas_move_stop.height / rect.height)) / dpr_move_stop;

          const buttonWidth = 120;
          const buttonHeight = 40;
          const buttonX = (canvas_move_stop.offsetWidth - buttonWidth) / 2;
          const buttonY = (canvas_move_stop.offsetHeight - buttonHeight) / 2;

          if (
            clickX >= buttonX &&
            clickX <= buttonX + buttonWidth &&
            clickY >= buttonY &&
            clickY <= buttonY + buttonHeight
          ) {
            restartAnimation();
          }
        }
      });

      // 启动动画，传入当前时间
      requestAnimationFrame(draw_move_stop);
    </script>

    <h3 class="分区标题 分区3级标题">延时动画</h3>
    <p class="分区普通文本">
      核心思想还是用<span class="行内代码">currentTime</span>来计算时间差，当时间差超过<span class="行内专业名词"
        >延时时长</span
      >，就开始运行动画。
    </p>
    <pre class="line-numbers">
      <code class="lang-javascript">
        const 延时时长 = 2000;
        const 动画时长 = 2000;
        let 起始时间 = 0;
        let 动画已开始 = false;

        function 绘制矩形() {
          //绘制逻辑
        }
              
        function animate(currentTime) {
            const 延时已用时 = currentTime - 起始时间;
                        
            // 如果经过时间超过2000ms(2秒)且动画未开始，则开始动画
            if (延时已用时 >= 延时时长 && !动画已开始) {
                动画已开始 = true;
                起始时间 = currentTime;  //更新起始时间，用于计算动画已用时
            }
            
            if (动画已开始) {
                const 动画已用时 = currentTime - 起始时间;
                //这里不要更新"起始时间"，因为这里不是用"两帧之间的移动距离"，而是用"这一帧的整体移动进度"
                //"两帧之间移动的距离"是独立的，"这一帧的整体移动进度"是累积的

                const 水平移动进度 = Math.min(动画已用时 / 动画时长, 1);  // 进度不能超过1
                const 当前矩形水平位置 = 水平移动进度 * canvas.width;
                绘制矩形();
            }
            
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
      </code>
    </pre>
    <figure class="截图容器" style="width: 100%; aspect-ratio: 1.75">
      <canvas id="canvas-delay" style="width: 100%; height: calc(100% - 42px); background-color: #222"></canvas>
    </figure>
    <script>
      const canvas_delay = document.getElementById("canvas-delay");
      const ctx_delay = canvas_delay.getContext("2d");
      const dpr_delay = window.devicePixelRatio || 1;
      canvas_delay.width = canvas_delay.offsetWidth * dpr_delay;
      canvas_delay.height = canvas_delay.offsetHeight * dpr_delay;
      ctx_delay.scale(dpr_delay, dpr_delay);

      // 动画参数
      let lastTime_delay = 0;
      const px_per_second_delay = 400;
      let animationPhase_delay = -1; // -1: 未开始, 0: 延时, 1: 移动, 2: 完成
      let phaseStartTime_delay = 0;
      let delayDuration_delay = 1.0; // 默认延时1秒

      // 矩形参数
      const rect_delay_width = 80;
      const rect_delay_height = 80;
      let rect_delay_x = 0; // 从canvas最左边开始
      const rect_delay_y = (canvas_delay.offsetHeight - rect_delay_height) / 2;
      const rect_delay_fillStyle = "#aa3b4b";
      const rect_delay_strokeStyle = "#aaa";
      ctx_delay.lineWidth = 3;

      // 滑块参数
      const slider_delay_width = 200;
      const slider_delay_height = 20;
      const slider_delay_x = 100;
      const slider_delay_y = canvas_delay.offsetHeight - 60;
      const slider_delay_min = 0.5;
      const slider_delay_max = 3.0;
      const slider_delay_step = 0.5;
      let slider_delay_value = 1.0;
      let isDragging_delay = false;
      let lastMouseX_delay = 0;
      let lastMouseY_delay = 0;

      // 重新播放按钮参数
      const button_delay_width = 100;
      const button_delay_height = 35;
      const button_delay_x = canvas_delay.offsetWidth - button_delay_width - 20;
      const button_delay_y = 20;

      function drawRect_delay() {
        ctx_delay.clearRect(0, 0, canvas_delay.offsetWidth, canvas_delay.offsetHeight);

        // 绘制矩形
        ctx_delay.fillStyle = rect_delay_fillStyle;
        ctx_delay.strokeStyle = rect_delay_strokeStyle;
        ctx_delay.lineWidth = 2;
        ctx_delay.fillRect(rect_delay_x, rect_delay_y, rect_delay_width, rect_delay_height);
        ctx_delay.strokeRect(rect_delay_x, rect_delay_y, rect_delay_width, rect_delay_height);
      }

      function drawSlider_delay() {
        // 绘制"延时时长"文字
        ctx_delay.fillStyle = "silver";
        ctx_delay.font = "16px sans-serif";
        ctx_delay.textAlign = "right";
        ctx_delay.textBaseline = "middle";
        ctx_delay.fillText("延时时长", slider_delay_x - 15, slider_delay_y + 10);

        // 绘制滑块轨道
        ctx_delay.fillStyle = "#333";
        ctx_delay.fillRect(slider_delay_x, slider_delay_y, slider_delay_width, slider_delay_height);

        // 计算滑块位置
        const sliderProgress = (slider_delay_value - slider_delay_min) / (slider_delay_max - slider_delay_min);
        const sliderPosX = slider_delay_x + sliderProgress * slider_delay_width;

        // 绘制已滑过的部分
        ctx_delay.fillStyle = "#4CAF50";
        ctx_delay.fillRect(slider_delay_x, slider_delay_y, sliderPosX - slider_delay_x, slider_delay_height);

        // 检查鼠标是否在滑块上
        const rect = canvas_delay.getBoundingClientRect();
        const mouseX = ((lastMouseX_delay - rect.left) * (canvas_delay.width / rect.width)) / dpr_delay;
        const mouseY = ((lastMouseY_delay - rect.top) * (canvas_delay.height / rect.height)) / dpr_delay;

        const isHovering =
          mouseX >= sliderPosX - 5 &&
          mouseX <= sliderPosX + 5 &&
          mouseY >= slider_delay_y - 5 &&
          mouseY <= slider_delay_y + slider_delay_height + 5;

        // 绘制滑块
        ctx_delay.fillStyle = isHovering || isDragging_delay ? "#ffd700" : "#fff";
        ctx_delay.fillRect(sliderPosX - 5, slider_delay_y - 5, 10, slider_delay_height + 10);
        ctx_delay.strokeStyle = isHovering || isDragging_delay ? "#ffb700" : "#666";
        ctx_delay.lineWidth = isHovering || isDragging_delay ? 2 : 1;
        ctx_delay.strokeRect(sliderPosX - 5, slider_delay_y - 5, 10, slider_delay_height + 10);

        // 绘制数值
        ctx_delay.fillStyle = "lightskyblue";
        ctx_delay.font = "16px 'JetBrains Mono', Consolas, monospace";
        ctx_delay.textAlign = "left";
        ctx_delay.fillText(slider_delay_value + "s", slider_delay_x + slider_delay_width + 15, slider_delay_y + 10);
      }

      function drawButton_delay() {
        // 检查鼠标是否在按钮上
        const rect = canvas_delay.getBoundingClientRect();
        const mouseX = ((lastMouseX_delay - rect.left) * (canvas_delay.width / rect.width)) / dpr_delay;
        const mouseY = ((lastMouseY_delay - rect.top) * (canvas_delay.height / rect.height)) / dpr_delay;

        const isHovering =
          mouseX >= button_delay_x &&
          mouseX <= button_delay_x + button_delay_width &&
          mouseY >= button_delay_y &&
          mouseY <= button_delay_y + button_delay_height;

        // 绘制按钮背景
        ctx_delay.fillStyle = isHovering ? "#2C8F30" : "#2156a3";
        ctx_delay.fillRect(button_delay_x, button_delay_y, button_delay_width, button_delay_height);

        // 绘制按钮边框
        ctx_delay.strokeStyle = "#aaa";
        ctx_delay.lineWidth = 1;
        ctx_delay.strokeRect(button_delay_x, button_delay_y, button_delay_width, button_delay_height);

        // 绘制按钮文字
        ctx_delay.fillStyle = "#fff";
        ctx_delay.font = "14px sans-serif";
        ctx_delay.textAlign = "center";
        ctx_delay.textBaseline = "middle";
        ctx_delay.fillText(
          "重新播放",
          button_delay_x + button_delay_width / 2,
          button_delay_y + button_delay_height / 2
        );
      }

      function drawDelayCountdown_delay(currentTime) {
        const centerX = canvas_delay.offsetWidth / 2;
        const centerY = 50;
        const fontSize = "24px 'JetBrains Mono', Consolas, monospace";

        if (animationPhase_delay === -1) {
          // 未开始状态，显示延时设置
          const text = delayDuration_delay.toFixed(1);
          const unit = "s";

          // 绘制数字
          ctx_delay.fillStyle = "#fff";
          ctx_delay.font = fontSize;
          ctx_delay.textAlign = "right";
          ctx_delay.textBaseline = "middle";
          ctx_delay.fillText(text, centerX, centerY);

          // 绘制单位
          ctx_delay.fillStyle = "darkgoldenrod";
          ctx_delay.textAlign = "left";
          ctx_delay.fillText(unit, centerX, centerY);
        } else if (animationPhase_delay === 0) {
          // 延时阶段，显示倒计时
          const elapsedTime = (currentTime - phaseStartTime_delay) / 1000;
          const remainingTime = Math.max(0, delayDuration_delay - elapsedTime);
          const text = remainingTime.toFixed(1);
          const unit = "s";

          // 绘制数字
          ctx_delay.fillStyle = "#fff";
          ctx_delay.font = fontSize;
          ctx_delay.textAlign = "right";
          ctx_delay.textBaseline = "middle";
          ctx_delay.fillText(text, centerX, centerY);

          // 绘制单位
          ctx_delay.fillStyle = "darkgoldenrod";
          ctx_delay.textAlign = "left";
          ctx_delay.fillText(unit, centerX, centerY);
        } else if (animationPhase_delay === 1) {
          // 移动阶段，显示0.0s
          const text = "0.0";
          const unit = "s";

          // 绘制数字
          ctx_delay.fillStyle = "#fff";
          ctx_delay.font = fontSize;
          ctx_delay.textAlign = "right";
          ctx_delay.textBaseline = "middle";
          ctx_delay.fillText(text, centerX, centerY);

          // 绘制单位
          ctx_delay.fillStyle = "darkgoldenrod";
          ctx_delay.textAlign = "left";
          ctx_delay.fillText(unit, centerX, centerY);
        } else if (animationPhase_delay === 2) {
          // 完成状态，显示0.0s
          const text = "0.0";
          const unit = "s";

          // 绘制数字
          ctx_delay.fillStyle = "#fff";
          ctx_delay.font = fontSize;
          ctx_delay.textAlign = "right";
          ctx_delay.textBaseline = "middle";
          ctx_delay.fillText(text, centerX, centerY);

          // 绘制单位
          ctx_delay.fillStyle = "darkgoldenrod";
          ctx_delay.textAlign = "left";
          ctx_delay.fillText(unit, centerX, centerY);
        }
      }

      function animate_delay(currentTime) {
        // 绘制基础元素
        drawRect_delay();
        drawSlider_delay();
        drawButton_delay();
        drawDelayCountdown_delay(currentTime);

        // 动画逻辑
        switch (animationPhase_delay) {
          case 0: // 延时阶段
            if (currentTime - phaseStartTime_delay >= delayDuration_delay * 1000) {
              animationPhase_delay = 1;
              phaseStartTime_delay = currentTime;
              lastTime_delay = currentTime;
            }
            break;

          case 1: // 移动阶段
            const deltaTime = (currentTime - lastTime_delay) / 1000;
            lastTime_delay = currentTime;

            const moveDistance = px_per_second_delay * deltaTime;
            rect_delay_x += moveDistance;

            // 边界检测
            if (rect_delay_x >= canvas_delay.offsetWidth - rect_delay_width) {
              rect_delay_x = canvas_delay.offsetWidth - rect_delay_width; // 停在最右边
              animationPhase_delay = 2; // 进入完成状态
            }
            break;

          case 2: // 完成状态
            // 动画完成，不再继续
            break;
        }

        // 继续请求下一帧以保持交互功能
        requestAnimationFrame(animate_delay);
      }

      function restartAnimation_delay() {
        animationPhase_delay = 0; // 开始延时阶段
        rect_delay_x = 0; // 重置到canvas最左边
        lastTime_delay = 0;
        delayDuration_delay = slider_delay_value;
        phaseStartTime_delay = performance.now();
        requestAnimationFrame(animate_delay);
      }

      // 鼠标事件处理
      canvas_delay.addEventListener("mousemove", function (e) {
        lastMouseX_delay = e.clientX;
        lastMouseY_delay = e.clientY;

        // 检查鼠标样式
        const rect = canvas_delay.getBoundingClientRect();
        const mouseX = ((e.clientX - rect.left) * (canvas_delay.width / rect.width)) / dpr_delay;
        const mouseY = ((e.clientY - rect.top) * (canvas_delay.height / rect.height)) / dpr_delay;

        // 检查滑块悬停
        const sliderProgress = (slider_delay_value - slider_delay_min) / (slider_delay_max - slider_delay_min);
        const sliderPosX = slider_delay_x + sliderProgress * slider_delay_width;
        const isSliderHovering =
          mouseX >= sliderPosX - 5 &&
          mouseX <= sliderPosX + 5 &&
          mouseY >= slider_delay_y - 5 &&
          mouseY <= slider_delay_y + slider_delay_height + 5;

        // 检查按钮悬停
        const isButtonHovering =
          mouseX >= button_delay_x &&
          mouseX <= button_delay_x + button_delay_width &&
          mouseY >= button_delay_y &&
          mouseY <= button_delay_y + button_delay_height;

        if (isSliderHovering || isDragging_delay) {
          canvas_delay.style.cursor = 'url("/Images/Common/鼠标-指向.cur"), pointer';
        } else if (isButtonHovering) {
          canvas_delay.style.cursor = 'url("/Images/Common/鼠标-指向.cur"), pointer';
        } else {
          canvas_delay.style.cursor = "default";
        }
      });

      canvas_delay.addEventListener("mousedown", function (e) {
        const rect = canvas_delay.getBoundingClientRect();
        const x = ((e.clientX - rect.left) * (canvas_delay.width / rect.width)) / dpr_delay;
        const y = ((e.clientY - rect.top) * (canvas_delay.height / rect.height)) / dpr_delay;

        // 检查是否点击在滑块上
        const sliderProgress = (slider_delay_value - slider_delay_min) / (slider_delay_max - slider_delay_min);
        const sliderPosX = slider_delay_x + sliderProgress * slider_delay_width;

        if (
          x >= sliderPosX - 5 &&
          x <= sliderPosX + 5 &&
          y >= slider_delay_y - 5 &&
          y <= slider_delay_y + slider_delay_height + 5
        ) {
          isDragging_delay = true;
        }
      });

      canvas_delay.addEventListener("mouseup", function (e) {
        if (isDragging_delay) {
          isDragging_delay = false;
        } else {
          // 检查是否点击了重新播放按钮
          const rect = canvas_delay.getBoundingClientRect();
          const x = ((e.clientX - rect.left) * (canvas_delay.width / rect.width)) / dpr_delay;
          const y = ((e.clientY - rect.top) * (canvas_delay.height / rect.height)) / dpr_delay;

          if (
            x >= button_delay_x &&
            x <= button_delay_x + button_delay_width &&
            y >= button_delay_y &&
            y <= button_delay_y + button_delay_height
          ) {
            restartAnimation_delay();
          }
        }
      });

      // 滑块拖拽逻辑
      canvas_delay.addEventListener("mousemove", function (e) {
        if (isDragging_delay) {
          const rect = canvas_delay.getBoundingClientRect();
          const x = ((e.clientX - rect.left) * (canvas_delay.width / rect.width)) / dpr_delay;

          // 计算新的滑块值
          let newValue =
            ((x - slider_delay_x) / slider_delay_width) * (slider_delay_max - slider_delay_min) + slider_delay_min;
          newValue = Math.max(slider_delay_min, Math.min(slider_delay_max, newValue));

          // 按步进值调整
          slider_delay_value = Math.round(newValue / slider_delay_step) * slider_delay_step;
          delayDuration_delay = slider_delay_value;

          // 如果动画未开始，更新显示
          if (animationPhase_delay === -1) {
            requestAnimationFrame(animate_delay);
          }
        }
      });

      canvas_delay.addEventListener("mouseleave", function () {
        canvas_delay.style.cursor = "default";
        isDragging_delay = false;
      });

      // 启动初始绘制（不自动开始动画）
      requestAnimationFrame(animate_delay);
    </script>
  </article>
</div>
