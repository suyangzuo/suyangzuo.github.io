Vue's Single-File Component (SFC) format - with its .vue file extension - is one of the most beloved features among Vue developers. It encapsulates a component's template, script, and style in a single file, making code organization intuitive and maintainable. Unlike other frameworks that separate HTML, CSS, and JS into different files, SFCs keep related code together, reducing the need to switch between files when working on a component. This article will dive deep into the structure of SFCs, explore their key features, and share best practices to help you write clean, efficient SFCs.​
Let's start with the basic structure of an SFC. Every .vue file consists of three optional sections: <template>, <script>, and <style>. The <template> section contains the component's HTML markup, which defines the UI. Vue's template syntax extends HTML with features like directives (v-if, v-for), bindings (v-bind, v-model), and event handlers (v-on), making it easy to create dynamic UIs. For example, a simple "Counter" component's template might include a button that updates a count value and displays the current count.​
The <script> section contains the component's logic, such as data, methods, computed properties, and lifecycle hooks. In Vue 3, you can use either the Options API or the Composition API in the <script> section. For the Options API, you export an object with properties like data, methods, and computed. For the Composition API, you use the setup() function (or the <script setup> syntactic sugar, which we'll cover later) to define reactive state and logic. The <script> section is also where you import other components, libraries, or assets needed for the component.​
The <style> section contains the component's CSS styles. By default, styles in an SFC are scoped to the component - meaning they only apply to elements in the component's template, preventing style leakage to other parts of the app. This is achieved by adding a scoped attribute to the <style> tag (e.g., <style scoped>). Scoped styles are a game-changer for large apps, as they eliminate the need for complex CSS naming conventions (like BEM) to avoid style conflicts. You can also use preprocessors like Sass, Less, or Stylus in the <style> section by adding a lang attribute (e.g., <style scoped lang="scss">).​
One of the most powerful features of SFCs in Vue 3 is <script setup>, a syntactic sugar that simplifies writing Composition API code. <script setup> reduces boilerplate by automatically registering imported components, eliminating the need to return values from setup(), and allowing direct access to reactive state in the template. For example, with <script setup>, you can import a component and use it in the template without adding it to a components object. You can also define reactive state with ref or reactive and use it directly in the template, without returning it from a function. This makes the code shorter, cleaner, and easier to read.​
Another key feature of SFCs is the ability to define multiple <style> sections with different scoping or preprocessor settings. For example, you can have one <style scoped> section for component-specific styles and another <style> section (without scoped) for global styles that apply to the entire app. You can also use scoped with different preprocessors - for instance, a <style scoped lang="scss"> section for Sass styles and a <style scoped lang="less"> section for Less styles (though using multiple preprocessors in one component is generally not recommended for maintainability).​
SFCs also support custom blocks, which allow you to extend the functionality of .vue files. Custom blocks are non-standard sections (like <docs>, <i18n>, or <test>) that can be processed by Vue plugins. For example, the vue-i18n plugin uses a <i18n> block to define component-specific translations, making it easy to manage localization without separate files. The vue-docgen-api plugin uses a <docs> block to generate documentation for components, keeping documentation in sync with the component code. Custom blocks are a powerful way to tailor SFCs to your project's needs, but they require additional tooling to process.​
Now, let's explore best practices for writing SFCs. First, keep components small and focused. A good rule of thumb is that a component should do one thing and do it well. If a component becomes too large (e.g., over 500 lines of code), split it into smaller sub-components. This not only improves maintainability but also helps with performance (as discussed in the previous article). For example, a "CheckoutForm" component that includes billing info, shipping info, and payment options can be split into "BillingForm", "ShippingForm", and "PaymentForm" sub-components.​
Second, use <script setup> for Composition API code (Vue 3 only). <script setup> reduces boilerplate and makes the code more concise, as mentioned earlier. It also improves TypeScript support, as it allows for better type inference. If you're using the Options API, stick to the standard <script> section - but consider migrating to <script setup> for new components, as it's the recommended approach for Vue 3.​
Third, use scoped styles by default. Scoped styles prevent style conflicts and make it easier to reason about where styles apply. If you need to style a child component from a parent component, use deep selectors (e.g., ::v-deep .child-class in Vue 2, or :deep(.child-class) in Vue 3) instead of removing the scoped attribute. Deep selectors allow you to target nested components while keeping the parent's styles scoped.​
Fourth, optimize templates for readability and performance. Avoid complex expressions in templates - instead, use computed properties or methods to encapsulate logic. For example, instead of writing {{ user.name ? user.name : 'Guest' }} in the template, define a computed property userDisplayName that returns the appropriate value. Also, avoid using v-for with v-if on the same element (as v-for has higher priority and can cause unnecessary re-renders) - instead, filter the list with a computed property first.​
Fifth, manage assets efficiently. If a component uses a small image or icon, consider inlining it as a base64 string (using tools like url-loader in Webpack or Vite) to reduce HTTP requests. For larger assets, use lazy loading (as discussed earlier) or CDNs to offload bandwidth. Also, avoid importing large libraries in individual components - instead, import them globally (if used across multiple components) or use tree shaking to include only the parts you need.​
Finally, document your components. Add comments to the <template>, <script>, and <style> sections to explain complex logic or styles. Use custom blocks like <docs> to generate formal documentation, or add JSDoc comments to the <script> section for TypeScript support. Good documentation makes it easier for other developers (or future you) to understand and use the component.​
In conclusion, Vue's Single-File Component format is a powerful tool for building maintainable, organized Vue applications. By understanding its structure, leveraging features like <script setup> and scoped styles, and following best practices for component design and asset management, you can write SFCs that are clean, efficient, and easy to work with. Whether you're building a small app or a large enterprise project, SFCs will help you keep your codebase organized and scalable.
