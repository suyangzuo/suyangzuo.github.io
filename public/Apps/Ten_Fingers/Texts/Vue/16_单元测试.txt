Unit testing is a practice that checks if individual parts of your Vue app - like components or functions - work as expected. It helps catch bugs early, makes refactoring safer, and ensures your app remains stable as it grows. This article covers the basics of Vue unit testing, including tools to use and how to test common component behaviors.​
The main tools for Vue unit testing are Vue Test Utils (the official testing library for Vue) and test runners like Vitest or Jest. Vue Test Utils provides functions to mount components, simulate user interactions, and assert component output. Vitest is a fast, Vite-compatible test runner that's popular for Vue 3 projects, while Jest is a widely used option that works with both Vue 2 and 3.​
To test a simple Vue component (like a Counter component with a button that increments a count), the process usually has three steps. First, mount the component using mount() from Vue Test Utils - this creates a wrapper around the component that lets you interact with it. Second, simulate a user action: for the Counter component, you'd simulate a button click using wrapper.find('button').trigger('click'). Third, assert the result: check if the count has increased by verifying the component's text content or reactive state.​
Testing component props is another common scenario. If you have a UserCard component that takes a name prop and displays it, you can pass the prop when mounting the component and assert that the name appears in the rendered output. This ensures the component correctly uses the props it receives.​
Async components or components that fetch data require a bit more work. For async components loaded with defineAsyncComponent, Vue Test Utils has await mountAsync() to wait for the component to load before testing. For components that fetch data (e.g., in setup() or mounted()), you can mock the API call using tools like Vitest's vi.mock() to return fake data, then assert that the component displays the mocked data correctly.​
Unit testing doesn't have to cover every possible scenario - focus on critical behaviors. For example, test that a form submits with valid data, or that a toggle button shows/hides content. Avoid testing implementation details (like how a component stores internal state) and instead test what the user sees and interacts with.​
In short, Vue unit testing with Vue Test Utils and Vitest/Jest is a straightforward way to keep your components reliable. By testing key behaviors and simulating user actions, you can catch bugs early and build Vue apps that stay stable as they scale.
