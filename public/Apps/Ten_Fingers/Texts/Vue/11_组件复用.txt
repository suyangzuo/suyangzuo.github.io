Reusing code is one of the biggest time-savers in Vue development - it reduces duplication, keeps your codebase clean, and ensures consistency across your app. Vue offers several ways to reuse component logic and UI elements, from mixins (traditional but less flexible) to composables (modern, Vue 3-focused) and slots (for UI reuse). This article explains these techniques and when to use each.​
Let's start with mixins, a Vue 2 staple that's still supported in Vue 3. Mixins are objects that contain component options (like data, methods, or mounted) that can be merged into other components. For example, a loggerMixin might have a mounted hook that logs when a component is created, and a logMessage method to log custom messages. To use it, you add mixins: [loggerMixin] to your component - Vue then merges the mixin's options with the component's own options.​
But mixins have drawbacks. If multiple mixins define the same option (like two mixins with a mounted hook), they can conflict or override each other. It's also hard to track where logic comes from - if a component uses several mixins, you might struggle to find which mixin a method or data property belongs to. For these reasons, mixins are best for simple, single-purpose logic in small apps.​
Composables, introduced in Vue 3 with the Composition API, are a better choice for most modern Vue apps. Composables are functions that encapsulate reactive state and logic, and they're designed to be reusable across components. Unlike mixins, composables are explicit - you import them into a component and call them, so you always know where your logic comes from.​
A common example is a useLocalStorage composable: it might take a key and default value, use ref to create a reactive value, and sync that value with the browser's localStorage (saving when the value changes, loading when the component mounts). To use it, you import useLocalStorage into your component, call const theme = useLocalStorage('theme', 'light'), and then use theme like any other reactive value. Composables also work well with TypeScript, as they can infer types easily.​
For reusing UI elements (not just logic), slots are perfect. Slots let you create "template placeholders" in a component, so parent components can pass in custom content. For example, a Card component might have a slot for the title and a slot for the body. The Card template could look like this: a container with a <slot name="title"> (for the card title) and a <slot name="body"> (for the card content). When using Card, the parent can pass content into these slots - <Card><template #title>My Card</template><template #body>Card content here</template></Card>.​
Slots are flexible: you can have default slots (for content without a name) or scoped slots (which let the child component pass data to the parent's slot content). For example, a List component might use a scoped slot to pass each list item's data to the parent, so the parent can customize how each item is rendered.​
Choosing the right reuse technique depends on your needs: use mixins for simple, legacy Vue 2 logic; use composables for reactive logic in Vue 3; and use slots for reusable UI templates. By reusing code wisely, you'll write less repetitive code, fix bugs faster, and build Vue apps that are easier to maintain.
