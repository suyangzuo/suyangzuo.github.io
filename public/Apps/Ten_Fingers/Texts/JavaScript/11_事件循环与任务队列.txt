The event loop is the heart of JavaScript concurrency. It continuously checks the call stack and, when empty, moves tasks from various queues into the stack. Synchronous code runs immediately, but asynchronous operations such as setTimeout, fetch, or DOM events place their callbacks in queues. The macrotask queue includes timers and I/O, while the microtask queue holds Promise callbacks and queueMicrotask. After each macrotask, the engine drains all microtasks before rendering or sleeping. This explains why Promise.then executes before setTimeout(..., 0). Zero-delay timers are not guaranteed to run immediately; they simply enqueue the callback at the next iteration. Long-running synchronous loops can starve the event loop, freezing the UI. To keep apps responsive, heavy computation should be chunked, deferred with setTimeout, or offloaded to Web Workers. Understanding the loop helps diagnose performance issues, predict execution order in complex async flows, and write smooth animations using requestAnimationFrame. Browser devtools even provide flame graphs to visualize where the main thread spends its time.
