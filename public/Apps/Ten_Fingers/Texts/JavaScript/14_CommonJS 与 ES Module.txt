As projects grow, splitting code into reusable modules becomes essential for maintainability and performance. Node.js popularized CommonJS with require and module.exports. Modules are loaded synchronously, and each file gets its own scope, preventing global leaks. Circular dependencies are handled by returning the current partial exports object. In contrast, ES modules use import and export statements standardized in ES2015. They are statically analyzable, enabling tree-shaking to remove unused code and dead elimination during bundling. Browsers load ES modules asynchronously via script type="module", respecting CORS and executing in strict mode by default. Dynamic import() returns a Promise and can be used inside functions for code-splitting. Node.js supports ES modules when files end with .mjs or when "type": "module" is set in package.json; interoperability allows importing CommonJS from ES modules but not vice versa without dynamic import. Bundlers like Webpack and Rollup abstract away the differences for front-end projects, but understanding both systems helps write isomorphic libraries that run in both environments and prepares codebases for future native ESM adoption.
