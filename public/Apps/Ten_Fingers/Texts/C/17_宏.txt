The C programming language is renowned for its power and efficiency, much of which stems from its compilation process. A crucial, yet often misunderstood, phase of this process is handled by the preprocessor. Before the compiler even sees your code, the preprocessor acts as a dedicated text editor, manipulating the source code based on directives you provide. Among these directives, #define for creating macros is one of the most powerful and potentially dangerous tools in a C programmer's arsenal.
At its most basic, a macro is a fragment of code that has been given a name. Whenever the preprocessor encounters this name in the source code, it replaces it with the defined fragment. This operation is called macro expansion. It is a simple text substitution, devoid of the intelligence of a compiler; it does not understand types, scope, or most of the language's semantics. This simplicity is the source of both its utility and its pitfalls.
Let's start with the simplest form: object-like macros. They are defined using the #define directive followed by the macro name and the replacement text.
In this code, before compilation, every occurrence of BUFFER_SIZE will be replaced by 1024, PI by 3.14159, and so on. This is immensely useful for defining magic numbers. Instead of scattering the literal 1024 throughout your code, you use BUFFER_SIZE. If you need to change the buffer size later, you only change the single #define line, and the update propagates everywhere. This makes code more readable and maintainable.
A step up in complexity are function-like macros. They look like function calls and can take arguments.
