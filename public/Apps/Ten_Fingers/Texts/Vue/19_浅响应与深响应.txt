Vue 3's reactivity system (powered by ES6 Proxies) makes it easy to create reactive state, but not all reactive objects behave the same - there's a key difference between shallow reactive state and deep reactive state. Understanding this difference helps you avoid reactivity bugs and optimize performance by choosing the right API for your use case. This article breaks down shallow vs. deep reactivity in Vue 3.​
Deep reactivity is what most developers expect by default: when you create a reactive object with reactive(), all nested properties of that object are reactive. For example, if you have a user object with a address nested object (const user = reactive({ name: 'Alice', address: { city: 'Paris' } })), changing user.name or user.address.city will trigger reactivity - components using these properties will re-render to reflect the changes. This is ideal for complex state objects where nested properties need to be reactive.​
Shallow reactivity, by contrast, only makes the top-level properties of an object reactive - nested properties are not reactive. Vue 3 provides shallowReactive() for creating shallow reactive objects. Using the same example: const user = shallowReactive({ name: 'Alice', address: { city: 'Paris' } }) - changing user.name will trigger reactivity, but changing user.address.city will not. The nested address object is a plain JavaScript object, not reactive, so updates to it won't be tracked.​
The same distinction applies to ref() and shallowRef(). A regular ref() is deeply reactive: if the ref holds an object (e.g., const user = ref({ name: 'Alice', address: { city: 'Paris' } })), changing user.value.address.city will trigger reactivity. shallowRef(), however, only tracks changes to the value property itself - not to nested properties of the object inside value. For example, const user = shallowRef({ name: 'Alice', address: { city: 'Paris' } }) - changing user.value = { ...user.value, name: 'Bob' } will trigger reactivity, but changing user.value.address.city will not.​
So when should you use shallow reactivity? The main use case is performance optimization for large objects or arrays where nested properties don't need to be reactive. For example, if you have a large list of static data (like a list of countries fetched from an API that never changes), using shallowReactive() or shallowRef() avoids the overhead of making every nested property reactive - this can improve app performance, especially with large datasets.​
Another use case is when you want to manually control reactivity for nested properties. For example, if you have a form object where some fields are static and others are dynamic, you can use shallowReactive() to make only the dynamic top-level fields reactive, while leaving static nested fields as plain objects.​
It's easy to accidentally use the wrong API and create non-reactive nested properties. A common bug is using shallowReactive() for an object with nested properties that need to be reactive - when you update the nested properties, components won't re-render, leading to confusing UI inconsistencies. To avoid this, use reactive() (deep) by default, and only switch to shallow APIs when you have a clear performance reason.​
In summary, Vue 3's shallow and deep reactivity APIs let you tailor reactivity to your state's needs. Use deep reactivity (reactive(), ref()) for state with nested properties that need to be reactive, and shallow reactivity (shallowReactive(), shallowRef()) for large or static objects where nested reactivity isn't needed. By choosing the right API, you ensure your state behaves as expected and your app runs efficiently.
