<article class="专题简介">
  <h1 class="简介标题">输入字符串<span class="原创">原创</span></h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本"><span class="日期文本-数字 日期文本-年">2024</span>年<span class="日期文本-数字 日期文本-月">4</span>月<span class="日期文本-数字 日期文本-日">3</span>日</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://github.com/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://www.deviantart.com/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dev"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://www.freecodecamp.org/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://codepen.io/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://dribbble.com/suyangzuo"
        target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://www.artstation.com/user-7893655"
        target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a
        class="联系方式链接"
        href="https://codesandbox.io/u/suyangzuo"
        target="_blank"
      >
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>

<div class="专题正文区">
  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">
      字符串类型<span class="次要">和</span>输入函数
    </h2>

    <h3 class="分区标题 分区3级标题">字符串类型选择</h3>
    <p class="分区普通文本">
      在<a
        class="超链接"
        target="_blank"
        href="/Blogs/index.html?tech=C语言&article=数组字符串和指针字符串"
        >数组字符串和指针字符串</a
      >专题中，我们知道了C语言的字符串有两种形式，当需要向字符串输入数据时，我们应该用哪一种呢？
    </p>
    <p class="分区普通文本">
      我个人的理解是：输入字符串时，<span class="强调"
        >强烈建议使用数组形式</span
      >，而不是指针形式。理由请查阅本专题<span class="行内专业名词">第4章</span
      >。
    </p>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        使用<span class="行内专业名词">数组字符串</span
        >，至少要多留一个字符的位置给<span class="代码">'\0'</span>。
      </p>
    </section>

    <h3 class="分区标题 分区3级标题">输入函数选择</h3>
    <p class="分区普通文本">
      C语言提供了多个用于输入的函数，可以根据不同的需求进行选择：
    </p>
    <ul class="分区列表">
      <li class="分区列表项">
        字符串包含空白字符：<span class="代码">fgets()</span>
      </li>
      <li class="分区列表项">
        字符串没有空白字符：<span class="代码">scanf()</span>
      </li>
    </ul>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">C语言中的空白字符有 6 种：</p>
      <ul class="分区列表">
        <li class="分区列表项"><span class="代码">' '</span>，空格</li>
        <li class="分区列表项">
          <span class="代码">'\n'</span>，换行<span class="附加说明"
            >按回车键</span
          >
        </li>
        <li class="分区列表项">
          <span class="代码">'\r'</span>，回车<span class="附加说明"
            >不是回车键</span
          >
        </li>
        <li class="分区列表项"><span class="代码">'\t'</span>，水平制表符</li>
        <li class="分区列表项"><span class="代码">'\v'</span>，垂直制表符</li>
        <li class="分区列表项"><span class="代码">'\f'</span>，换页</li>
      </ul>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">
      <span class="行内代码">scanf()</span>函数
    </h2>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">scanf()</span>用法和规则
    </h3>
    <ul class="分区列表">
      <li class="分区列表项">
        使用<span class="代码">%s</span>作为字符串的格式说明符
      </li>
      <li class="分区列表项">忽略前置的空白字符</li>
      <li class="分区列表项">
        从第1个非空白字符开始正常读取，直到再次遇到空白字符
      </li>
      <li class="分区列表项">
        正常读取后遇到的空白字符及其之后的字符会留在缓冲区，包括换行符
      </li>
      <li class="分区列表项">
        会自动在读取的字符后面加上<span class="代码">'\0'</span>字符
      </li>
    </ul>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">scanf()</span>处理字符长度
    </h3>
    <p class="分区普通文本">
      <span class="代码">scanf()</span
      >函数默认不会检查字符的长度，这可能会导致输入的字符长度超出数组长度：
    </p>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/C语言/输入字符串/scanf-超出数组长度.png"
        alt="scanf 输入字符串长度超出数组长度"
      />
    </figure>
    <p class="分区普通文本">
      数组只有 7 个字符的长度，却输入了 14 个字符，再加上<span class="行内代码"
        >'\0'</span
      >，一共 15 字节。在输出结果中，数组占用空间为 7 字节，然而字符串长度却是
      14<span class="附加说明"
        ><span class="行内代码">strlen()</span>函数是不将<span class="行内代码"
          >'\0'</span
        >计算在内的</span
      >。
    </p>
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        这里最危险的地方在于：明明输入的字符串长度超出了数组的限制，编译器却没有报错，运行程序也没有错误！这看似挺让人满意的，实际上会导致无法及时发现一些严重的潜在问题，当这些问题爆发时，程序就会出人意料地崩溃。因此，编写
        C语言 程序时，需要非常小心！
      </p>
    </section>
    <p class="分区普通文本">
      我们显然不能任由这种<span class="强调">明明有错，却不报错</span
      >的情况发生。因此，使用<span class="行内代码">scanf</span
      >函数输入字符串时，我们需要通过格式说明符来<span class="行内专业名词"
        >限制长度</span
      >。
    </p>
    <pre class="line-numbers">
      <code class="lang-c">
        char name[7];
        scanf("%6s", name); //需要留1个字符的位置给'\0'，因此我们可以输入6个字符
      </code>
    </pre>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/C语言/输入字符串/scanf-限制输入长度.png"
        alt="scanf 限制输入长度"
      />
    </figure>
    <p class="分区普通文本">
      虽然输入了 10 个字符，但是<span class="行内代码">scanf</span>只接收了 6
      个字符，再加上自动添加的<span class="行内代码">'\0'</span
      >，刚好符合数组的长度。
    </p>
    <p class="分区普通文本">
      <span class="强调">注意：</span>超出长度的字符<span class="附加说明"
        >包括<span class="行内专业名词">换行符</span></span
      >并未被丢弃，而是被放回了<span class="专业名词">缓冲区</span>。
    </p>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">scanf()</span>处理空白字符
    </h3>
    <p class="分区普通文本">
      <span class="代码">scanf</span
      >不应该用来处理空白字符，但是，万一遇到空白字符，我们应该了解<span
        class="行内代码"
        >scanf</span
      >是怎么运作的，<span class="行内专业名词">2-1</span
      >节已经说明了对于空白字符的处理方式。假如有这样一段代码，连续两次用<span
        class="行内代码"
        >scanf</span
      >输入字符串，并且第一次输入<span class="代码"> su yang↩︎</span
      >会得到什么结果呢？
    </p>
    <pre class="line-numbers">
      <code class="lang-c">
        char name[7];
        printf("第1次输入：");
        scanf("%6s", name);
        printf("姓名：%s\n\n", name, name);

        printf("--------------------------\n\n");

        printf("第2次输入：");
        scanf("%6s", name);
        printf("姓名：%s\n\n", name, name);
      </code>
    </pre>
    <figure class="截图容器">
      <img
        style="background-color: #222"
        src="/Images/Blogs/C语言/输入字符串/连续两次scanf-代码动图.webp"
        alt="连续两次 scanf 代码动图"
      />
    </figure>
    <p class="分区普通文本">
      第一次<span class="代码">scanf</span>等待用户输入了<span class="行内代码">
        su yang↩︎</span
      >，但输出的结果只有<span class="行内代码">su</span>；第二次<span
        class="代码"
        >scanf</span
      >根本就没有等待用户输入，输出的结果是<span class="行内代码">yang</span
      >。请根据<span class="行内专业名词">2-1</span
      >节对空白字符的处理方式，想想为什么是这个结果？哪些字符被忽略？哪些字符被放回了缓冲区？
    </p>
    <p class="分区普通文本">对于上述程序，我们可以用图示的方法来表示：</p>
    <figure class="截图容器">
      <img
        style="background-color: #222"
        src="/Images/Blogs/C语言/输入字符串/连续两次scanf-原理分析.webp"
        alt="连续两次 scanf 原理分析"
      />
    </figure>

    <h3 class="分区标题 分区3级标题">刷新缓冲区</h3>
    <p class="分区普通文本">
      现在大多数的输入函数，都是采用<span class="行内专业名词">缓冲输入</span
      >的方式，先把输入的内容放到<span class="行内专业名词">缓冲区</span
      >，等输入完成后再一起处理。但是，这也造成一些容易让人困扰的问题，比如<span
        class="行内专业名词"
        >输入函数将不符合条件的字符放回了缓冲区</span
      >，而下一个输入函数会优先读取缓冲区，读到的就是上一次残留的字符。
    </p>
    <p class="分区普通文本">
      因此，我们自然而然地想到：有没有办法<span class="行内专业名词"
        >刷新缓冲区</span
      >？答案是：<span class="行内专业名词">有</span>。
    </p>
    <p class="分区普通文本">
      <span class="代码">fflush()</span
      >函数就可以刷新文件流的缓存。如果我们要刷新<span class="行内专业名词"
        >标准输入</span
      ><span class="附加说明">也就是键盘输入</span>的缓冲区，就要把<span
        class="行内代码"
        >stdin</span
      >作为参数。
    </p>
    <pre class="line-numbers">
      <code class="lang-c">
        fflush(stdin); //刷新标准输入的缓冲区
      </code>
    </pre>
    <figure class="截图容器">
      <img
        style="background-color: #222"
        src="/Images/Blogs/C语言/输入字符串/两次scanf之间刷新缓冲区.webp"
        alt="两次scanf之间刷新缓冲区"
      />
    </figure>
    <p class="分区普通文本">
      第二次<span class="行内代码">scanf</span
      >运行之前，刷新了缓冲区，因此可以正常输入字符。
    </p>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">
      <span class="行内代码">fgets()</span>函数
    </h2>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">fgets()</span>用法和规则
    </h3>
    <ul class="分区列表">
      <li class="分区列表项">
        <span class="行内代码">fgets</span
        >是处理文件流的，如果要处理标准输入，要将<span class="行内代码"
          >stdin</span
        >作为第 3 个参数
      </li>
      <li class="分区列表项">通过第 2 个参数，可以控制输入的字符数量</li>
      <li class="分区列表项">可以正常接收空格</li>
      <li class="分区列表项">
        一定会在字符串最后放入<span class="行内代码">'\0'</span>
      </li>
      <li class="分区列表项">
        如果字符串有多余位置，会在<span class="行内代码">'\0'</span>前放入换行符
      </li>
      <li class="分区列表项">如果字符串没有多余位置，换行符会留在缓冲区</li>
      <li class="分区列表项">超出长度的字符会留在缓冲区</li>
    </ul>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">fgets()</span>处理字符长度
    </h3>
    <p class="分区普通文本">
      <span class="行内代码">fgets</span>通过第 2
      个参数来处理输入字符的长度。<span class="强调">注意：</span
      ><span class="行内代码">fgets</span>会留一个字符的位置给<span
        class="行内代码"
        >'\0'</span
      >，因此能够从输入中接收的字符数量是<span class="代码">长度 - 1</span>。
    </p>
    <pre class="line-numbers">
      <code class="lang-c">
        #include &lt;stdio.h&gt;
        #include &lt;windows.h&gt;
        
        #define NAME_LENGTH 7 //定义数组长度
        
        int main(void) {
            SetConsoleOutputCP(CP_UTF8);
        
            char name[NAME_LENGTH];
            printf("输入姓名：");
            fgets(name, NAME_LENGTH, stdin);
            printf("姓名：%s\n", name);
        }
      </code>
    </pre>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/C语言/输入字符串/fgets输入字符超出长度.png"
        alt="fgets 输入字符超出长度"
      />
    </figure>
    <p class="分区普通文本">
      虽然输入了14个字符，实际只接收了6个。因为数组长度为
      7，但会自动留下一个字符的位置给<span class="行内代码">'\0'</span
      >；并且<span class="行内代码">suyang</span
      >后面也没有空行，因为没有多余的位置留给换行符。
    </p>
    <p class="分区普通文本">
      要保留换行符，需要空出 2 个字符的位置，一个给<span class="行内代码"
        >'\n'</span
      >，一个给<span class="行内代码">'\0'</span>。
    </p>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/C语言/输入字符串/fgets输入保留2个字符的位置.png"
        alt="fgets 输入保留2个字符的位置"
      />
    </figure>
    <p class="分区普通文本">
      数组长度为 7，一共输入了 5 个字符，还有 2 个字符的位置留给换行符和<span
        class="行内代码"
        >'\0'</span
      >，因此<span class="行内代码">suyan</span>后面有一个空行。
    </p>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">fgets()</span>处理换行符
    </h3>
    <p class="分区普通文本">
      基本规则很简单：有空位，就放入换行符；没空位，换行符就留在缓冲区。我们尝试连续输入两次姓名，以便理解<span
        class="行内代码"
        >fgets</span
      >如何处理换行符。
    </p>
    <pre class="line-numbers">
      <code class="lang-c">
        #include &lt;stdio.h&gt;
        #include &lt;windows.h&gt;
        
        #define NAME_LENGTH 7 //定义数组长度
        
        int main(void) {
            SetConsoleOutputCP(CP_UTF8);

            char name[NAME_LENGTH];
        
            printf("第1次输入姓名：");
            fgets(name, NAME_LENGTH, stdin);
            printf("姓名：%s\n", name);
        
            printf("--------------------------\n");
        
            printf("第2次输入姓名：");
            fgets(name, NAME_LENGTH, stdin);
            printf("姓名：%s\n", name);
        }
      </code>
    </pre>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/C语言/输入字符串/连续两次fgets.webp"
        alt="连续两次 fgets"
      />
    </figure>
    <p class="分区普通文本">
      第 1 次输入，读取了<span class="代码">su yan</span>共 6 个字符，<span
        class="代码"
        >g↩︎</span
      >留在了缓冲区。因此第二次<span class="行内代码">fgets</span
      >首先读取缓冲区内容，得到的就是<span class="代码">g↩︎</span
      >，因为缓冲区内本身就有换行符，导致第二次<span class="行内代码"
        >fgets</span
      >并没有等待用户输入；同时，<span class="行内代码">name</span>除去<span
        class="行内代码"
        >'\0'</span
      >有 6 个字符的位置，第二次只读取了 2
      个字符，其中一个还是换行符，有充足的空位，因此换行符得以保留，于是我们在<span
        class="行内代码"
        >g</span
      >后面看到了一个空行。这段程序也可以用图示表示。
    </p>
    <figure class="截图容器">
      <img
        style="background-color: #222"
        src="/Images/Blogs/C语言/输入字符串/连续两次fgets-原理分析.webp"
        alt="连续两次fgets 原理分析"
      />
    </figure>
    <p class="分区普通文本">
      <span class="行内代码">fgets</span
      >是可以读取空格的，并且在字符串有多余空位时会保留换行符。
    </p>

    <h3 class="分区标题 分区3级标题">刷新缓冲区</h3>
    <p class="分区普通文本">
      两次<span class="行内代码">fgets</span>之间使用<span class="代码"
        >fflush(stdin)</span
      >即可，具体方法与<span class="行内专业名词">2-4</span>节相同，不再赘述。
    </p>

    <h3 class="分区标题 分区3级标题">替换换行符</h3>
    <p class="分区普通文本">
      绝大多数情况下，我们都会为字符串准备足够的长度，因此<span class="行内代码"
        >fgets</span
      >在绝大多数情况下都会将换行符保存在字符串中。这么做有何意义？在<a
        class="超链接"
        target="_blank"
        href="https://lshoshia.science.tsu.ge/C/Stephen Prata C Primer Plus  2013.pdf"
        >C Primer Plus 第6版</a
      ><span class="行内代码"
        >第11章<span class="附加说明">实际页数：458</span></span
      >中，有这样一段描述：<br /><span class="行内专业名词"
        >The fact that
        <span class="行内代码">fgets()</span>
        stores the newline presents a
        <span style="color: #ec60af">problem</span> and an
        <span style="color: #ec60af">opportunity</span>. The
        <span style="color: #ec60af">problem</span> is that you might not want
        the newline as part of the string you store. The
        <span style="color: #ec60af">opportunity</span> is the presence or
        absence of a newline character in the stored string can be used to tell
        whether the whole line was read. If it wasn’t, then you can decide what
        to do with the rest of the line.
      </span>
    </p>
    <p class="分区普通文本">作者认为：保留换行符有好有坏。</p>
    <p class="分区普通文本">
      <span class="专业名词">优点</span
      >：可以通过换行符来判断是否已经读取了一整行。什么意思呢？<span
        class="行内代码"
        >fgets</span
      >可以用来处理多行数据，每次读取一行。怎么判断一行已经到头了？当然是通过换行符。
    </p>
    <p class="分区普通文本">
      <span class="专业名词">缺点</span
      >：只有一行时，你可能不想要换行符。因此需要想办法将换行符替换成<span
        class="行内代码"
        >'\0'</span
      >。<span class="专业名词">C Primer Plus 第6版</span
      >的作者采用的是简单粗暴<span class="附加说明">但有效</span>的<span
        class="行内代码"
        >while</span
      >循环迭代查找换行符。而我希望能用一些更为优雅的办法。
    </p>
    <ul class="分区列表">
      <li class="分区列表项">
        使用<span class="代码">strchr</span>函数
        <pre>
          <code class="lang-c">
            char* strchr(const char* str, int ch) //函数定义
          </code>
        </pre>
        <p class="分区普通文本">
          定义解释：在字符串<span class="行内代码">str</span>内搜索字符<span
            class="行内代码"
            >ch</span
          >，能找到就返回<span class="行内代码">ch</span
          >的指针，找不到就返回<span class="行内代码">NULL</span>。<br /><span
            class="强调"
            >注意：</span
          >字符<span class="行内代码">ch</span>会被提升为<span class="行内代码"
            >int</span
          >类型进行传递，但函数内部还是会将其作为<span class="行内代码"
            >char</span
          >处理。
        </p>
        <pre class="line-numbers">
          <code class="lang-c">
            #include &lt;stdio.h&gt;
            #include &lt;windows.h&gt;
            #include &lt;string.h&gt; //需要包含此头文件，才能调用strchr()函数
            
            #define NAME_LENGTH 10
            
            int main(void) {
                SetConsoleOutputCP(CP_UTF8);
            
                char name[NAME_LENGTH];
                printf("输入姓名：");
                fgets(name, NAME_LENGTH, stdin);

                //返回的是指向'\n'的指针
                char* p_NewLineChar = strchr(name, '\n');

                //不能保证一定会找到'\n'，因此需要判断此指针是否为NULL
                if (p_NewLineChar)
                    *p_NewLineChar = '\0';
            
                printf("姓名：%s\n", name);
            }
          </code>
        </pre>
        <figure class="截图容器">
          <img
            src="/Images/Blogs/C语言/输入字符串/strchr替换换行符.png"
            alt="strchr 替换换行符"
          />
        </figure>
        <p class="分区普通文本">
          输出结果后面没有空行，说明<span class="行内代码">'\n'</span
          >已被替换成<span class="行内代码">'\0'</span>。
        </p>
      </li>
      <li class="分区列表项">
        使用<span class="代码">strcspn</span>函数
        <pre>
          <code class="lang-c">
            size_t strcspn(const char* str1, const char* str2) //函数定义
          </code>
        </pre>
        <p class="分区普通文本">
          定义解释：在<span class="行内代码">str1</span>内搜索<span
            class="行内代码"
            >str2</span
          >包含的所有字符，计算每个能找到的字符之前的字符数量，取其中的最小值；如果没有找到任何结果，则返回<span
            class="行内代码"
            >str1</span
          >的长度<span class="附加说明"
            >不包含<span class="行内代码">'\0'</span></span
          >。
        </p>
        <p class="分区普通文本">这听上去有些难以理解，让我们举个例子：</p>
        <pre class="line-numbers">
          <code class="lang-c">
            #include &lt;stdio.h&gt;
            #include &lt;windows.h&gt;
            #include &lt;string.h&gt; //需要包含此头文件，才能调用strchr()函数

            int main(void) {
                SetConsoleOutputCP(CP_UTF8);
            
                char name1[] = "suyang";
                char* name2 = "any";

                //在name1内部查找name2包含的所有字符：
                //在name1中查找'a' → 'a'前面有3个字符
                //在name1中查找'n' → 'n'前面有4个字符
                //在name1中查找'y' → 'y'前面有2个字符
                //所有查找结果取最小值，得到 2
                size_t count = strcspn(name1, name2);
                printf("数量: %llu\n", count);
            }
          </code>
        </pre>
        <figure class="截图容器">
          <img
            src="/Images/Blogs/C语言/输入字符串/strcspn案例.png"
            alt="strcspn 案例"
          />
        </figure>
        <p class="分区普通文本">
          <span class="行内代码">"any"</span>包含的所有字符中，首次出现在<span
            class="行内代码"
            >"suyang"</span
          >中且前面的字符最少的就是<span class="行内代码">'y'</span
          >，它的前面只有<span class="行内代码">'s'</span>和<span
            class="行内代码"
            >'u'</span
          >两个字符，所以结果为 2。
        </p>
        <p class="分区普通文本">
          我们可以只查找换行符<span class="行内代码">'\n'</span>，也就是将<span
            class="行内代码"
            >strcspn</span
          >的第二个参数设置为<span class="行内代码">"\n"</span
          ><span class="附加说明">必须是字符串形式</span
          >。试想一下，假设换行符前面有 5 个字符，换行符就是第 6
          个字符，索引为<span class="行内代码">[5]</span>，也就是说<span
            class="行内代码"
            >strcspn</span
          >返回的结果恰好就是换行符的索引。
        </p>
        <pre class="line-numbers">
          <code class="lang-c">
            #include &lt;stdio.h&gt;
            #include &lt;windows.h&gt;
            #include &lt;string.h&gt; //需要包含此头文件，才能调用strcspn()函数

            #define NAME_LENGTH 10

            int main(void) {
                SetConsoleOutputCP(CP_UTF8);

                char name[NAME_LENGTH];
                printf("输入姓名：");
                fgets(name, NAME_LENGTH, stdin);

                size_t count = strcspn(name, "\n");
                if (count < strlen(name)) //如果count等于有效字符数，说明找不到'\n'
                    name[count] = '\0';

                printf("姓名：%s\n", name);
            }
          </code>
        </pre>
        <figure class="截图容器">
          <img
            src="/Images/Blogs/C语言/输入字符串/strcspn替换换行符.png"
            alt="strcspn 替换换行符"
          />
        </figure>
        <p class="分区普通文本">
          输出结果后面没有空行，说明<span class="行内代码">'\n'</span
          >已被替换成<span class="行内代码">'\0'</span>。
        </p>
      </li>
    </ul>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">
      输入字符串到<span class="行内代码">char*</span>
    </h2>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">char*</span>的问题
    </h3>
    <p class="分区普通文本">
      <span class="代码">char*</span
      >类型字符串有个特点，变量和字符串对象是分开的，分别占用不同的内存空间。所以，如果简单地用<span
        class="行内代码"
        >char*</span
      >类型，无法预知需要占用多少内存空间：
    </p>
    <pre class="line-numbers">
      <code class="lang-c">
        #include &lt;stdio.h&gt;
        #include &lt;windows.h&gt;
        int main(void) {
            SetConsoleOutputCP(CP_UTF8);

            char* name; //仅声明指针变量，没有为字符串对象分配内存

            printf("输入姓名：");
            scanf("%s", name); //没有指定输入长度，想输入多长都可以
            printf("姓名：%s\n", name, name);
        }
      </code>
    </pre>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/C语言/输入字符串/指针字符串-scanf.png"
        alt="指针字符串 scanf"
      />
    </figure>
    <p class="分区普通文本">
      从结果看没啥问题，而且输入多长都可以，都会分配足够的内存空间，似乎很爽。但是，这种<span
        class="强调"
        >不受控制</span
      >的行为，<span class="强调">不符合</span>C语言
      <span class="强调">小心谨慎地对待内存</span
      >的编程规范。试想一下，用户可以不受控制地输入任意数量的字符，假如输入<span
        class="行内专业名词"
        >10000</span
      >个字符呢？假如输入一整本三国演义会如何？你确定有这么大的连续内存空间能容纳整本小说？因此，我们应该<span
        class="强调"
        >控制用户的输入</span
      >，不能让用户随意发挥，这对程序是很危险的事。
    </p>

    <h3 class="分区标题 分区3级标题">
      <span class="行内代码">char*</span>怎么用
    </h3>
    <p class="分区普通文本">
      简而言之就是：为<span class="行内代码">char*</span
      >指针所指的字符串对象，事先分配好内存空间。
    </p>
    <pre class="line-numbers">
      <code class="lang-c">
        #include &lt;stdio.h&gt;
        #include &lt;windows.h&gt;
        #include &lt;stdlib.h&gt; //包含此头文件，方可调用 malloc() 函数

        #define NAME_LENGTH 10
        
        int main(void) {
            SetConsoleOutputCP(CP_UTF8);
            
            //事先分配好内存空间，占用空间为：单个字符占用空间 × 字符数量
            //再将 malloc 返回的泛类型指针 void* 转化为特定类型指针 char*
            char* name = (char*)malloc(sizeof(char) * NAME_LENGTH);

            printf("输入姓名：");
            fgets(name, NAME_LENGTH, stdin);
            printf("姓名：%s\n", name);
        }
      </code>
    </pre>
    <p class="分区普通文本">
      问题在于：这么写的话，还不如用数组来得方便。因此，更加推荐使用数组接收字符串输入。
    </p>
  </article>
</div>
