<article class="专题简介">
  <h1 class="简介标题">交叉观察器<span class="原创">原创</span></h1>
  <div class="简介信息">
    <section class="简介信息文本">
      <p class="作者">
        <span class="作者前缀 前缀">作者：</span>
        <span class="作者姓名">苏扬</span>
      </p>
      <p class="日期">
        <span class="日期前缀 前缀">日期：</span>
        <span class="日期文本"><span class="日期文本-数字 日期文本-年">2024</span>年<span class="日期文本-数字 日期文本-月">6</span>月<span class="日期文本-数字 日期文本-日">14</span>日</span>
      </p>
    </section>
    <section class="简介信息图像">
      <img src="/Images/Contributors/苏扬.jpg" alt="苏扬" />
    </section>
  </div>
  <ul class="联系方式列表">
    <li class="联系方式项">
      <a class="联系方式链接" href="mailto:suyangzuo@gmail.com" target="_blank">
        <i class="fa-solid fa-envelope"></i>
      </a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://github.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-github"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.deviantart.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-deviantart"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dev.to/suyangzuo" target="_blank"><i class="fa-brands fa-dev"></i></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.freecodecamp.org/suyangzuo" target="_blank"
        ><i class="fa-brands fa-free-code-camp"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codepen.io/suyangzuo" target="_blank"
        ><i class="fa-brands fa-codepen"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://dribbble.com/suyangzuo" target="_blank"
        ><i class="fa-brands fa-dribbble"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://www.artstation.com/user-7893655" target="_blank"
        ><i class="fa-brands fa-artstation"></i
      ></a>
    </li>
    <li class="联系方式项">
      <a class="联系方式链接" href="https://codesandbox.io/u/suyangzuo" target="_blank">
        <img src="/Images/Page-Logos/CodeSandbox.png" alt="CodeSandbox"
      /></a>
    </li>
  </ul>
</article>
<div class="专题正文区">
  <article class="正文分区">
    <section class="提醒">
      <h3 class="提醒标题">提醒</h3>
      <p class="分区普通文本">
        欢迎访问本站<span class="行内专业名词">交互式学习中心</span>的<a
          class="超链接"
          href="http://localhost:3000/Interactive-Hub/Intersection-Observer/"
          target="_blank"
          >交叉观察器</a
        >页面，获得更佳的交互式体验。
      </p>
    </section>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">交叉观察器简介</h2>

    <h3 class="分区标题 分区3级标题">设计的初衷</h3>
    <p class="分区普通文本">现代网站上经常有下列需求：</p>
    <ul class="分区列表">
      <li class="分区列表项">某个元素滚动到视口内，运行一段动画</li>
      <li class="分区列表项">页面无限滚动，一边滚动一边加载新的内容</li>
      <li class="分区列表项">页面滚动时加载资源</li>
    </ul>
    <p class="分区普通文本">
      早前都是使用事件循环来实现这样的需求，比如：在滚动时不断计算元素的<span class="行内专业名词"
        >边界矩形<span class="附加说明"><span class="行内代码">getBoundingClientRect()</span></span></span
      >。但是，<span class="行内专业名词">JavaScript</span>是一门<span class="行内专业名词">单线程</span
      >语言，这意味着每次滚动所触发的代码程序，都会运行在<span class="行内专业名词">主线程</span
      >上，这会严重影响网站的性能，用户的浏览体验变得很糟糕。
    </p>
    <p class="分区普通文本">
      为了解决这个问题，在 2017年9月，<span class="行内专业名词">Google</span>提出了<a
        class="超链接"
        target="_blank"
        href="https://www.w3.org/TR/2017/WD-intersection-observer-20170914/"
        >第一份交叉观察器的公开工作草案</a
      >。经过多年的发展，现代浏览器已经能够很好地支持交叉观察器。
    </p>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">使用交叉观察器</h2>

    <h3 class="分区标题 分区3级标题">观察器选项</h3>
    <p class="分区普通文本">要使用交叉观察器，首先需要定义几个选项：</p>
    <ul class="分区列表">
      <li class="分区列表项">
        <span class="专业名词">视口元素<span class="行内代码">root</span></span
        >：用作<span class="行内专业名词">观察器的视口</span>，必须是观察目标的祖先；如果不指定，则<span
          class="行内专业名词"
          >默认为浏览器视口</span
        >。
      </li>
      <li class="分区列表项">
        <span class="专业名词">视口元素边距<span class="行内代码">rootMargin</span></span
        >：用来扩大或缩小观察器视口。如果不指定，则<span class="行内专业名词"
          >默认为<span class="行内代码">0</span></span
        >。
      </li>
      <li class="分区列表项">
        <span class="专业名词">阈值<span class="行内代码">threshold</span></span
        >：一个数字或一组数字，指定了目标在视口元素内出现多少才算<span class="行内专业名词">交叉</span
        ><span class="附加说明">即执行回调</span>。如<span class="行内代码">0.5</span>，意味着目标在视口元素内达到<span
          class="行内专业名词"
          >50%可见</span
        >时，就执行回调。如果不指定，则<span class="行内专业名词">默认为<span class="行内代码">0</span></span
        >，意味着目标只要在视口元素内出现<span class="行内代码">1</span>像素，就执行回调。
      </li>
    </ul>

    <h3 class="分区标题 分区3级标题">观察器回调</h3>
    <p class="分区普通文本">
      当目标元素与视口元素的<span class="行内专业名词">交叉比例</span>越过某个<span class="行内专业名词">阈值</span
      >时，执行的函数。
    </p>
    <section class="提醒">
      <h3 class="提醒标题">观察器条目</h3>
      <p class="分区普通文本">
        观察器可以同时观察多个目标，一个目标就会产生一个条目，因此在回调中，会自动接收一个参数叫<span
          class="行内专业名词"
          >条目集合<span class="附加说明"><span class="行内代码">entries</span></span></span
        >，这是一个可迭代对象。
      </p>
      <p class="分区普通文本">
        <span class="强调">注意：</span>即使只观察<span class="行内专业名词">1</span>个元素，传入的参数依然是<span
          class="行内代码"
          >entries<span class="附加说明">复数</span></span
        >，尽管这个集合中只有<span class="行内专业名词">1</span>个条目。
      </p>
    </section>

    <h3 class="分区标题 分区3级标题">代码范例</h3>
    <p class="分区普通文本">假设我们有这样的元素：</p>
    <figure class="截图容器" style="height: 450px">
      <img
        style="height: calc(100% - 41px)"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-初始状态.png"
        alt="交叉观察器-初始状态"
      />
    </figure>
    <p class="分区普通文本">
      现在，我们需要观察<span class="行内专业名词">被观察元素</span>是否与<span class="行内专业名词">视口元素</span
      >交叉。大多数情况下，<span class="行内专业名词">视口元素</span>都会设置为<span class="行内专业名词"
        >浏览器视口</span
      >，因此我们用一个黄色边框模拟浏览器视口。
    </p>
    <p class="分区普通文本">
      完整的<span class="行内专业名词">交叉观察器</span>范例需要用到以下<span class="行内专业名词">4</span>个步骤：
    </p>
    <ol class="分区列表 有序列表">
      <li class="分区列表项">编写选项</li>
      <li class="分区列表项">编写回调函数</li>
      <li class="分区列表项">生成观察器</li>
      <li class="分区列表项">设置观察对象</li>
    </ol>
    <pre class="line-numbers">
      <code class="lang-js">
        const 被观察元素 = document.querySelector(".被观察元素");

        const 选项 = {
          root: null, //视口元素：必须是被观察元素的祖先；不写或设置为"null"，root就是浏览器视口
          rootMargin: "0px", //视口元素外边距：不写相当于设置为0，表示视口保持原本的大小
          threshold: 1, //阈值：1代表100%，意味着被观察元素必须越过"100%可见"的阈值，才会触发回调
        };

        function 回调(条目集合) {
          //每个条目代表一个被观察元素，即使只有一个，传入的参数也是集合
          条目集合.forEach(() => {
            显示回调动画();
          });
        }

        //生成交叉观察器，参数就是回调和选项
        const 观察器 = new IntersectionObserver(回调, 选项);

        //设置观察哪些元素，可以一次性传入多个被观察元素
        观察器.observe(被观察元素);
      </code>
    </pre>

    <h3 class="分区标题 分区3级标题">触发回调的时机</h3>
    <p class="分区普通文本">
      只要跨过<span class="行内代码">threshold</span>这条分界线，就会触发回调。让我们来滚动页面，看看<span
        class="行内专业名词"
        >阈值为<span class="行内代码">100%</span></span
      >到底是什么意思：
    </p>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-百分之百-触发回调.webp"
        alt="交叉观察器-100%-触发回调"
      />
    </figure>
    <p class="分区普通文本">
      被观察元素只要<span class="行内代码">100%</span><span class="强调">跨过</span>视口，就会<span class="行内专业名词"
        >触发回调</span
      >；这个<span class="行内代码">100%</span>是在<span class="行内专业名词">选项</span>的<span class="行内代码"
        >threshold</span
      >属性中设置的。当被观察元素自身的<span class="行内代码">100%</span>处于视口元素内部时，其状态为<span
        class="行内专业名词"
        >交叉中</span
      >；被观察元素位于视口元素内的部分不足<span class="行内代码">100%</span>，状态为<span class="行内专业名词"
        >未交叉</span
      >。
    </p>
    <section class="提醒">
      <h3 class="提醒标题">
        <span class="强调">进</span><span class="次要">与</span><span class="强调">出</span>都算跨过<span
          class="行内专业名词"
          >阈值</span
        >
      </h3>
      <p class="分区普通文本">
        相信你已注意到，不是只有<span class="行内专业名词"
          >从外到内<span class="附加说明">未交叉 &#10145; 交叉中</span></span
        >才会触发回调，<span class="行内专业名词">从内到外<span class="附加说明">交叉中 &#10145; 未交叉</span></span
        >同样会触发。你可以把阈值想象成一条<span class="强调">分界线</span
        >，只要越过分界线，不论从内到外，还是从外到内，都会触发回调函数。
      </p>
      <figure class="截图容器">
        <video
          class="video-js"
          loop
          muted
          autoplay
          preload="auto"
          poster="/Images/Blogs/Web前端-原生开发/交叉观察器/九品芝麻官-poster.png"
          data-setup='{
          "fluid": true
        }'
        >
          <source src="/Images/Blogs/Web前端-原生开发/交叉观察器/九品芝麻官-反复横跳.mp4" type="video/mp4" />
        </video>
      </figure>
      <p class="分区普通文本">黄线就是视口边界，反复横跳的结果，怎一个惨字了得。</p>
    </section>

    <h3 class="分区标题 分区3级标题">阈值</h3>
    <p class="分区普通文本">
      让我们再观察一个<span class="行内专业名词">阈值</span>为<span class="行内代码">50%</span
      >的案例。为了让视觉效果更加直观，我在<span class="行内代码">50%</span>的位置加了一条横线：
    </p>
    <figure class="截图容器">
      <img
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/被观察元素-百分之五十-示意图.png"
        alt="被观察元素-50%-示意图"
      />
    </figure>
    <p class="分区普通文本">
      横线代表<span class="行内代码">50%</span>的位置。为了设置<span class="行内代码">50%</span
      >的阈值，我们需要修改选项中的<span class="行内代码">threshold</span>：
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        const 选项 = {
          root: null,
          rootMargin: "0px",
          threshold: 0.5, //阈值：0.5代表50%，意味着被观察元素必须越过"50%可见"的阈值，才会触发回调
        };
      </code>
    </pre>
    <p class="分区普通文本">现在，让我们来观察效果：</p>
    <figure class="截图容器">
      <img
        style="height: clamp(500px, 75vh, 950px)"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-阈值-百分之五十.webp"
        alt="交叉观察器-阈值-百分之五十"
      />
    </figure>
    <p class="分区普通文本">
      看懂了吗？<span class="行内专业名词">阈值</span>控制着被观察元素的<span class="行内专业名词">百分之多少</span
      >越过视口边界时，会触发回调。
    </p>

    <h3 class="分区标题 分区3级标题">多个阈值</h3>
    <p class="分区普通文本">
      <span class="行内专业名词">阈值</span>可以不止一个，多个阈值可以写成数组形式，<span class="行内专业名词"
        >被观察元素</span
      >在<span class="行内专业名词">视口元素</span>内的可见性只要跨过任何一个阈值，都会触发回调。
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        const 选项 = {
          threshold: [
            0,    //0代表1像素，意味着被观察元素只要越过"1像素可见"的阈值，就会触发回调
            0.25, //25%
            0.5,  //50%
            0.75, //75%
            1     //100%
          ], 
        };
      </code>
    </pre>
    <p class="分区普通文本">
      5个阈值，意味着从<span class="行内专业名词">完全不可见</span>到<span class="行内专业名词">完全可见</span
      >的过程中<span class="附加说明">或者反过来</span>，会触发 5 次回调。
    </p>
    <figure class="截图容器">
      <img
        style="height: clamp(500px, 75vh, 950px)"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-5个阈值.webp"
        alt="交叉观察器-5个阈值"
      />
    </figure>
    <p class="分区普通文本">
      5 个<span class="行内专业名词">阈值</span>，意味着 5 条<span class="行内专业名词">分界线</span>。
    </p>

    <h3 class="分区标题 分区3级标题">视口元素外边距</h3>
    <p class="分区普通文本">
      视口元素外边距的作用很简单：将实际的视口向外扩展，或者向内收缩。假设我们要将实际视口向内收缩：
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        const 选项 = {
          root: null,
          
          //语法和"CSS"的"margin"类似，注意：这里不能用"0"，必须用"0px"
          rootMargin: "-125px -50px", //负值表示向内收缩，上下各125像素，左右各50像素
          threshold: 0.5, //阈值：0意味着被观察元素只要有1个像素约过视口边界，就会触发回调
        };
      </code>
    </pre>
    <p class="分区普通文本">负值代表向内收缩，因此实际视口比视口元素要小。二者关系如下图：</p>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/视口元素-实际视口.png"
        alt="视口元素-实际视口"
      />
    </figure>
    <p class="分区普通文本">
      <span class="强调">注意：</span>实际视口在网页上是看不见的，图中的<span style="color: lightcyan">亮青色</span
      >方框是我特意制作以方便观察用的。 因为水平和垂直都是<span class="行内专业名词">负值</span>，因此实际视口要<span
        class="行内专业名词"
        >小于</span
      >视口元素。反之，<span class="行内专业名词">正值</span>会使实际视口<span class="行内专业名词">大于</span
      >视口元素。让我们来看看效果：
    </p>
    <figure class="截图容器">
      <img
        style="height: clamp(500px, 75vh, 950px)"
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-视口元素外边距.webp"
        alt="交叉观察器-rootMargin"
      />
    </figure>
    <p class="分区普通文本">
      当被观察元素的<span class="行内代码">50%</span>越过视口元素边界时，没有触发回调，因为此时真正的视口是内部的<span
        class="行内专业名词"
        >实际视口</span
      >。
    </p>
  </article>

  <article class="正文分区">
    <h2 class="分区标题 分区2级标题">交叉观察器<span class="行内代码">API</span></h2>

    <h3 class="分区标题 分区3级标题">交叉中</h3>
    <p class="分区普通文本">
      有时，我们只想在<span class="行内专业名词">未交叉 &#10145; 交叉中</span
      >状态运行一些任务，反之则什么都不做。怎么实现呢？交叉观察器有一个非常实用的属性：<span class="行内专业名词"
        >交叉中<span class="附加说明"><span class="行内代码">isIntersecting</span></span></span
      >，此属性为<span class="行内专业名词">布尔类型</span>，可用来判断被观察元素与视口元素当前是否处于交叉状态。
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        //其它代码相同

        function 回调(条目集合) {
          条目集合.forEach((条目) => {
            //仅当处于交叉状态时，才显示回调动画
            if (条目.isIntersecting) {
              显示回调动画();
            }
          });
        }

        //其它代码相同
      </code>
    </pre>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-交叉中-触发回调.webp"
        alt="交叉观察器-交叉中-触发回调"
      />
    </figure>
    <p class="分区普通文本">
      每次越过<span class="行内代码">100%</span
      >临界线时，触发回调，回调内部判断两个元素是否处于交叉状态，具体到本程序而言，会判断被观察元素是否<span
        class="行内代码"
        >100%</span
      >处于视口元素内部，<span class="行内专业名词">是</span>则显示动画。
    </p>

    <h3 class="分区标题 分区3级标题">交叉比例</h3>
    <p class="分区普通文本">
      <span class="行内专业名词">交叉比例</span>表示<span class="行内专业名词">被观察元素</span>在<span
        class="行内专业名词"
        >视口元素</span
      >内的部分占<span class="行内专业名词">被观察元素</span>本身的比例。是不是感觉很像<span class="行内专业名词"
        >阈值</span
      >？按道理，当越过<span class="行内代码">50%</span><span class="行内专业名词">阈值</span>时，<span
        class="行内专业名词"
        >交叉比</span
      >也应该恰好是<span class="行内代码">50%</span>，让我们将<span class="行内专业名词">交叉比</span
      >打印到控制台，看看结果：
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        //其它代码相同
        
        //访问条目的 intersectionRatio，即交叉比例
        function 回调(条目集合) {
          条目集合.forEach((条目) => {
            console.log(条目.intersectionRatio);
          });
        }

        //其它代码相同
      </code>
    </pre>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-交叉比例.webp"
        alt="交叉观察器-打印交叉比例"
      />
    </figure>
    <p class="分区普通文本">
      奇怪，数值并不准确！这是因为从<span class="行内专业名词">跨越阈值线</span>到<span class="行内专业名词"
        >计算交叉比并打印到控制台</span
      >，需要一段时间，这段时间内页面可能依然在滚动，这个时间差对人来说非常之小，但对程序来说足以造成误差。页面滚动越快，误差越大。
    </p>
    <p class="分区普通文本">
      我们可以用<span class="行内专业名词">交叉比</span>来做什么呢？举个例子：可以把<span class="行内专业名词"
        >交叉比</span
      >当做元素背景渐变的色标位置：
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        //其它代码相同
        const 选项 = {
          threshold: [0, 0.25, 0.5, 0.75, 1],
        };

        //访问条目的 intersectionRatio，即交叉比例
        function 回调(条目集合) {
          条目集合.forEach((条目) => {
            被观察元素.style.backgroundImage = `linear-gradient(
              90deg, 
              transparent ${100 - 条目.intersectionRatio * 100}%, 
              rgb(68,96,68) ${100 - 条目.intersectionRatio * 100}%)`;
            
            //为了跟阈值对比，我们把计算后得到的交叉比打印到控制台
            console.log(被观察元素.style.backgroundImage);
          });
        }

        //其它代码相同
      </code>
    </pre>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/阈值-四等份-背景渐变.webp"
        alt="阈值-四等份-背景渐变"
      />
    </figure>
    <p class="分区普通文本">
      从控制台可以看出，大多数情况下<span class="行内专业名词">交叉比</span>和<span class="行内专业名词">阈值</span
      >之间都会有误差。不过，我们可以通过<span class="行内专业名词">视觉误导</span>的手段，让用户<span
        class="行内专业名词"
        >不那么容易觉察到</span
      >误差。比较常见的方式就是<span class="行内专业名词">细分</span>阈值。
    </p>
    <p class="分区普通文本">
      刚刚我们只是把阈值分成了<span class="代码">[0, 0.25, 0.5, 0.75, 1]</span>共<span class="行内代码">5</span
      >段。如果分成<span class="行内代码">100</span>段呢？
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        //其它代码相同
        const 长度 = 101;
        const 跨度 = 0.01;
        const 起点 = 0;
        
        const 选项 = {
          //从0到100，每0.01分一段，长度是101；如果长度为100，只会得到 0 ~ 0.99
          threshold: Array.from({ length: 长度 }, (_, 索引) => 起点 + 索引 * 跨度),
          //第8行写法等同于第10行：
          //threshold: [0, 0.01, 0.02, 0.03, ·····, 0.98, 0.99, 1],
        };

        //访问条目的 intersectionRatio，即交叉比例
        function 回调(条目集合) {
          条目集合.forEach((条目) => {
            被观察元素.style.backgroundImage = `linear-gradient(
              90deg,
              transparent ${100 - 条目.intersectionRatio * 100}%,
              rgb(68,96,68) ${100 - 条目.intersectionRatio * 100}%)`;
          });
        }

        //其它代码相同
      </code>
    </pre>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/阈值-100等份-背景渐变.webp"
        alt="阈值-100等份-背景渐变"
      />
    </figure>
    <p class="分区普通文本">是不是感觉丝滑多了？肉眼很难看出<span class="行内专业名词">误差</span>。</p>

    <h3 class="分区标题 分区3级标题">目标</h3>
    <p class="分区普通文本">
      有时我们需要同时监控多个元素，如何在回调内部识别<span class="行内专业名词">当前触发回调的元素</span
      >呢？答案是：<span class="行内代码">target</span>属性。
    </p>
    <pre class="line-numbers">
      <code class="lang-js">
        //获取多个被观察元素
        const 被观察元素组 = document.querySelectorAll(".被观察元素");

        const 长度 = 201;
        const 步长 = 0.005;
        const 起点 = 0;
        
        const 选项 = {
          threshold: Array.from({ length: 长度 }, (_, i) => 起点 + i * 步长),
        };
        
        function 回调(条目集合) {
          条目集合.forEach((条目) => {
            //条目.target 就是当前触发回调的元素
            const 边框色 = window.getComputedStyle(条目.target).borderColor;
            条目.target.style.backgroundImage = `linear-gradient(
              90deg, 
              transparent ${100 - 条目.intersectionRatio * 100}%, 
              ${边框色} ${100 - 条目.intersectionRatio * 100}%)`;
          });
        }
        
        const 观察者 = new IntersectionObserver(回调, 选项);
        
        //循环迭代，观察组内的所有元素
        for (const 被观察元素 of 被观察元素组) {
          观察者.observe(被观察元素);
        }
      </code>
    </pre>
    <figure class="截图容器">
      <img
        loading="lazy"
        src="/Images/Blogs/Web前端-原生开发/交叉观察器/交叉观察器-条目目标-观察多个元素.webp"
        alt="交叉观察器-条目目标-观察多个元素"
      />
    </figure>
    <p class="分区普通文本">
      <span class="行内代码">target</span>属性能自动获取<span class="行内专业名词">当前触发回调的元素</span
      >，降低了程序的复杂性和重复性。
    </p>
  </article>
</div>